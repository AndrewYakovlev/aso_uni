
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AnonymousUser
 * 
 */
export type AnonymousUser = $Result.DefaultSelection<Prisma.$AnonymousUserPayload>
/**
 * Model PushSubscription
 * 
 */
export type PushSubscription = $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Characteristic
 * 
 */
export type Characteristic = $Result.DefaultSelection<Prisma.$CharacteristicPayload>
/**
 * Model CharacteristicCategory
 * 
 */
export type CharacteristicCategory = $Result.DefaultSelection<Prisma.$CharacteristicCategoryPayload>
/**
 * Model CharacteristicValue
 * 
 */
export type CharacteristicValue = $Result.DefaultSelection<Prisma.$CharacteristicValuePayload>
/**
 * Model ProductCharacteristic
 * 
 */
export type ProductCharacteristic = $Result.DefaultSelection<Prisma.$ProductCharacteristicPayload>
/**
 * Model VehicleMake
 * 
 */
export type VehicleMake = $Result.DefaultSelection<Prisma.$VehicleMakePayload>
/**
 * Model VehicleModel
 * 
 */
export type VehicleModel = $Result.DefaultSelection<Prisma.$VehicleModelPayload>
/**
 * Model VehicleGeneration
 * 
 */
export type VehicleGeneration = $Result.DefaultSelection<Prisma.$VehicleGenerationPayload>
/**
 * Model VehicleModification
 * 
 */
export type VehicleModification = $Result.DefaultSelection<Prisma.$VehicleModificationPayload>
/**
 * Model VehicleApplication
 * 
 */
export type VehicleApplication = $Result.DefaultSelection<Prisma.$VehicleApplicationPayload>
/**
 * Model CrossReference
 * 
 */
export type CrossReference = $Result.DefaultSelection<Prisma.$CrossReferencePayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model ViewHistory
 * 
 */
export type ViewHistory = $Result.DefaultSelection<Prisma.$ViewHistoryPayload>
/**
 * Model Cart
 * 
 */
export type Cart = $Result.DefaultSelection<Prisma.$CartPayload>
/**
 * Model CartItem
 * 
 */
export type CartItem = $Result.DefaultSelection<Prisma.$CartItemPayload>
/**
 * Model ChatProduct
 * 
 */
export type ChatProduct = $Result.DefaultSelection<Prisma.$ChatProductPayload>
/**
 * Model ChatProductImage
 * 
 */
export type ChatProductImage = $Result.DefaultSelection<Prisma.$ChatProductImagePayload>
/**
 * Model ChatStatus
 * 
 */
export type ChatStatus = $Result.DefaultSelection<Prisma.$ChatStatusPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model OrderStatus
 * 
 */
export type OrderStatus = $Result.DefaultSelection<Prisma.$OrderStatusPayload>
/**
 * Model DeliveryMethod
 * 
 */
export type DeliveryMethod = $Result.DefaultSelection<Prisma.$DeliveryMethodPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderStatusLog
 * 
 */
export type OrderStatusLog = $Result.DefaultSelection<Prisma.$OrderStatusLogPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model CustomerGroup
 * 
 */
export type CustomerGroup = $Result.DefaultSelection<Prisma.$CustomerGroupPayload>
/**
 * Model DiscountRule
 * 
 */
export type DiscountRule = $Result.DefaultSelection<Prisma.$DiscountRulePayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model PromoCodeUsage
 * 
 */
export type PromoCodeUsage = $Result.DefaultSelection<Prisma.$PromoCodeUsagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CrossType: {
  OEM: 'OEM',
  AFTERMARKET: 'AFTERMARKET',
  UNIVERSAL: 'UNIVERSAL'
};

export type CrossType = (typeof CrossType)[keyof typeof CrossType]


export const SenderType: {
  CUSTOMER: 'CUSTOMER',
  MANAGER: 'MANAGER',
  SYSTEM: 'SYSTEM'
};

export type SenderType = (typeof SenderType)[keyof typeof SenderType]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  PRODUCT_CARD: 'PRODUCT_CARD',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED: 'FIXED',
  FREE_SHIPPING: 'FREE_SHIPPING'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CrossType = $Enums.CrossType

export const CrossType: typeof $Enums.CrossType

export type SenderType = $Enums.SenderType

export const SenderType: typeof $Enums.SenderType

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anonymousUser`: Exposes CRUD operations for the **AnonymousUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnonymousUsers
    * const anonymousUsers = await prisma.anonymousUser.findMany()
    * ```
    */
  get anonymousUser(): Prisma.AnonymousUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PushSubscriptions
    * const pushSubscriptions = await prisma.pushSubscription.findMany()
    * ```
    */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characteristic`: Exposes CRUD operations for the **Characteristic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characteristics
    * const characteristics = await prisma.characteristic.findMany()
    * ```
    */
  get characteristic(): Prisma.CharacteristicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characteristicCategory`: Exposes CRUD operations for the **CharacteristicCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacteristicCategories
    * const characteristicCategories = await prisma.characteristicCategory.findMany()
    * ```
    */
  get characteristicCategory(): Prisma.CharacteristicCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characteristicValue`: Exposes CRUD operations for the **CharacteristicValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacteristicValues
    * const characteristicValues = await prisma.characteristicValue.findMany()
    * ```
    */
  get characteristicValue(): Prisma.CharacteristicValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productCharacteristic`: Exposes CRUD operations for the **ProductCharacteristic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCharacteristics
    * const productCharacteristics = await prisma.productCharacteristic.findMany()
    * ```
    */
  get productCharacteristic(): Prisma.ProductCharacteristicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleMake`: Exposes CRUD operations for the **VehicleMake** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleMakes
    * const vehicleMakes = await prisma.vehicleMake.findMany()
    * ```
    */
  get vehicleMake(): Prisma.VehicleMakeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleModel`: Exposes CRUD operations for the **VehicleModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleModels
    * const vehicleModels = await prisma.vehicleModel.findMany()
    * ```
    */
  get vehicleModel(): Prisma.VehicleModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleGeneration`: Exposes CRUD operations for the **VehicleGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleGenerations
    * const vehicleGenerations = await prisma.vehicleGeneration.findMany()
    * ```
    */
  get vehicleGeneration(): Prisma.VehicleGenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleModification`: Exposes CRUD operations for the **VehicleModification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleModifications
    * const vehicleModifications = await prisma.vehicleModification.findMany()
    * ```
    */
  get vehicleModification(): Prisma.VehicleModificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicleApplication`: Exposes CRUD operations for the **VehicleApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleApplications
    * const vehicleApplications = await prisma.vehicleApplication.findMany()
    * ```
    */
  get vehicleApplication(): Prisma.VehicleApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crossReference`: Exposes CRUD operations for the **CrossReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CrossReferences
    * const crossReferences = await prisma.crossReference.findMany()
    * ```
    */
  get crossReference(): Prisma.CrossReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewHistory`: Exposes CRUD operations for the **ViewHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewHistories
    * const viewHistories = await prisma.viewHistory.findMany()
    * ```
    */
  get viewHistory(): Prisma.ViewHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **Cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.CartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cartItem`: Exposes CRUD operations for the **CartItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CartItems
    * const cartItems = await prisma.cartItem.findMany()
    * ```
    */
  get cartItem(): Prisma.CartItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatProduct`: Exposes CRUD operations for the **ChatProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatProducts
    * const chatProducts = await prisma.chatProduct.findMany()
    * ```
    */
  get chatProduct(): Prisma.ChatProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatProductImage`: Exposes CRUD operations for the **ChatProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatProductImages
    * const chatProductImages = await prisma.chatProductImage.findMany()
    * ```
    */
  get chatProductImage(): Prisma.ChatProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatStatus`: Exposes CRUD operations for the **ChatStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatStatuses
    * const chatStatuses = await prisma.chatStatus.findMany()
    * ```
    */
  get chatStatus(): Prisma.ChatStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStatus`: Exposes CRUD operations for the **OrderStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatuses
    * const orderStatuses = await prisma.orderStatus.findMany()
    * ```
    */
  get orderStatus(): Prisma.OrderStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryMethod`: Exposes CRUD operations for the **DeliveryMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryMethods
    * const deliveryMethods = await prisma.deliveryMethod.findMany()
    * ```
    */
  get deliveryMethod(): Prisma.DeliveryMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderStatusLog`: Exposes CRUD operations for the **OrderStatusLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatusLogs
    * const orderStatusLogs = await prisma.orderStatusLog.findMany()
    * ```
    */
  get orderStatusLog(): Prisma.OrderStatusLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerGroup`: Exposes CRUD operations for the **CustomerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerGroups
    * const customerGroups = await prisma.customerGroup.findMany()
    * ```
    */
  get customerGroup(): Prisma.CustomerGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discountRule`: Exposes CRUD operations for the **DiscountRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountRules
    * const discountRules = await prisma.discountRule.findMany()
    * ```
    */
  get discountRule(): Prisma.DiscountRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promoCodeUsage`: Exposes CRUD operations for the **PromoCodeUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodeUsages
    * const promoCodeUsages = await prisma.promoCodeUsage.findMany()
    * ```
    */
  get promoCodeUsage(): Prisma.PromoCodeUsageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    AnonymousUser: 'AnonymousUser',
    PushSubscription: 'PushSubscription',
    NotificationSettings: 'NotificationSettings',
    NotificationLog: 'NotificationLog',
    Category: 'Category',
    Product: 'Product',
    ProductCategory: 'ProductCategory',
    ProductImage: 'ProductImage',
    Brand: 'Brand',
    Characteristic: 'Characteristic',
    CharacteristicCategory: 'CharacteristicCategory',
    CharacteristicValue: 'CharacteristicValue',
    ProductCharacteristic: 'ProductCharacteristic',
    VehicleMake: 'VehicleMake',
    VehicleModel: 'VehicleModel',
    VehicleGeneration: 'VehicleGeneration',
    VehicleModification: 'VehicleModification',
    VehicleApplication: 'VehicleApplication',
    CrossReference: 'CrossReference',
    Favorite: 'Favorite',
    ViewHistory: 'ViewHistory',
    Cart: 'Cart',
    CartItem: 'CartItem',
    ChatProduct: 'ChatProduct',
    ChatProductImage: 'ChatProductImage',
    ChatStatus: 'ChatStatus',
    Chat: 'Chat',
    Message: 'Message',
    OrderStatus: 'OrderStatus',
    DeliveryMethod: 'DeliveryMethod',
    PaymentMethod: 'PaymentMethod',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderStatusLog: 'OrderStatusLog',
    Payment: 'Payment',
    CustomerGroup: 'CustomerGroup',
    DiscountRule: 'DiscountRule',
    PromoCode: 'PromoCode',
    PromoCodeUsage: 'PromoCodeUsage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "anonymousUser" | "pushSubscription" | "notificationSettings" | "notificationLog" | "category" | "product" | "productCategory" | "productImage" | "brand" | "characteristic" | "characteristicCategory" | "characteristicValue" | "productCharacteristic" | "vehicleMake" | "vehicleModel" | "vehicleGeneration" | "vehicleModification" | "vehicleApplication" | "crossReference" | "favorite" | "viewHistory" | "cart" | "cartItem" | "chatProduct" | "chatProductImage" | "chatStatus" | "chat" | "message" | "orderStatus" | "deliveryMethod" | "paymentMethod" | "order" | "orderItem" | "orderStatusLog" | "payment" | "customerGroup" | "discountRule" | "promoCode" | "promoCodeUsage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AnonymousUser: {
        payload: Prisma.$AnonymousUserPayload<ExtArgs>
        fields: Prisma.AnonymousUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnonymousUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnonymousUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          findFirst: {
            args: Prisma.AnonymousUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnonymousUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          findMany: {
            args: Prisma.AnonymousUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>[]
          }
          create: {
            args: Prisma.AnonymousUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          createMany: {
            args: Prisma.AnonymousUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnonymousUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>[]
          }
          delete: {
            args: Prisma.AnonymousUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          update: {
            args: Prisma.AnonymousUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          deleteMany: {
            args: Prisma.AnonymousUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnonymousUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnonymousUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>[]
          }
          upsert: {
            args: Prisma.AnonymousUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnonymousUserPayload>
          }
          aggregate: {
            args: Prisma.AnonymousUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnonymousUser>
          }
          groupBy: {
            args: Prisma.AnonymousUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnonymousUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnonymousUserCountArgs<ExtArgs>
            result: $Utils.Optional<AnonymousUserCountAggregateOutputType> | number
          }
        }
      }
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>
        fields: Prisma.PushSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PushSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePushSubscription>
          }
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PushSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Characteristic: {
        payload: Prisma.$CharacteristicPayload<ExtArgs>
        fields: Prisma.CharacteristicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          findFirst: {
            args: Prisma.CharacteristicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          findMany: {
            args: Prisma.CharacteristicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>[]
          }
          create: {
            args: Prisma.CharacteristicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          createMany: {
            args: Prisma.CharacteristicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>[]
          }
          delete: {
            args: Prisma.CharacteristicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          update: {
            args: Prisma.CharacteristicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacteristicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>[]
          }
          upsert: {
            args: Prisma.CharacteristicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          aggregate: {
            args: Prisma.CharacteristicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristic>
          }
          groupBy: {
            args: Prisma.CharacteristicGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicCountAggregateOutputType> | number
          }
        }
      }
      CharacteristicCategory: {
        payload: Prisma.$CharacteristicCategoryPayload<ExtArgs>
        fields: Prisma.CharacteristicCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          findFirst: {
            args: Prisma.CharacteristicCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          findMany: {
            args: Prisma.CharacteristicCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>[]
          }
          create: {
            args: Prisma.CharacteristicCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          createMany: {
            args: Prisma.CharacteristicCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>[]
          }
          delete: {
            args: Prisma.CharacteristicCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          update: {
            args: Prisma.CharacteristicCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacteristicCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>[]
          }
          upsert: {
            args: Prisma.CharacteristicCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicCategoryPayload>
          }
          aggregate: {
            args: Prisma.CharacteristicCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristicCategory>
          }
          groupBy: {
            args: Prisma.CharacteristicCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicCategoryCountAggregateOutputType> | number
          }
        }
      }
      CharacteristicValue: {
        payload: Prisma.$CharacteristicValuePayload<ExtArgs>
        fields: Prisma.CharacteristicValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          findFirst: {
            args: Prisma.CharacteristicValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          findMany: {
            args: Prisma.CharacteristicValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>[]
          }
          create: {
            args: Prisma.CharacteristicValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          createMany: {
            args: Prisma.CharacteristicValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>[]
          }
          delete: {
            args: Prisma.CharacteristicValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          update: {
            args: Prisma.CharacteristicValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacteristicValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>[]
          }
          upsert: {
            args: Prisma.CharacteristicValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicValuePayload>
          }
          aggregate: {
            args: Prisma.CharacteristicValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristicValue>
          }
          groupBy: {
            args: Prisma.CharacteristicValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicValueCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicValueCountAggregateOutputType> | number
          }
        }
      }
      ProductCharacteristic: {
        payload: Prisma.$ProductCharacteristicPayload<ExtArgs>
        fields: Prisma.ProductCharacteristicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCharacteristicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          findFirst: {
            args: Prisma.ProductCharacteristicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCharacteristicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          findMany: {
            args: Prisma.ProductCharacteristicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>[]
          }
          create: {
            args: Prisma.ProductCharacteristicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          createMany: {
            args: Prisma.ProductCharacteristicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCharacteristicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>[]
          }
          delete: {
            args: Prisma.ProductCharacteristicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          update: {
            args: Prisma.ProductCharacteristicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          deleteMany: {
            args: Prisma.ProductCharacteristicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCharacteristicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductCharacteristicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>[]
          }
          upsert: {
            args: Prisma.ProductCharacteristicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          aggregate: {
            args: Prisma.ProductCharacteristicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCharacteristic>
          }
          groupBy: {
            args: Prisma.ProductCharacteristicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCharacteristicCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicCountAggregateOutputType> | number
          }
        }
      }
      VehicleMake: {
        payload: Prisma.$VehicleMakePayload<ExtArgs>
        fields: Prisma.VehicleMakeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleMakeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleMakeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          findFirst: {
            args: Prisma.VehicleMakeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleMakeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          findMany: {
            args: Prisma.VehicleMakeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>[]
          }
          create: {
            args: Prisma.VehicleMakeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          createMany: {
            args: Prisma.VehicleMakeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleMakeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>[]
          }
          delete: {
            args: Prisma.VehicleMakeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          update: {
            args: Prisma.VehicleMakeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          deleteMany: {
            args: Prisma.VehicleMakeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleMakeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleMakeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>[]
          }
          upsert: {
            args: Prisma.VehicleMakeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleMakePayload>
          }
          aggregate: {
            args: Prisma.VehicleMakeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleMake>
          }
          groupBy: {
            args: Prisma.VehicleMakeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleMakeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleMakeCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleMakeCountAggregateOutputType> | number
          }
        }
      }
      VehicleModel: {
        payload: Prisma.$VehicleModelPayload<ExtArgs>
        fields: Prisma.VehicleModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          findFirst: {
            args: Prisma.VehicleModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          findMany: {
            args: Prisma.VehicleModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
          }
          create: {
            args: Prisma.VehicleModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          createMany: {
            args: Prisma.VehicleModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
          }
          delete: {
            args: Prisma.VehicleModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          update: {
            args: Prisma.VehicleModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          deleteMany: {
            args: Prisma.VehicleModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleModelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
          }
          upsert: {
            args: Prisma.VehicleModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModelPayload>
          }
          aggregate: {
            args: Prisma.VehicleModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleModel>
          }
          groupBy: {
            args: Prisma.VehicleModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleModelCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleModelCountAggregateOutputType> | number
          }
        }
      }
      VehicleGeneration: {
        payload: Prisma.$VehicleGenerationPayload<ExtArgs>
        fields: Prisma.VehicleGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          findFirst: {
            args: Prisma.VehicleGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          findMany: {
            args: Prisma.VehicleGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>[]
          }
          create: {
            args: Prisma.VehicleGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          createMany: {
            args: Prisma.VehicleGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>[]
          }
          delete: {
            args: Prisma.VehicleGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          update: {
            args: Prisma.VehicleGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          deleteMany: {
            args: Prisma.VehicleGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleGenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>[]
          }
          upsert: {
            args: Prisma.VehicleGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleGenerationPayload>
          }
          aggregate: {
            args: Prisma.VehicleGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleGeneration>
          }
          groupBy: {
            args: Prisma.VehicleGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleGenerationCountAggregateOutputType> | number
          }
        }
      }
      VehicleModification: {
        payload: Prisma.$VehicleModificationPayload<ExtArgs>
        fields: Prisma.VehicleModificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleModificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleModificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          findFirst: {
            args: Prisma.VehicleModificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleModificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          findMany: {
            args: Prisma.VehicleModificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>[]
          }
          create: {
            args: Prisma.VehicleModificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          createMany: {
            args: Prisma.VehicleModificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleModificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>[]
          }
          delete: {
            args: Prisma.VehicleModificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          update: {
            args: Prisma.VehicleModificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          deleteMany: {
            args: Prisma.VehicleModificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleModificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleModificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>[]
          }
          upsert: {
            args: Prisma.VehicleModificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleModificationPayload>
          }
          aggregate: {
            args: Prisma.VehicleModificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleModification>
          }
          groupBy: {
            args: Prisma.VehicleModificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleModificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleModificationCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleModificationCountAggregateOutputType> | number
          }
        }
      }
      VehicleApplication: {
        payload: Prisma.$VehicleApplicationPayload<ExtArgs>
        fields: Prisma.VehicleApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          findFirst: {
            args: Prisma.VehicleApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          findMany: {
            args: Prisma.VehicleApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>[]
          }
          create: {
            args: Prisma.VehicleApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          createMany: {
            args: Prisma.VehicleApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>[]
          }
          delete: {
            args: Prisma.VehicleApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          update: {
            args: Prisma.VehicleApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          deleteMany: {
            args: Prisma.VehicleApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleApplicationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>[]
          }
          upsert: {
            args: Prisma.VehicleApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleApplicationPayload>
          }
          aggregate: {
            args: Prisma.VehicleApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleApplication>
          }
          groupBy: {
            args: Prisma.VehicleApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleApplicationCountAggregateOutputType> | number
          }
        }
      }
      CrossReference: {
        payload: Prisma.$CrossReferencePayload<ExtArgs>
        fields: Prisma.CrossReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrossReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrossReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          findFirst: {
            args: Prisma.CrossReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrossReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          findMany: {
            args: Prisma.CrossReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>[]
          }
          create: {
            args: Prisma.CrossReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          createMany: {
            args: Prisma.CrossReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrossReferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>[]
          }
          delete: {
            args: Prisma.CrossReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          update: {
            args: Prisma.CrossReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          deleteMany: {
            args: Prisma.CrossReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrossReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrossReferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>[]
          }
          upsert: {
            args: Prisma.CrossReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrossReferencePayload>
          }
          aggregate: {
            args: Prisma.CrossReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrossReference>
          }
          groupBy: {
            args: Prisma.CrossReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrossReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrossReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<CrossReferenceCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      ViewHistory: {
        payload: Prisma.$ViewHistoryPayload<ExtArgs>
        fields: Prisma.ViewHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          findFirst: {
            args: Prisma.ViewHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          findMany: {
            args: Prisma.ViewHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>[]
          }
          create: {
            args: Prisma.ViewHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          createMany: {
            args: Prisma.ViewHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>[]
          }
          delete: {
            args: Prisma.ViewHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          update: {
            args: Prisma.ViewHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ViewHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ViewHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewHistoryPayload>
          }
          aggregate: {
            args: Prisma.ViewHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewHistory>
          }
          groupBy: {
            args: Prisma.ViewHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ViewHistoryCountAggregateOutputType> | number
          }
        }
      }
      Cart: {
        payload: Prisma.$CartPayload<ExtArgs>
        fields: Prisma.CartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findFirst: {
            args: Prisma.CartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          findMany: {
            args: Prisma.CartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          create: {
            args: Prisma.CartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          createMany: {
            args: Prisma.CartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          delete: {
            args: Prisma.CartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          update: {
            args: Prisma.CartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          deleteMany: {
            args: Prisma.CartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>[]
          }
          upsert: {
            args: Prisma.CartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.CartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartCountArgs<ExtArgs>
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      CartItem: {
        payload: Prisma.$CartItemPayload<ExtArgs>
        fields: Prisma.CartItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CartItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CartItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findFirst: {
            args: Prisma.CartItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CartItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          findMany: {
            args: Prisma.CartItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          create: {
            args: Prisma.CartItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          createMany: {
            args: Prisma.CartItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CartItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          delete: {
            args: Prisma.CartItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          update: {
            args: Prisma.CartItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          deleteMany: {
            args: Prisma.CartItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CartItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CartItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>[]
          }
          upsert: {
            args: Prisma.CartItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CartItemPayload>
          }
          aggregate: {
            args: Prisma.CartItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCartItem>
          }
          groupBy: {
            args: Prisma.CartItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CartItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CartItemCountArgs<ExtArgs>
            result: $Utils.Optional<CartItemCountAggregateOutputType> | number
          }
        }
      }
      ChatProduct: {
        payload: Prisma.$ChatProductPayload<ExtArgs>
        fields: Prisma.ChatProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          findFirst: {
            args: Prisma.ChatProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          findMany: {
            args: Prisma.ChatProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>[]
          }
          create: {
            args: Prisma.ChatProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          createMany: {
            args: Prisma.ChatProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>[]
          }
          delete: {
            args: Prisma.ChatProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          update: {
            args: Prisma.ChatProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          deleteMany: {
            args: Prisma.ChatProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>[]
          }
          upsert: {
            args: Prisma.ChatProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductPayload>
          }
          aggregate: {
            args: Prisma.ChatProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatProduct>
          }
          groupBy: {
            args: Prisma.ChatProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatProductCountArgs<ExtArgs>
            result: $Utils.Optional<ChatProductCountAggregateOutputType> | number
          }
        }
      }
      ChatProductImage: {
        payload: Prisma.$ChatProductImagePayload<ExtArgs>
        fields: Prisma.ChatProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          findFirst: {
            args: Prisma.ChatProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          findMany: {
            args: Prisma.ChatProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>[]
          }
          create: {
            args: Prisma.ChatProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          createMany: {
            args: Prisma.ChatProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>[]
          }
          delete: {
            args: Prisma.ChatProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          update: {
            args: Prisma.ChatProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ChatProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ChatProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatProductImagePayload>
          }
          aggregate: {
            args: Prisma.ChatProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatProductImage>
          }
          groupBy: {
            args: Prisma.ChatProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatProductImageCountAggregateOutputType> | number
          }
        }
      }
      ChatStatus: {
        payload: Prisma.$ChatStatusPayload<ExtArgs>
        fields: Prisma.ChatStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          findFirst: {
            args: Prisma.ChatStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          findMany: {
            args: Prisma.ChatStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>[]
          }
          create: {
            args: Prisma.ChatStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          createMany: {
            args: Prisma.ChatStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>[]
          }
          delete: {
            args: Prisma.ChatStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          update: {
            args: Prisma.ChatStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          deleteMany: {
            args: Prisma.ChatStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>[]
          }
          upsert: {
            args: Prisma.ChatStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatStatusPayload>
          }
          aggregate: {
            args: Prisma.ChatStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatStatus>
          }
          groupBy: {
            args: Prisma.ChatStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatStatusCountArgs<ExtArgs>
            result: $Utils.Optional<ChatStatusCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      OrderStatus: {
        payload: Prisma.$OrderStatusPayload<ExtArgs>
        fields: Prisma.OrderStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          findMany: {
            args: Prisma.OrderStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          create: {
            args: Prisma.OrderStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          createMany: {
            args: Prisma.OrderStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          delete: {
            args: Prisma.OrderStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          update: {
            args: Prisma.OrderStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>[]
          }
          upsert: {
            args: Prisma.OrderStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatus>
          }
          groupBy: {
            args: Prisma.OrderStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusCountAggregateOutputType> | number
          }
        }
      }
      DeliveryMethod: {
        payload: Prisma.$DeliveryMethodPayload<ExtArgs>
        fields: Prisma.DeliveryMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          findFirst: {
            args: Prisma.DeliveryMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          findMany: {
            args: Prisma.DeliveryMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>[]
          }
          create: {
            args: Prisma.DeliveryMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          createMany: {
            args: Prisma.DeliveryMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>[]
          }
          delete: {
            args: Prisma.DeliveryMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          update: {
            args: Prisma.DeliveryMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryMethodPayload>
          }
          aggregate: {
            args: Prisma.DeliveryMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryMethod>
          }
          groupBy: {
            args: Prisma.DeliveryMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryMethodCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryMethodCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderStatusLog: {
        payload: Prisma.$OrderStatusLogPayload<ExtArgs>
        fields: Prisma.OrderStatusLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          findMany: {
            args: Prisma.OrderStatusLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>[]
          }
          create: {
            args: Prisma.OrderStatusLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          createMany: {
            args: Prisma.OrderStatusLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderStatusLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>[]
          }
          delete: {
            args: Prisma.OrderStatusLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          update: {
            args: Prisma.OrderStatusLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderStatusLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>[]
          }
          upsert: {
            args: Prisma.OrderStatusLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusLogPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatusLog>
          }
          groupBy: {
            args: Prisma.OrderStatusLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusLogCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusLogCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      CustomerGroup: {
        payload: Prisma.$CustomerGroupPayload<ExtArgs>
        fields: Prisma.CustomerGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findFirst: {
            args: Prisma.CustomerGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findMany: {
            args: Prisma.CustomerGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          create: {
            args: Prisma.CustomerGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          createMany: {
            args: Prisma.CustomerGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          delete: {
            args: Prisma.CustomerGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          update: {
            args: Prisma.CustomerGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          deleteMany: {
            args: Prisma.CustomerGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          upsert: {
            args: Prisma.CustomerGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          aggregate: {
            args: Prisma.CustomerGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerGroup>
          }
          groupBy: {
            args: Prisma.CustomerGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupCountAggregateOutputType> | number
          }
        }
      }
      DiscountRule: {
        payload: Prisma.$DiscountRulePayload<ExtArgs>
        fields: Prisma.DiscountRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findFirst: {
            args: Prisma.DiscountRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          findMany: {
            args: Prisma.DiscountRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          create: {
            args: Prisma.DiscountRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          createMany: {
            args: Prisma.DiscountRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          delete: {
            args: Prisma.DiscountRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          update: {
            args: Prisma.DiscountRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          deleteMany: {
            args: Prisma.DiscountRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>[]
          }
          upsert: {
            args: Prisma.DiscountRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountRulePayload>
          }
          aggregate: {
            args: Prisma.DiscountRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscountRule>
          }
          groupBy: {
            args: Prisma.DiscountRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountRuleCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountRuleCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      PromoCodeUsage: {
        payload: Prisma.$PromoCodeUsagePayload<ExtArgs>
        fields: Prisma.PromoCodeUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          findMany: {
            args: Prisma.PromoCodeUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          create: {
            args: Prisma.PromoCodeUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          createMany: {
            args: Prisma.PromoCodeUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          update: {
            args: Prisma.PromoCodeUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>[]
          }
          upsert: {
            args: Prisma.PromoCodeUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodeUsagePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCodeUsage>
          }
          groupBy: {
            args: Prisma.PromoCodeUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeUsageCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeUsageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    anonymousUser?: AnonymousUserOmit
    pushSubscription?: PushSubscriptionOmit
    notificationSettings?: NotificationSettingsOmit
    notificationLog?: NotificationLogOmit
    category?: CategoryOmit
    product?: ProductOmit
    productCategory?: ProductCategoryOmit
    productImage?: ProductImageOmit
    brand?: BrandOmit
    characteristic?: CharacteristicOmit
    characteristicCategory?: CharacteristicCategoryOmit
    characteristicValue?: CharacteristicValueOmit
    productCharacteristic?: ProductCharacteristicOmit
    vehicleMake?: VehicleMakeOmit
    vehicleModel?: VehicleModelOmit
    vehicleGeneration?: VehicleGenerationOmit
    vehicleModification?: VehicleModificationOmit
    vehicleApplication?: VehicleApplicationOmit
    crossReference?: CrossReferenceOmit
    favorite?: FavoriteOmit
    viewHistory?: ViewHistoryOmit
    cart?: CartOmit
    cartItem?: CartItemOmit
    chatProduct?: ChatProductOmit
    chatProductImage?: ChatProductImageOmit
    chatStatus?: ChatStatusOmit
    chat?: ChatOmit
    message?: MessageOmit
    orderStatus?: OrderStatusOmit
    deliveryMethod?: DeliveryMethodOmit
    paymentMethod?: PaymentMethodOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    orderStatusLog?: OrderStatusLogOmit
    payment?: PaymentOmit
    customerGroup?: CustomerGroupOmit
    discountRule?: DiscountRuleOmit
    promoCode?: PromoCodeOmit
    promoCodeUsage?: PromoCodeUsageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    carts: number
    orders: number
    chats: number
    managedChats: number
    favorites: number
    viewHistory: number
    personalPromoCodes: number
    promoCodeUsage: number
    orderStatusLogs: number
    PushSubscription: number
    NotificationLog: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | UserCountOutputTypeCountCartsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    chats?: boolean | UserCountOutputTypeCountChatsArgs
    managedChats?: boolean | UserCountOutputTypeCountManagedChatsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    viewHistory?: boolean | UserCountOutputTypeCountViewHistoryArgs
    personalPromoCodes?: boolean | UserCountOutputTypeCountPersonalPromoCodesArgs
    promoCodeUsage?: boolean | UserCountOutputTypeCountPromoCodeUsageArgs
    orderStatusLogs?: boolean | UserCountOutputTypeCountOrderStatusLogsArgs
    PushSubscription?: boolean | UserCountOutputTypeCountPushSubscriptionArgs
    NotificationLog?: boolean | UserCountOutputTypeCountNotificationLogArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonalPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPromoCodeUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }


  /**
   * Count Type AnonymousUserCountOutputType
   */

  export type AnonymousUserCountOutputType = {
    carts: number
    chats: number
    viewHistory: number
  }

  export type AnonymousUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | AnonymousUserCountOutputTypeCountCartsArgs
    chats?: boolean | AnonymousUserCountOutputTypeCountChatsArgs
    viewHistory?: boolean | AnonymousUserCountOutputTypeCountViewHistoryArgs
  }

  // Custom InputTypes
  /**
   * AnonymousUserCountOutputType without action
   */
  export type AnonymousUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUserCountOutputType
     */
    select?: AnonymousUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnonymousUserCountOutputType without action
   */
  export type AnonymousUserCountOutputTypeCountCartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
  }

  /**
   * AnonymousUserCountOutputType without action
   */
  export type AnonymousUserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * AnonymousUserCountOutputType without action
   */
  export type AnonymousUserCountOutputTypeCountViewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewHistoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    products: number
    characteristics: number
    viewHistory: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    characteristics?: boolean | CategoryCountOutputTypeCountCharacteristicsArgs
    viewHistory?: boolean | CategoryCountOutputTypeCountViewHistoryArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountViewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewHistoryWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    categories: number
    images: number
    characteristics: number
    vehicleApplications: number
    crossReferences: number
    cartItems: number
    orderItems: number
    favorites: number
    viewHistory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    images?: boolean | ProductCountOutputTypeCountImagesArgs
    characteristics?: boolean | ProductCountOutputTypeCountCharacteristicsArgs
    vehicleApplications?: boolean | ProductCountOutputTypeCountVehicleApplicationsArgs
    crossReferences?: boolean | ProductCountOutputTypeCountCrossReferencesArgs
    cartItems?: boolean | ProductCountOutputTypeCountCartItemsArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    favorites?: boolean | ProductCountOutputTypeCountFavoritesArgs
    viewHistory?: boolean | ProductCountOutputTypeCountViewHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVehicleApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleApplicationWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCrossReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrossReferenceWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountViewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewHistoryWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    products: number
    crossReferences: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BrandCountOutputTypeCountProductsArgs
    crossReferences?: boolean | BrandCountOutputTypeCountCrossReferencesArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountCrossReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrossReferenceWhereInput
  }


  /**
   * Count Type CharacteristicCountOutputType
   */

  export type CharacteristicCountOutputType = {
    values: number
    productValues: number
    categories: number
  }

  export type CharacteristicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | CharacteristicCountOutputTypeCountValuesArgs
    productValues?: boolean | CharacteristicCountOutputTypeCountProductValuesArgs
    categories?: boolean | CharacteristicCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCountOutputType
     */
    select?: CharacteristicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicValueWhereInput
  }

  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeCountProductValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
  }

  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicCategoryWhereInput
  }


  /**
   * Count Type CharacteristicValueCountOutputType
   */

  export type CharacteristicValueCountOutputType = {
    productValues: number
  }

  export type CharacteristicValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productValues?: boolean | CharacteristicValueCountOutputTypeCountProductValuesArgs
  }

  // Custom InputTypes
  /**
   * CharacteristicValueCountOutputType without action
   */
  export type CharacteristicValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValueCountOutputType
     */
    select?: CharacteristicValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacteristicValueCountOutputType without action
   */
  export type CharacteristicValueCountOutputTypeCountProductValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
  }


  /**
   * Count Type VehicleMakeCountOutputType
   */

  export type VehicleMakeCountOutputType = {
    models: number
  }

  export type VehicleMakeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | VehicleMakeCountOutputTypeCountModelsArgs
  }

  // Custom InputTypes
  /**
   * VehicleMakeCountOutputType without action
   */
  export type VehicleMakeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMakeCountOutputType
     */
    select?: VehicleMakeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleMakeCountOutputType without action
   */
  export type VehicleMakeCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleModelWhereInput
  }


  /**
   * Count Type VehicleModelCountOutputType
   */

  export type VehicleModelCountOutputType = {
    generations: number
  }

  export type VehicleModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generations?: boolean | VehicleModelCountOutputTypeCountGenerationsArgs
  }

  // Custom InputTypes
  /**
   * VehicleModelCountOutputType without action
   */
  export type VehicleModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModelCountOutputType
     */
    select?: VehicleModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleModelCountOutputType without action
   */
  export type VehicleModelCountOutputTypeCountGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleGenerationWhereInput
  }


  /**
   * Count Type VehicleGenerationCountOutputType
   */

  export type VehicleGenerationCountOutputType = {
    modifications: number
  }

  export type VehicleGenerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modifications?: boolean | VehicleGenerationCountOutputTypeCountModificationsArgs
  }

  // Custom InputTypes
  /**
   * VehicleGenerationCountOutputType without action
   */
  export type VehicleGenerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGenerationCountOutputType
     */
    select?: VehicleGenerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleGenerationCountOutputType without action
   */
  export type VehicleGenerationCountOutputTypeCountModificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleModificationWhereInput
  }


  /**
   * Count Type VehicleModificationCountOutputType
   */

  export type VehicleModificationCountOutputType = {
    applications: number
  }

  export type VehicleModificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | VehicleModificationCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * VehicleModificationCountOutputType without action
   */
  export type VehicleModificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModificationCountOutputType
     */
    select?: VehicleModificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleModificationCountOutputType without action
   */
  export type VehicleModificationCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleApplicationWhereInput
  }


  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    items: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | CartCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }


  /**
   * Count Type ChatProductCountOutputType
   */

  export type ChatProductCountOutputType = {
    images: number
    cartItems: number
    orderItems: number
  }

  export type ChatProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ChatProductCountOutputTypeCountImagesArgs
    cartItems?: boolean | ChatProductCountOutputTypeCountCartItemsArgs
    orderItems?: boolean | ChatProductCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * ChatProductCountOutputType without action
   */
  export type ChatProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductCountOutputType
     */
    select?: ChatProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatProductCountOutputType without action
   */
  export type ChatProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatProductImageWhereInput
  }

  /**
   * ChatProductCountOutputType without action
   */
  export type ChatProductCountOutputTypeCountCartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
  }

  /**
   * ChatProductCountOutputType without action
   */
  export type ChatProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ChatStatusCountOutputType
   */

  export type ChatStatusCountOutputType = {
    chats: number
  }

  export type ChatStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | ChatStatusCountOutputTypeCountChatsArgs
  }

  // Custom InputTypes
  /**
   * ChatStatusCountOutputType without action
   */
  export type ChatStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatusCountOutputType
     */
    select?: ChatStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatStatusCountOutputType without action
   */
  export type ChatStatusCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    chatProducts: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatProducts?: boolean | MessageCountOutputTypeCountChatProductsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountChatProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatProductWhereInput
  }


  /**
   * Count Type OrderStatusCountOutputType
   */

  export type OrderStatusCountOutputType = {
    orders: number
    orderLogs: number
  }

  export type OrderStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatusCountOutputTypeCountOrdersArgs
    orderLogs?: boolean | OrderStatusCountOutputTypeCountOrderLogsArgs
  }

  // Custom InputTypes
  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusCountOutputType
     */
    select?: OrderStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * OrderStatusCountOutputType without action
   */
  export type OrderStatusCountOutputTypeCountOrderLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusLogWhereInput
  }


  /**
   * Count Type DeliveryMethodCountOutputType
   */

  export type DeliveryMethodCountOutputType = {
    orders: number
  }

  export type DeliveryMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | DeliveryMethodCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * DeliveryMethodCountOutputType without action
   */
  export type DeliveryMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethodCountOutputType
     */
    select?: DeliveryMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryMethodCountOutputType without action
   */
  export type DeliveryMethodCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    orders: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PaymentMethodCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    statusLogs: number
    payments: number
    promoCodeUsage: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    statusLogs?: boolean | OrderCountOutputTypeCountStatusLogsArgs
    payments?: boolean | OrderCountOutputTypeCountPaymentsArgs
    promoCodeUsage?: boolean | OrderCountOutputTypeCountPromoCodeUsageArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusLogWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountPromoCodeUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
  }


  /**
   * Count Type CustomerGroupCountOutputType
   */

  export type CustomerGroupCountOutputType = {
    users: number
    discountRules: number
  }

  export type CustomerGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CustomerGroupCountOutputTypeCountUsersArgs
    discountRules?: boolean | CustomerGroupCountOutputTypeCountDiscountRulesArgs
  }

  // Custom InputTypes
  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupCountOutputType
     */
    select?: CustomerGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeCountDiscountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
  }


  /**
   * Count Type DiscountRuleCountOutputType
   */

  export type DiscountRuleCountOutputType = {
    promoCodes: number
  }

  export type DiscountRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCodes?: boolean | DiscountRuleCountOutputTypeCountPromoCodesArgs
  }

  // Custom InputTypes
  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRuleCountOutputType
     */
    select?: DiscountRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountRuleCountOutputType without action
   */
  export type DiscountRuleCountOutputTypeCountPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }


  /**
   * Count Type PromoCodeCountOutputType
   */

  export type PromoCodeCountOutputType = {
    orders: number
    usage: number
  }

  export type PromoCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PromoCodeCountOutputTypeCountOrdersArgs
    usage?: boolean | PromoCodeCountOutputTypeCountUsageArgs
  }

  // Custom InputTypes
  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeCountOutputType
     */
    select?: PromoCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * PromoCodeCountOutputType without action
   */
  export type PromoCodeCountOutputTypeCountUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    personalDiscount: Decimal | null
  }

  export type UserSumAggregateOutputType = {
    personalDiscount: Decimal | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    phone: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    customerGroupId: string | null
    personalDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    customerGroupId: string | null
    personalDiscount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    phone: number
    email: number
    firstName: number
    lastName: number
    role: number
    customerGroupId: number
    personalDiscount: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    personalDiscount?: true
  }

  export type UserSumAggregateInputType = {
    personalDiscount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    phone?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    customerGroupId?: true
    personalDiscount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    phone?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    customerGroupId?: true
    personalDiscount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    phone?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    customerGroupId?: true
    personalDiscount?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    phone: string
    email: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole
    customerGroupId: string | null
    personalDiscount: Decimal | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    customerGroupId?: boolean
    personalDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    managedChats?: boolean | User$managedChatsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    viewHistory?: boolean | User$viewHistoryArgs<ExtArgs>
    personalPromoCodes?: boolean | User$personalPromoCodesArgs<ExtArgs>
    promoCodeUsage?: boolean | User$promoCodeUsageArgs<ExtArgs>
    orderStatusLogs?: boolean | User$orderStatusLogsArgs<ExtArgs>
    PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>
    NotificationSettings?: boolean | User$NotificationSettingsArgs<ExtArgs>
    NotificationLog?: boolean | User$NotificationLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    customerGroupId?: boolean
    personalDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    customerGroupId?: boolean
    personalDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    phone?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    customerGroupId?: boolean
    personalDiscount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phone" | "email" | "firstName" | "lastName" | "role" | "customerGroupId" | "personalDiscount" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
    carts?: boolean | User$cartsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    managedChats?: boolean | User$managedChatsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    viewHistory?: boolean | User$viewHistoryArgs<ExtArgs>
    personalPromoCodes?: boolean | User$personalPromoCodesArgs<ExtArgs>
    promoCodeUsage?: boolean | User$promoCodeUsageArgs<ExtArgs>
    orderStatusLogs?: boolean | User$orderStatusLogsArgs<ExtArgs>
    PushSubscription?: boolean | User$PushSubscriptionArgs<ExtArgs>
    NotificationSettings?: boolean | User$NotificationSettingsArgs<ExtArgs>
    NotificationLog?: boolean | User$NotificationLogArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | User$customerGroupArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      customerGroup: Prisma.$CustomerGroupPayload<ExtArgs> | null
      carts: Prisma.$CartPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      managedChats: Prisma.$ChatPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      viewHistory: Prisma.$ViewHistoryPayload<ExtArgs>[]
      personalPromoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      promoCodeUsage: Prisma.$PromoCodeUsagePayload<ExtArgs>[]
      orderStatusLogs: Prisma.$OrderStatusLogPayload<ExtArgs>[]
      PushSubscription: Prisma.$PushSubscriptionPayload<ExtArgs>[]
      NotificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs> | null
      NotificationLog: Prisma.$NotificationLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phone: string
      email: string | null
      firstName: string | null
      lastName: string | null
      role: $Enums.UserRole
      customerGroupId: string | null
      personalDiscount: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerGroup<T extends User$customerGroupArgs<ExtArgs> = {}>(args?: Subset<T, User$customerGroupArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    carts<T extends User$cartsArgs<ExtArgs> = {}>(args?: Subset<T, User$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends User$chatsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    managedChats<T extends User$managedChatsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedChatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewHistory<T extends User$viewHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$viewHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalPromoCodes<T extends User$personalPromoCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$personalPromoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodeUsage<T extends User$promoCodeUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$promoCodeUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderStatusLogs<T extends User$orderStatusLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$orderStatusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PushSubscription<T extends User$PushSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$PushSubscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationSettings<T extends User$NotificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationSettingsArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    NotificationLog<T extends User$NotificationLogArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly customerGroupId: FieldRef<"User", 'String'>
    readonly personalDiscount: FieldRef<"User", 'Decimal'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.customerGroup
   */
  export type User$customerGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    where?: CustomerGroupWhereInput
  }

  /**
   * User.carts
   */
  export type User$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.chats
   */
  export type User$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.managedChats
   */
  export type User$managedChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.viewHistory
   */
  export type User$viewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    where?: ViewHistoryWhereInput
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    cursor?: ViewHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * User.personalPromoCodes
   */
  export type User$personalPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * User.promoCodeUsage
   */
  export type User$promoCodeUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    cursor?: PromoCodeUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * User.orderStatusLogs
   */
  export type User$orderStatusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    where?: OrderStatusLogWhereInput
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    cursor?: OrderStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * User.PushSubscription
   */
  export type User$PushSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    cursor?: PushSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * User.NotificationSettings
   */
  export type User$NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
  }

  /**
   * User.NotificationLog
   */
  export type User$NotificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AnonymousUser
   */

  export type AggregateAnonymousUser = {
    _count: AnonymousUserCountAggregateOutputType | null
    _min: AnonymousUserMinAggregateOutputType | null
    _max: AnonymousUserMaxAggregateOutputType | null
  }

  export type AnonymousUserMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    lastActivity: Date | null
  }

  export type AnonymousUserMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
    lastActivity: Date | null
  }

  export type AnonymousUserCountAggregateOutputType = {
    id: number
    sessionId: number
    ipAddress: number
    userAgent: number
    createdAt: number
    lastActivity: number
    _all: number
  }


  export type AnonymousUserMinAggregateInputType = {
    id?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    lastActivity?: true
  }

  export type AnonymousUserMaxAggregateInputType = {
    id?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    lastActivity?: true
  }

  export type AnonymousUserCountAggregateInputType = {
    id?: true
    sessionId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    lastActivity?: true
    _all?: true
  }

  export type AnonymousUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousUser to aggregate.
     */
    where?: AnonymousUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousUsers to fetch.
     */
    orderBy?: AnonymousUserOrderByWithRelationInput | AnonymousUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnonymousUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnonymousUsers
    **/
    _count?: true | AnonymousUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnonymousUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnonymousUserMaxAggregateInputType
  }

  export type GetAnonymousUserAggregateType<T extends AnonymousUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAnonymousUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnonymousUser[P]>
      : GetScalarType<T[P], AggregateAnonymousUser[P]>
  }




  export type AnonymousUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnonymousUserWhereInput
    orderBy?: AnonymousUserOrderByWithAggregationInput | AnonymousUserOrderByWithAggregationInput[]
    by: AnonymousUserScalarFieldEnum[] | AnonymousUserScalarFieldEnum
    having?: AnonymousUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnonymousUserCountAggregateInputType | true
    _min?: AnonymousUserMinAggregateInputType
    _max?: AnonymousUserMaxAggregateInputType
  }

  export type AnonymousUserGroupByOutputType = {
    id: string
    sessionId: string
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    lastActivity: Date
    _count: AnonymousUserCountAggregateOutputType | null
    _min: AnonymousUserMinAggregateOutputType | null
    _max: AnonymousUserMaxAggregateOutputType | null
  }

  type GetAnonymousUserGroupByPayload<T extends AnonymousUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnonymousUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnonymousUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnonymousUserGroupByOutputType[P]>
            : GetScalarType<T[P], AnonymousUserGroupByOutputType[P]>
        }
      >
    >


  export type AnonymousUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    lastActivity?: boolean
    carts?: boolean | AnonymousUser$cartsArgs<ExtArgs>
    chats?: boolean | AnonymousUser$chatsArgs<ExtArgs>
    viewHistory?: boolean | AnonymousUser$viewHistoryArgs<ExtArgs>
    _count?: boolean | AnonymousUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anonymousUser"]>

  export type AnonymousUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    lastActivity?: boolean
  }, ExtArgs["result"]["anonymousUser"]>

  export type AnonymousUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    lastActivity?: boolean
  }, ExtArgs["result"]["anonymousUser"]>

  export type AnonymousUserSelectScalar = {
    id?: boolean
    sessionId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    lastActivity?: boolean
  }

  export type AnonymousUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "ipAddress" | "userAgent" | "createdAt" | "lastActivity", ExtArgs["result"]["anonymousUser"]>
  export type AnonymousUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    carts?: boolean | AnonymousUser$cartsArgs<ExtArgs>
    chats?: boolean | AnonymousUser$chatsArgs<ExtArgs>
    viewHistory?: boolean | AnonymousUser$viewHistoryArgs<ExtArgs>
    _count?: boolean | AnonymousUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnonymousUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AnonymousUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnonymousUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnonymousUser"
    objects: {
      carts: Prisma.$CartPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      viewHistory: Prisma.$ViewHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      lastActivity: Date
    }, ExtArgs["result"]["anonymousUser"]>
    composites: {}
  }

  type AnonymousUserGetPayload<S extends boolean | null | undefined | AnonymousUserDefaultArgs> = $Result.GetResult<Prisma.$AnonymousUserPayload, S>

  type AnonymousUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnonymousUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnonymousUserCountAggregateInputType | true
    }

  export interface AnonymousUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnonymousUser'], meta: { name: 'AnonymousUser' } }
    /**
     * Find zero or one AnonymousUser that matches the filter.
     * @param {AnonymousUserFindUniqueArgs} args - Arguments to find a AnonymousUser
     * @example
     * // Get one AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnonymousUserFindUniqueArgs>(args: SelectSubset<T, AnonymousUserFindUniqueArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnonymousUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnonymousUserFindUniqueOrThrowArgs} args - Arguments to find a AnonymousUser
     * @example
     * // Get one AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnonymousUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AnonymousUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnonymousUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserFindFirstArgs} args - Arguments to find a AnonymousUser
     * @example
     * // Get one AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnonymousUserFindFirstArgs>(args?: SelectSubset<T, AnonymousUserFindFirstArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnonymousUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserFindFirstOrThrowArgs} args - Arguments to find a AnonymousUser
     * @example
     * // Get one AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnonymousUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AnonymousUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnonymousUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnonymousUsers
     * const anonymousUsers = await prisma.anonymousUser.findMany()
     * 
     * // Get first 10 AnonymousUsers
     * const anonymousUsers = await prisma.anonymousUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anonymousUserWithIdOnly = await prisma.anonymousUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnonymousUserFindManyArgs>(args?: SelectSubset<T, AnonymousUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnonymousUser.
     * @param {AnonymousUserCreateArgs} args - Arguments to create a AnonymousUser.
     * @example
     * // Create one AnonymousUser
     * const AnonymousUser = await prisma.anonymousUser.create({
     *   data: {
     *     // ... data to create a AnonymousUser
     *   }
     * })
     * 
     */
    create<T extends AnonymousUserCreateArgs>(args: SelectSubset<T, AnonymousUserCreateArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnonymousUsers.
     * @param {AnonymousUserCreateManyArgs} args - Arguments to create many AnonymousUsers.
     * @example
     * // Create many AnonymousUsers
     * const anonymousUser = await prisma.anonymousUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnonymousUserCreateManyArgs>(args?: SelectSubset<T, AnonymousUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnonymousUsers and returns the data saved in the database.
     * @param {AnonymousUserCreateManyAndReturnArgs} args - Arguments to create many AnonymousUsers.
     * @example
     * // Create many AnonymousUsers
     * const anonymousUser = await prisma.anonymousUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnonymousUsers and only return the `id`
     * const anonymousUserWithIdOnly = await prisma.anonymousUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnonymousUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AnonymousUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnonymousUser.
     * @param {AnonymousUserDeleteArgs} args - Arguments to delete one AnonymousUser.
     * @example
     * // Delete one AnonymousUser
     * const AnonymousUser = await prisma.anonymousUser.delete({
     *   where: {
     *     // ... filter to delete one AnonymousUser
     *   }
     * })
     * 
     */
    delete<T extends AnonymousUserDeleteArgs>(args: SelectSubset<T, AnonymousUserDeleteArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnonymousUser.
     * @param {AnonymousUserUpdateArgs} args - Arguments to update one AnonymousUser.
     * @example
     * // Update one AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnonymousUserUpdateArgs>(args: SelectSubset<T, AnonymousUserUpdateArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnonymousUsers.
     * @param {AnonymousUserDeleteManyArgs} args - Arguments to filter AnonymousUsers to delete.
     * @example
     * // Delete a few AnonymousUsers
     * const { count } = await prisma.anonymousUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnonymousUserDeleteManyArgs>(args?: SelectSubset<T, AnonymousUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnonymousUsers
     * const anonymousUser = await prisma.anonymousUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnonymousUserUpdateManyArgs>(args: SelectSubset<T, AnonymousUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnonymousUsers and returns the data updated in the database.
     * @param {AnonymousUserUpdateManyAndReturnArgs} args - Arguments to update many AnonymousUsers.
     * @example
     * // Update many AnonymousUsers
     * const anonymousUser = await prisma.anonymousUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnonymousUsers and only return the `id`
     * const anonymousUserWithIdOnly = await prisma.anonymousUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnonymousUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AnonymousUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnonymousUser.
     * @param {AnonymousUserUpsertArgs} args - Arguments to update or create a AnonymousUser.
     * @example
     * // Update or create a AnonymousUser
     * const anonymousUser = await prisma.anonymousUser.upsert({
     *   create: {
     *     // ... data to create a AnonymousUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnonymousUser we want to update
     *   }
     * })
     */
    upsert<T extends AnonymousUserUpsertArgs>(args: SelectSubset<T, AnonymousUserUpsertArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnonymousUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserCountArgs} args - Arguments to filter AnonymousUsers to count.
     * @example
     * // Count the number of AnonymousUsers
     * const count = await prisma.anonymousUser.count({
     *   where: {
     *     // ... the filter for the AnonymousUsers we want to count
     *   }
     * })
    **/
    count<T extends AnonymousUserCountArgs>(
      args?: Subset<T, AnonymousUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnonymousUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnonymousUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnonymousUserAggregateArgs>(args: Subset<T, AnonymousUserAggregateArgs>): Prisma.PrismaPromise<GetAnonymousUserAggregateType<T>>

    /**
     * Group by AnonymousUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnonymousUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnonymousUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnonymousUserGroupByArgs['orderBy'] }
        : { orderBy?: AnonymousUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnonymousUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnonymousUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnonymousUser model
   */
  readonly fields: AnonymousUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnonymousUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnonymousUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    carts<T extends AnonymousUser$cartsArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousUser$cartsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends AnonymousUser$chatsArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousUser$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewHistory<T extends AnonymousUser$viewHistoryArgs<ExtArgs> = {}>(args?: Subset<T, AnonymousUser$viewHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnonymousUser model
   */
  interface AnonymousUserFieldRefs {
    readonly id: FieldRef<"AnonymousUser", 'String'>
    readonly sessionId: FieldRef<"AnonymousUser", 'String'>
    readonly ipAddress: FieldRef<"AnonymousUser", 'String'>
    readonly userAgent: FieldRef<"AnonymousUser", 'String'>
    readonly createdAt: FieldRef<"AnonymousUser", 'DateTime'>
    readonly lastActivity: FieldRef<"AnonymousUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnonymousUser findUnique
   */
  export type AnonymousUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousUser to fetch.
     */
    where: AnonymousUserWhereUniqueInput
  }

  /**
   * AnonymousUser findUniqueOrThrow
   */
  export type AnonymousUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousUser to fetch.
     */
    where: AnonymousUserWhereUniqueInput
  }

  /**
   * AnonymousUser findFirst
   */
  export type AnonymousUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousUser to fetch.
     */
    where?: AnonymousUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousUsers to fetch.
     */
    orderBy?: AnonymousUserOrderByWithRelationInput | AnonymousUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousUsers.
     */
    cursor?: AnonymousUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousUsers.
     */
    distinct?: AnonymousUserScalarFieldEnum | AnonymousUserScalarFieldEnum[]
  }

  /**
   * AnonymousUser findFirstOrThrow
   */
  export type AnonymousUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousUser to fetch.
     */
    where?: AnonymousUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousUsers to fetch.
     */
    orderBy?: AnonymousUserOrderByWithRelationInput | AnonymousUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnonymousUsers.
     */
    cursor?: AnonymousUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnonymousUsers.
     */
    distinct?: AnonymousUserScalarFieldEnum | AnonymousUserScalarFieldEnum[]
  }

  /**
   * AnonymousUser findMany
   */
  export type AnonymousUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter, which AnonymousUsers to fetch.
     */
    where?: AnonymousUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnonymousUsers to fetch.
     */
    orderBy?: AnonymousUserOrderByWithRelationInput | AnonymousUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnonymousUsers.
     */
    cursor?: AnonymousUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnonymousUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnonymousUsers.
     */
    skip?: number
    distinct?: AnonymousUserScalarFieldEnum | AnonymousUserScalarFieldEnum[]
  }

  /**
   * AnonymousUser create
   */
  export type AnonymousUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AnonymousUser.
     */
    data: XOR<AnonymousUserCreateInput, AnonymousUserUncheckedCreateInput>
  }

  /**
   * AnonymousUser createMany
   */
  export type AnonymousUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnonymousUsers.
     */
    data: AnonymousUserCreateManyInput | AnonymousUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousUser createManyAndReturn
   */
  export type AnonymousUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * The data used to create many AnonymousUsers.
     */
    data: AnonymousUserCreateManyInput | AnonymousUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnonymousUser update
   */
  export type AnonymousUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AnonymousUser.
     */
    data: XOR<AnonymousUserUpdateInput, AnonymousUserUncheckedUpdateInput>
    /**
     * Choose, which AnonymousUser to update.
     */
    where: AnonymousUserWhereUniqueInput
  }

  /**
   * AnonymousUser updateMany
   */
  export type AnonymousUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnonymousUsers.
     */
    data: XOR<AnonymousUserUpdateManyMutationInput, AnonymousUserUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousUsers to update
     */
    where?: AnonymousUserWhereInput
    /**
     * Limit how many AnonymousUsers to update.
     */
    limit?: number
  }

  /**
   * AnonymousUser updateManyAndReturn
   */
  export type AnonymousUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * The data used to update AnonymousUsers.
     */
    data: XOR<AnonymousUserUpdateManyMutationInput, AnonymousUserUncheckedUpdateManyInput>
    /**
     * Filter which AnonymousUsers to update
     */
    where?: AnonymousUserWhereInput
    /**
     * Limit how many AnonymousUsers to update.
     */
    limit?: number
  }

  /**
   * AnonymousUser upsert
   */
  export type AnonymousUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AnonymousUser to update in case it exists.
     */
    where: AnonymousUserWhereUniqueInput
    /**
     * In case the AnonymousUser found by the `where` argument doesn't exist, create a new AnonymousUser with this data.
     */
    create: XOR<AnonymousUserCreateInput, AnonymousUserUncheckedCreateInput>
    /**
     * In case the AnonymousUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnonymousUserUpdateInput, AnonymousUserUncheckedUpdateInput>
  }

  /**
   * AnonymousUser delete
   */
  export type AnonymousUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    /**
     * Filter which AnonymousUser to delete.
     */
    where: AnonymousUserWhereUniqueInput
  }

  /**
   * AnonymousUser deleteMany
   */
  export type AnonymousUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnonymousUsers to delete
     */
    where?: AnonymousUserWhereInput
    /**
     * Limit how many AnonymousUsers to delete.
     */
    limit?: number
  }

  /**
   * AnonymousUser.carts
   */
  export type AnonymousUser$cartsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    where?: CartWhereInput
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    cursor?: CartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * AnonymousUser.chats
   */
  export type AnonymousUser$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * AnonymousUser.viewHistory
   */
  export type AnonymousUser$viewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    where?: ViewHistoryWhereInput
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    cursor?: ViewHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * AnonymousUser without action
   */
  export type AnonymousUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
  }


  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    deviceName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    endpoint: string | null
    p256dh: string | null
    auth: string | null
    userAgent: string | null
    deviceName: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastUsedAt: Date | null
  }

  export type PushSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    endpoint: number
    p256dh: number
    auth: number
    userAgent: number
    deviceName: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastUsedAt: number
    _all: number
  }


  export type PushSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
  }

  export type PushSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    endpoint?: true
    p256dh?: true
    auth?: true
    userAgent?: true
    deviceName?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastUsedAt?: true
    _all?: true
  }

  export type PushSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PushSubscriptions
    **/
    _count?: true | PushSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PushSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type GetPushSubscriptionAggregateType<T extends PushSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePushSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>
  }




  export type PushSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PushSubscriptionWhereInput
    orderBy?: PushSubscriptionOrderByWithAggregationInput | PushSubscriptionOrderByWithAggregationInput[]
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum
    having?: PushSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PushSubscriptionCountAggregateInputType | true
    _min?: PushSubscriptionMinAggregateInputType
    _max?: PushSubscriptionMaxAggregateInputType
  }

  export type PushSubscriptionGroupByOutputType = {
    id: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent: string | null
    deviceName: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastUsedAt: Date
    _count: PushSubscriptionCountAggregateOutputType | null
    _min: PushSubscriptionMinAggregateOutputType | null
    _max: PushSubscriptionMaxAggregateOutputType | null
  }

  type GetPushSubscriptionGroupByPayload<T extends PushSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PushSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type PushSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pushSubscription"]>

  export type PushSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    endpoint?: boolean
    p256dh?: boolean
    auth?: boolean
    userAgent?: boolean
    deviceName?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastUsedAt?: boolean
  }

  export type PushSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "endpoint" | "p256dh" | "auth" | "userAgent" | "deviceName" | "isActive" | "createdAt" | "updatedAt" | "lastUsedAt", ExtArgs["result"]["pushSubscription"]>
  export type PushSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PushSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PushSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      endpoint: string
      p256dh: string
      auth: string
      userAgent: string | null
      deviceName: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastUsedAt: Date
    }, ExtArgs["result"]["pushSubscription"]>
    composites: {}
  }

  type PushSubscriptionGetPayload<S extends boolean | null | undefined | PushSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>

  type PushSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PushSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PushSubscriptionCountAggregateInputType | true
    }

  export interface PushSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'], meta: { name: 'PushSubscription' } }
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     * 
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PushSubscriptionFindManyArgs>(args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     * 
     */
    create<T extends PushSubscriptionCreateArgs>(args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PushSubscriptions and returns the data saved in the database.
     * @param {PushSubscriptionCreateManyAndReturnArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PushSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PushSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     * 
     */
    delete<T extends PushSubscriptionDeleteArgs>(args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PushSubscriptionUpdateArgs>(args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PushSubscriptions and returns the data updated in the database.
     * @param {PushSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many PushSubscriptions.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PushSubscriptions and only return the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PushSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PushSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>): Prisma__PushSubscriptionClient<$Result.GetResult<Prisma.$PushSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PushSubscriptionAggregateArgs>(args: Subset<T, PushSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPushSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PushSubscription model
   */
  readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<"PushSubscription", 'String'>
    readonly userId: FieldRef<"PushSubscription", 'String'>
    readonly endpoint: FieldRef<"PushSubscription", 'String'>
    readonly p256dh: FieldRef<"PushSubscription", 'String'>
    readonly auth: FieldRef<"PushSubscription", 'String'>
    readonly userAgent: FieldRef<"PushSubscription", 'String'>
    readonly deviceName: FieldRef<"PushSubscription", 'String'>
    readonly isActive: FieldRef<"PushSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"PushSubscription", 'DateTime'>
    readonly lastUsedAt: FieldRef<"PushSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?: PushSubscriptionOrderByWithRelationInput | PushSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number
    distinct?: PushSubscriptionScalarFieldEnum | PushSubscriptionScalarFieldEnum[]
  }

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
  }

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PushSubscription createManyAndReturn
   */
  export type PushSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
  }

  /**
   * PushSubscription updateManyAndReturn
   */
  export type PushSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<PushSubscriptionCreateInput, PushSubscriptionUncheckedCreateInput>
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PushSubscriptionUpdateInput, PushSubscriptionUncheckedUpdateInput>
  }

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput
  }

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    newChat: boolean | null
    newMessage: boolean | null
    chatAssigned: boolean | null
    chatStatusChanged: boolean | null
    orderStatusChanged: boolean | null
    enableSchedule: boolean | null
    scheduleStart: string | null
    scheduleEnd: string | null
    scheduleTimezone: string | null
    soundEnabled: boolean | null
    vibrationEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    newChat: boolean | null
    newMessage: boolean | null
    chatAssigned: boolean | null
    chatStatusChanged: boolean | null
    orderStatusChanged: boolean | null
    enableSchedule: boolean | null
    scheduleStart: string | null
    scheduleEnd: string | null
    scheduleTimezone: string | null
    soundEnabled: boolean | null
    vibrationEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    newChat: number
    newMessage: number
    chatAssigned: number
    chatStatusChanged: number
    orderStatusChanged: number
    enableSchedule: number
    scheduleStart: number
    scheduleEnd: number
    scheduleTimezone: number
    scheduleDays: number
    soundEnabled: number
    vibrationEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    newChat?: true
    newMessage?: true
    chatAssigned?: true
    chatStatusChanged?: true
    orderStatusChanged?: true
    enableSchedule?: true
    scheduleStart?: true
    scheduleEnd?: true
    scheduleTimezone?: true
    soundEnabled?: true
    vibrationEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    newChat?: true
    newMessage?: true
    chatAssigned?: true
    chatStatusChanged?: true
    orderStatusChanged?: true
    enableSchedule?: true
    scheduleStart?: true
    scheduleEnd?: true
    scheduleTimezone?: true
    soundEnabled?: true
    vibrationEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    newChat?: true
    newMessage?: true
    chatAssigned?: true
    chatStatusChanged?: true
    orderStatusChanged?: true
    enableSchedule?: true
    scheduleStart?: true
    scheduleEnd?: true
    scheduleTimezone?: true
    scheduleDays?: true
    soundEnabled?: true
    vibrationEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    userId: string
    newChat: boolean
    newMessage: boolean
    chatAssigned: boolean
    chatStatusChanged: boolean
    orderStatusChanged: boolean
    enableSchedule: boolean
    scheduleStart: string | null
    scheduleEnd: string | null
    scheduleTimezone: string
    scheduleDays: JsonValue | null
    soundEnabled: boolean
    vibrationEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: boolean
    scheduleEnd?: boolean
    scheduleTimezone?: boolean
    scheduleDays?: boolean
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: boolean
    scheduleEnd?: boolean
    scheduleTimezone?: boolean
    scheduleDays?: boolean
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: boolean
    scheduleEnd?: boolean
    scheduleTimezone?: boolean
    scheduleDays?: boolean
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: boolean
    scheduleEnd?: boolean
    scheduleTimezone?: boolean
    scheduleDays?: boolean
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "newChat" | "newMessage" | "chatAssigned" | "chatStatusChanged" | "orderStatusChanged" | "enableSchedule" | "scheduleStart" | "scheduleEnd" | "scheduleTimezone" | "scheduleDays" | "soundEnabled" | "vibrationEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSettings"]>
  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      newChat: boolean
      newMessage: boolean
      chatAssigned: boolean
      chatStatusChanged: boolean
      orderStatusChanged: boolean
      enableSchedule: boolean
      scheduleStart: string | null
      scheduleEnd: string | null
      scheduleTimezone: string
      scheduleDays: Prisma.JsonValue | null
      soundEnabled: boolean
      vibrationEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
    readonly newChat: FieldRef<"NotificationSettings", 'Boolean'>
    readonly newMessage: FieldRef<"NotificationSettings", 'Boolean'>
    readonly chatAssigned: FieldRef<"NotificationSettings", 'Boolean'>
    readonly chatStatusChanged: FieldRef<"NotificationSettings", 'Boolean'>
    readonly orderStatusChanged: FieldRef<"NotificationSettings", 'Boolean'>
    readonly enableSchedule: FieldRef<"NotificationSettings", 'Boolean'>
    readonly scheduleStart: FieldRef<"NotificationSettings", 'String'>
    readonly scheduleEnd: FieldRef<"NotificationSettings", 'String'>
    readonly scheduleTimezone: FieldRef<"NotificationSettings", 'String'>
    readonly scheduleDays: FieldRef<"NotificationSettings", 'Json'>
    readonly soundEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly vibrationEnabled: FieldRef<"NotificationSettings", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings updateManyAndReturn
   */
  export type NotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    subscriptionId: string | null
    status: string | null
    errorMessage: string | null
    sentAt: Date | null
    clickedAt: Date | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    subscriptionId: string | null
    status: string | null
    errorMessage: string | null
    sentAt: Date | null
    clickedAt: Date | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    body: number
    data: number
    subscriptionId: number
    status: number
    errorMessage: number
    sentAt: number
    clickedAt: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    subscriptionId?: true
    status?: true
    errorMessage?: true
    sentAt?: true
    clickedAt?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    subscriptionId?: true
    status?: true
    errorMessage?: true
    sentAt?: true
    clickedAt?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    data?: true
    subscriptionId?: true
    status?: true
    errorMessage?: true
    sentAt?: true
    clickedAt?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    userId: string
    type: string
    title: string
    body: string
    data: JsonValue | null
    subscriptionId: string | null
    status: string
    errorMessage: string | null
    sentAt: Date
    clickedAt: Date | null
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    subscriptionId?: boolean
    status?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    clickedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    subscriptionId?: boolean
    status?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    clickedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    subscriptionId?: boolean
    status?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    clickedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>

  export type NotificationLogSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    subscriptionId?: boolean
    status?: boolean
    errorMessage?: boolean
    sentAt?: boolean
    clickedAt?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "body" | "data" | "subscriptionId" | "status" | "errorMessage" | "sentAt" | "clickedAt", ExtArgs["result"]["notificationLog"]>
  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      title: string
      body: string
      data: Prisma.JsonValue | null
      subscriptionId: string | null
      status: string
      errorMessage: string | null
      sentAt: Date
      clickedAt: Date | null
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationLogs and returns the data saved in the database.
     * @param {NotificationLogCreateManyAndReturnArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs and returns the data updated in the database.
     * @param {NotificationLogUpdateManyAndReturnArgs} args - Arguments to update many NotificationLogs.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationLogs and only return the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationLogUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly userId: FieldRef<"NotificationLog", 'String'>
    readonly type: FieldRef<"NotificationLog", 'String'>
    readonly title: FieldRef<"NotificationLog", 'String'>
    readonly body: FieldRef<"NotificationLog", 'String'>
    readonly data: FieldRef<"NotificationLog", 'Json'>
    readonly subscriptionId: FieldRef<"NotificationLog", 'String'>
    readonly status: FieldRef<"NotificationLog", 'String'>
    readonly errorMessage: FieldRef<"NotificationLog", 'String'>
    readonly sentAt: FieldRef<"NotificationLog", 'DateTime'>
    readonly clickedAt: FieldRef<"NotificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog createManyAndReturn
   */
  export type NotificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog updateManyAndReturn
   */
  export type NotificationLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    parentId: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    parentId: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    parentId?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    parentId: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    characteristics?: boolean | Category$characteristicsArgs<ExtArgs>
    viewHistory?: boolean | Category$viewHistoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    parentId?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "parentId" | "sortOrder" | "isActive" | "createdAt" | "updatedAt" | "deletedAt" | "metaTitle" | "metaDescription" | "metaKeywords", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    characteristics?: boolean | Category$characteristicsArgs<ExtArgs>
    viewHistory?: boolean | Category$viewHistoryArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductCategoryPayload<ExtArgs>[]
      characteristics: Prisma.$CharacteristicCategoryPayload<ExtArgs>[]
      viewHistory: Prisma.$ViewHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      parentId: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characteristics<T extends Category$characteristicsArgs<ExtArgs> = {}>(args?: Subset<T, Category$characteristicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewHistory<T extends Category$viewHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Category$viewHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly sortOrder: FieldRef<"Category", 'Int'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly deletedAt: FieldRef<"Category", 'DateTime'>
    readonly metaTitle: FieldRef<"Category", 'String'>
    readonly metaDescription: FieldRef<"Category", 'String'>
    readonly metaKeywords: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Category.characteristics
   */
  export type Category$characteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    where?: CharacteristicCategoryWhereInput
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    cursor?: CharacteristicCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacteristicCategoryScalarFieldEnum | CharacteristicCategoryScalarFieldEnum[]
  }

  /**
   * Category.viewHistory
   */
  export type Category$viewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    where?: ViewHistoryWhereInput
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    cursor?: ViewHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    comparePrice: Decimal | null
    stock: number | null
    deliveryDays: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    comparePrice: Decimal | null
    stock: number | null
    deliveryDays: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    sku: string | null
    price: Decimal | null
    comparePrice: Decimal | null
    stock: number | null
    deliveryDays: number | null
    brandId: string | null
    isOriginal: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    shortDescription: string | null
    sku: string | null
    price: Decimal | null
    comparePrice: Decimal | null
    stock: number | null
    deliveryDays: number | null
    brandId: string | null
    isOriginal: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    shortDescription: number
    sku: number
    price: number
    comparePrice: number
    stock: number
    deliveryDays: number
    brandId: number
    isOriginal: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    comparePrice?: true
    stock?: true
    deliveryDays?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    comparePrice?: true
    stock?: true
    deliveryDays?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    sku?: true
    price?: true
    comparePrice?: true
    stock?: true
    deliveryDays?: true
    brandId?: true
    isOriginal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    sku?: true
    price?: true
    comparePrice?: true
    stock?: true
    deliveryDays?: true
    brandId?: true
    isOriginal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    shortDescription?: true
    sku?: true
    price?: true
    comparePrice?: true
    stock?: true
    deliveryDays?: true
    brandId?: true
    isOriginal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    shortDescription: string | null
    sku: string
    price: Decimal
    comparePrice: Decimal | null
    stock: number
    deliveryDays: number | null
    brandId: string
    isOriginal: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    stock?: boolean
    deliveryDays?: boolean
    brandId?: boolean
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    characteristics?: boolean | Product$characteristicsArgs<ExtArgs>
    vehicleApplications?: boolean | Product$vehicleApplicationsArgs<ExtArgs>
    crossReferences?: boolean | Product$crossReferencesArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    favorites?: boolean | Product$favoritesArgs<ExtArgs>
    viewHistory?: boolean | Product$viewHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    stock?: boolean
    deliveryDays?: boolean
    brandId?: boolean
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    stock?: boolean
    deliveryDays?: boolean
    brandId?: boolean
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    shortDescription?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    stock?: boolean
    deliveryDays?: boolean
    brandId?: boolean
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "shortDescription" | "sku" | "price" | "comparePrice" | "stock" | "deliveryDays" | "brandId" | "isOriginal" | "isActive" | "createdAt" | "updatedAt" | "deletedAt" | "metaTitle" | "metaDescription" | "metaKeywords", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    characteristics?: boolean | Product$characteristicsArgs<ExtArgs>
    vehicleApplications?: boolean | Product$vehicleApplicationsArgs<ExtArgs>
    crossReferences?: boolean | Product$crossReferencesArgs<ExtArgs>
    cartItems?: boolean | Product$cartItemsArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    favorites?: boolean | Product$favoritesArgs<ExtArgs>
    viewHistory?: boolean | Product$viewHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      categories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      images: Prisma.$ProductImagePayload<ExtArgs>[]
      characteristics: Prisma.$ProductCharacteristicPayload<ExtArgs>[]
      vehicleApplications: Prisma.$VehicleApplicationPayload<ExtArgs>[]
      crossReferences: Prisma.$CrossReferencePayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      viewHistory: Prisma.$ViewHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      shortDescription: string | null
      sku: string
      price: Prisma.Decimal
      comparePrice: Prisma.Decimal | null
      stock: number
      deliveryDays: number | null
      brandId: string
      isOriginal: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Product$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characteristics<T extends Product$characteristicsArgs<ExtArgs> = {}>(args?: Subset<T, Product$characteristicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicleApplications<T extends Product$vehicleApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$vehicleApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crossReferences<T extends Product$crossReferencesArgs<ExtArgs> = {}>(args?: Subset<T, Product$crossReferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends Product$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Product$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Product$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewHistory<T extends Product$viewHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$viewHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly shortDescription: FieldRef<"Product", 'String'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly comparePrice: FieldRef<"Product", 'Decimal'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly deliveryDays: FieldRef<"Product", 'Int'>
    readonly brandId: FieldRef<"Product", 'String'>
    readonly isOriginal: FieldRef<"Product", 'Boolean'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly metaTitle: FieldRef<"Product", 'String'>
    readonly metaDescription: FieldRef<"Product", 'String'>
    readonly metaKeywords: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Product.images
   */
  export type Product$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product.characteristics
   */
  export type Product$characteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    cursor?: ProductCharacteristicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * Product.vehicleApplications
   */
  export type Product$vehicleApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    where?: VehicleApplicationWhereInput
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    cursor?: VehicleApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleApplicationScalarFieldEnum | VehicleApplicationScalarFieldEnum[]
  }

  /**
   * Product.crossReferences
   */
  export type Product$crossReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    where?: CrossReferenceWhereInput
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    cursor?: CrossReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrossReferenceScalarFieldEnum | CrossReferenceScalarFieldEnum[]
  }

  /**
   * Product.cartItems
   */
  export type Product$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.favorites
   */
  export type Product$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Product.viewHistory
   */
  export type Product$viewHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    where?: ViewHistoryWhereInput
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    cursor?: ViewHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    isPrimary: boolean | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    isPrimary: boolean | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    productId: number
    categoryId: number
    isPrimary: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    isPrimary?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    isPrimary?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    isPrimary?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    productId: string
    categoryId: string
    isPrimary: boolean
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    isPrimary?: boolean
  }

  export type ProductCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "categoryId" | "isPrimary", ExtArgs["result"]["productCategory"]>
  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      categoryId: string
      isPrimary: boolean
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories and returns the data updated in the database.
     * @param {ProductCategoryUpdateManyAndReturnArgs} args - Arguments to update many ProductCategories.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly productId: FieldRef<"ProductCategory", 'String'>
    readonly categoryId: FieldRef<"ProductCategory", 'String'>
    readonly isPrimary: FieldRef<"ProductCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
  }

  /**
   * ProductCategory updateManyAndReturn
   */
  export type ProductCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
    /**
     * Limit how many ProductCategories to delete.
     */
    limit?: number
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCategory
     */
    omit?: ProductCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    alt: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    alt: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    url: number
    alt: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ProductImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: string
    productId: string
    url: string
    alt: string | null
    sortOrder: number
    createdAt: Date
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    productId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "url" | "alt" | "sortOrder" | "createdAt", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      url: string
      alt: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'String'>
    readonly productId: FieldRef<"ProductImage", 'String'>
    readonly url: FieldRef<"ProductImage", 'String'>
    readonly alt: FieldRef<"ProductImage", 'String'>
    readonly sortOrder: FieldRef<"ProductImage", 'Int'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    description: string | null
    country: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    description: number
    country: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    country?: true
    isActive?: true
    createdAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    country?: true
    isActive?: true
    createdAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    description?: true
    country?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    description: string | null
    country: string | null
    isActive: boolean
    createdAt: Date
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
    products?: boolean | Brand$productsArgs<ExtArgs>
    crossReferences?: boolean | Brand$crossReferencesArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    description?: boolean
    country?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "description" | "country" | "isActive" | "createdAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Brand$productsArgs<ExtArgs>
    crossReferences?: boolean | Brand$crossReferencesArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      crossReferences: Prisma.$CrossReferencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      description: string | null
      country: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Brand$productsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    crossReferences<T extends Brand$crossReferencesArgs<ExtArgs> = {}>(args?: Subset<T, Brand$crossReferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly slug: FieldRef<"Brand", 'String'>
    readonly logo: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
    readonly country: FieldRef<"Brand", 'String'>
    readonly isActive: FieldRef<"Brand", 'Boolean'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.products
   */
  export type Brand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand.crossReferences
   */
  export type Brand$crossReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    where?: CrossReferenceWhereInput
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    cursor?: CrossReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrossReferenceScalarFieldEnum | CrossReferenceScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Characteristic
   */

  export type AggregateCharacteristic = {
    _count: CharacteristicCountAggregateOutputType | null
    _avg: CharacteristicAvgAggregateOutputType | null
    _sum: CharacteristicSumAggregateOutputType | null
    _min: CharacteristicMinAggregateOutputType | null
    _max: CharacteristicMaxAggregateOutputType | null
  }

  export type CharacteristicAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CharacteristicSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CharacteristicMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    type: string | null
    unit: string | null
    isRequired: boolean | null
    isFilterable: boolean | null
    filterType: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CharacteristicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    type: string | null
    unit: string | null
    isRequired: boolean | null
    isFilterable: boolean | null
    filterType: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type CharacteristicCountAggregateOutputType = {
    id: number
    name: number
    code: number
    type: number
    unit: number
    isRequired: number
    isFilterable: number
    filterType: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type CharacteristicAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CharacteristicSumAggregateInputType = {
    sortOrder?: true
  }

  export type CharacteristicMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    unit?: true
    isRequired?: true
    isFilterable?: true
    filterType?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CharacteristicMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    unit?: true
    isRequired?: true
    isFilterable?: true
    filterType?: true
    sortOrder?: true
    createdAt?: true
  }

  export type CharacteristicCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    type?: true
    unit?: true
    isRequired?: true
    isFilterable?: true
    filterType?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type CharacteristicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristic to aggregate.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characteristics
    **/
    _count?: true | CharacteristicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacteristicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacteristicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicMaxAggregateInputType
  }

  export type GetCharacteristicAggregateType<T extends CharacteristicAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristic[P]>
      : GetScalarType<T[P], AggregateCharacteristic[P]>
  }




  export type CharacteristicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicWhereInput
    orderBy?: CharacteristicOrderByWithAggregationInput | CharacteristicOrderByWithAggregationInput[]
    by: CharacteristicScalarFieldEnum[] | CharacteristicScalarFieldEnum
    having?: CharacteristicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicCountAggregateInputType | true
    _avg?: CharacteristicAvgAggregateInputType
    _sum?: CharacteristicSumAggregateInputType
    _min?: CharacteristicMinAggregateInputType
    _max?: CharacteristicMaxAggregateInputType
  }

  export type CharacteristicGroupByOutputType = {
    id: string
    name: string
    code: string
    type: string
    unit: string | null
    isRequired: boolean
    isFilterable: boolean
    filterType: string | null
    sortOrder: number
    createdAt: Date
    _count: CharacteristicCountAggregateOutputType | null
    _avg: CharacteristicAvgAggregateOutputType | null
    _sum: CharacteristicSumAggregateOutputType | null
    _min: CharacteristicMinAggregateOutputType | null
    _max: CharacteristicMaxAggregateOutputType | null
  }

  type GetCharacteristicGroupByPayload<T extends CharacteristicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    unit?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    values?: boolean | Characteristic$valuesArgs<ExtArgs>
    productValues?: boolean | Characteristic$productValuesArgs<ExtArgs>
    categories?: boolean | Characteristic$categoriesArgs<ExtArgs>
    _count?: boolean | CharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristic"]>

  export type CharacteristicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    unit?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["characteristic"]>

  export type CharacteristicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    unit?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["characteristic"]>

  export type CharacteristicSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    unit?: boolean
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type CharacteristicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "type" | "unit" | "isRequired" | "isFilterable" | "filterType" | "sortOrder" | "createdAt", ExtArgs["result"]["characteristic"]>
  export type CharacteristicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | Characteristic$valuesArgs<ExtArgs>
    productValues?: boolean | Characteristic$productValuesArgs<ExtArgs>
    categories?: boolean | Characteristic$categoriesArgs<ExtArgs>
    _count?: boolean | CharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacteristicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CharacteristicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CharacteristicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Characteristic"
    objects: {
      values: Prisma.$CharacteristicValuePayload<ExtArgs>[]
      productValues: Prisma.$ProductCharacteristicPayload<ExtArgs>[]
      categories: Prisma.$CharacteristicCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      type: string
      unit: string | null
      isRequired: boolean
      isFilterable: boolean
      filterType: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["characteristic"]>
    composites: {}
  }

  type CharacteristicGetPayload<S extends boolean | null | undefined | CharacteristicDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicPayload, S>

  type CharacteristicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacteristicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacteristicCountAggregateInputType | true
    }

  export interface CharacteristicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Characteristic'], meta: { name: 'Characteristic' } }
    /**
     * Find zero or one Characteristic that matches the filter.
     * @param {CharacteristicFindUniqueArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicFindUniqueArgs>(args: SelectSubset<T, CharacteristicFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Characteristic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacteristicFindUniqueOrThrowArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characteristic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindFirstArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicFindFirstArgs>(args?: SelectSubset<T, CharacteristicFindFirstArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characteristic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindFirstOrThrowArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characteristics
     * const characteristics = await prisma.characteristic.findMany()
     * 
     * // Get first 10 Characteristics
     * const characteristics = await prisma.characteristic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicWithIdOnly = await prisma.characteristic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicFindManyArgs>(args?: SelectSubset<T, CharacteristicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Characteristic.
     * @param {CharacteristicCreateArgs} args - Arguments to create a Characteristic.
     * @example
     * // Create one Characteristic
     * const Characteristic = await prisma.characteristic.create({
     *   data: {
     *     // ... data to create a Characteristic
     *   }
     * })
     * 
     */
    create<T extends CharacteristicCreateArgs>(args: SelectSubset<T, CharacteristicCreateArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characteristics.
     * @param {CharacteristicCreateManyArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristic = await prisma.characteristic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicCreateManyArgs>(args?: SelectSubset<T, CharacteristicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characteristics and returns the data saved in the database.
     * @param {CharacteristicCreateManyAndReturnArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristic = await prisma.characteristic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characteristics and only return the `id`
     * const characteristicWithIdOnly = await prisma.characteristic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Characteristic.
     * @param {CharacteristicDeleteArgs} args - Arguments to delete one Characteristic.
     * @example
     * // Delete one Characteristic
     * const Characteristic = await prisma.characteristic.delete({
     *   where: {
     *     // ... filter to delete one Characteristic
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicDeleteArgs>(args: SelectSubset<T, CharacteristicDeleteArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Characteristic.
     * @param {CharacteristicUpdateArgs} args - Arguments to update one Characteristic.
     * @example
     * // Update one Characteristic
     * const characteristic = await prisma.characteristic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicUpdateArgs>(args: SelectSubset<T, CharacteristicUpdateArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characteristics.
     * @param {CharacteristicDeleteManyArgs} args - Arguments to filter Characteristics to delete.
     * @example
     * // Delete a few Characteristics
     * const { count } = await prisma.characteristic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicDeleteManyArgs>(args?: SelectSubset<T, CharacteristicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characteristics
     * const characteristic = await prisma.characteristic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicUpdateManyArgs>(args: SelectSubset<T, CharacteristicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characteristics and returns the data updated in the database.
     * @param {CharacteristicUpdateManyAndReturnArgs} args - Arguments to update many Characteristics.
     * @example
     * // Update many Characteristics
     * const characteristic = await prisma.characteristic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characteristics and only return the `id`
     * const characteristicWithIdOnly = await prisma.characteristic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacteristicUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacteristicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Characteristic.
     * @param {CharacteristicUpsertArgs} args - Arguments to update or create a Characteristic.
     * @example
     * // Update or create a Characteristic
     * const characteristic = await prisma.characteristic.upsert({
     *   create: {
     *     // ... data to create a Characteristic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characteristic we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicUpsertArgs>(args: SelectSubset<T, CharacteristicUpsertArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCountArgs} args - Arguments to filter Characteristics to count.
     * @example
     * // Count the number of Characteristics
     * const count = await prisma.characteristic.count({
     *   where: {
     *     // ... the filter for the Characteristics we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicCountArgs>(
      args?: Subset<T, CharacteristicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicAggregateArgs>(args: Subset<T, CharacteristicAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicAggregateType<T>>

    /**
     * Group by Characteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Characteristic model
   */
  readonly fields: CharacteristicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Characteristic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends Characteristic$valuesArgs<ExtArgs> = {}>(args?: Subset<T, Characteristic$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productValues<T extends Characteristic$productValuesArgs<ExtArgs> = {}>(args?: Subset<T, Characteristic$productValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Characteristic$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Characteristic$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Characteristic model
   */
  interface CharacteristicFieldRefs {
    readonly id: FieldRef<"Characteristic", 'String'>
    readonly name: FieldRef<"Characteristic", 'String'>
    readonly code: FieldRef<"Characteristic", 'String'>
    readonly type: FieldRef<"Characteristic", 'String'>
    readonly unit: FieldRef<"Characteristic", 'String'>
    readonly isRequired: FieldRef<"Characteristic", 'Boolean'>
    readonly isFilterable: FieldRef<"Characteristic", 'Boolean'>
    readonly filterType: FieldRef<"Characteristic", 'String'>
    readonly sortOrder: FieldRef<"Characteristic", 'Int'>
    readonly createdAt: FieldRef<"Characteristic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Characteristic findUnique
   */
  export type CharacteristicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic findUniqueOrThrow
   */
  export type CharacteristicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic findFirst
   */
  export type CharacteristicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic findFirstOrThrow
   */
  export type CharacteristicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic findMany
   */
  export type CharacteristicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic create
   */
  export type CharacteristicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to create a Characteristic.
     */
    data: XOR<CharacteristicCreateInput, CharacteristicUncheckedCreateInput>
  }

  /**
   * Characteristic createMany
   */
  export type CharacteristicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicCreateManyInput | CharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characteristic createManyAndReturn
   */
  export type CharacteristicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicCreateManyInput | CharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characteristic update
   */
  export type CharacteristicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to update a Characteristic.
     */
    data: XOR<CharacteristicUpdateInput, CharacteristicUncheckedUpdateInput>
    /**
     * Choose, which Characteristic to update.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic updateMany
   */
  export type CharacteristicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characteristics.
     */
    data: XOR<CharacteristicUpdateManyMutationInput, CharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which Characteristics to update
     */
    where?: CharacteristicWhereInput
    /**
     * Limit how many Characteristics to update.
     */
    limit?: number
  }

  /**
   * Characteristic updateManyAndReturn
   */
  export type CharacteristicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * The data used to update Characteristics.
     */
    data: XOR<CharacteristicUpdateManyMutationInput, CharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which Characteristics to update
     */
    where?: CharacteristicWhereInput
    /**
     * Limit how many Characteristics to update.
     */
    limit?: number
  }

  /**
   * Characteristic upsert
   */
  export type CharacteristicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The filter to search for the Characteristic to update in case it exists.
     */
    where: CharacteristicWhereUniqueInput
    /**
     * In case the Characteristic found by the `where` argument doesn't exist, create a new Characteristic with this data.
     */
    create: XOR<CharacteristicCreateInput, CharacteristicUncheckedCreateInput>
    /**
     * In case the Characteristic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicUpdateInput, CharacteristicUncheckedUpdateInput>
  }

  /**
   * Characteristic delete
   */
  export type CharacteristicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter which Characteristic to delete.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic deleteMany
   */
  export type CharacteristicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristics to delete
     */
    where?: CharacteristicWhereInput
    /**
     * Limit how many Characteristics to delete.
     */
    limit?: number
  }

  /**
   * Characteristic.values
   */
  export type Characteristic$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    where?: CharacteristicValueWhereInput
    orderBy?: CharacteristicValueOrderByWithRelationInput | CharacteristicValueOrderByWithRelationInput[]
    cursor?: CharacteristicValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacteristicValueScalarFieldEnum | CharacteristicValueScalarFieldEnum[]
  }

  /**
   * Characteristic.productValues
   */
  export type Characteristic$productValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    cursor?: ProductCharacteristicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic.categories
   */
  export type Characteristic$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    where?: CharacteristicCategoryWhereInput
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    cursor?: CharacteristicCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacteristicCategoryScalarFieldEnum | CharacteristicCategoryScalarFieldEnum[]
  }

  /**
   * Characteristic without action
   */
  export type CharacteristicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Characteristic
     */
    omit?: CharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
  }


  /**
   * Model CharacteristicCategory
   */

  export type AggregateCharacteristicCategory = {
    _count: CharacteristicCategoryCountAggregateOutputType | null
    _min: CharacteristicCategoryMinAggregateOutputType | null
    _max: CharacteristicCategoryMaxAggregateOutputType | null
  }

  export type CharacteristicCategoryMinAggregateOutputType = {
    id: string | null
    characteristicId: string | null
    categoryId: string | null
  }

  export type CharacteristicCategoryMaxAggregateOutputType = {
    id: string | null
    characteristicId: string | null
    categoryId: string | null
  }

  export type CharacteristicCategoryCountAggregateOutputType = {
    id: number
    characteristicId: number
    categoryId: number
    _all: number
  }


  export type CharacteristicCategoryMinAggregateInputType = {
    id?: true
    characteristicId?: true
    categoryId?: true
  }

  export type CharacteristicCategoryMaxAggregateInputType = {
    id?: true
    characteristicId?: true
    categoryId?: true
  }

  export type CharacteristicCategoryCountAggregateInputType = {
    id?: true
    characteristicId?: true
    categoryId?: true
    _all?: true
  }

  export type CharacteristicCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicCategory to aggregate.
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicCategories to fetch.
     */
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacteristicCategories
    **/
    _count?: true | CharacteristicCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicCategoryMaxAggregateInputType
  }

  export type GetCharacteristicCategoryAggregateType<T extends CharacteristicCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristicCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristicCategory[P]>
      : GetScalarType<T[P], AggregateCharacteristicCategory[P]>
  }




  export type CharacteristicCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicCategoryWhereInput
    orderBy?: CharacteristicCategoryOrderByWithAggregationInput | CharacteristicCategoryOrderByWithAggregationInput[]
    by: CharacteristicCategoryScalarFieldEnum[] | CharacteristicCategoryScalarFieldEnum
    having?: CharacteristicCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicCategoryCountAggregateInputType | true
    _min?: CharacteristicCategoryMinAggregateInputType
    _max?: CharacteristicCategoryMaxAggregateInputType
  }

  export type CharacteristicCategoryGroupByOutputType = {
    id: string
    characteristicId: string
    categoryId: string
    _count: CharacteristicCategoryCountAggregateOutputType | null
    _min: CharacteristicCategoryMinAggregateOutputType | null
    _max: CharacteristicCategoryMaxAggregateOutputType | null
  }

  type GetCharacteristicCategoryGroupByPayload<T extends CharacteristicCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    categoryId?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicCategory"]>

  export type CharacteristicCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    categoryId?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicCategory"]>

  export type CharacteristicCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    categoryId?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicCategory"]>

  export type CharacteristicCategorySelectScalar = {
    id?: boolean
    characteristicId?: boolean
    categoryId?: boolean
  }

  export type CharacteristicCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characteristicId" | "categoryId", ExtArgs["result"]["characteristicCategory"]>
  export type CharacteristicCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CharacteristicCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type CharacteristicCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $CharacteristicCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacteristicCategory"
    objects: {
      characteristic: Prisma.$CharacteristicPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characteristicId: string
      categoryId: string
    }, ExtArgs["result"]["characteristicCategory"]>
    composites: {}
  }

  type CharacteristicCategoryGetPayload<S extends boolean | null | undefined | CharacteristicCategoryDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicCategoryPayload, S>

  type CharacteristicCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacteristicCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacteristicCategoryCountAggregateInputType | true
    }

  export interface CharacteristicCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacteristicCategory'], meta: { name: 'CharacteristicCategory' } }
    /**
     * Find zero or one CharacteristicCategory that matches the filter.
     * @param {CharacteristicCategoryFindUniqueArgs} args - Arguments to find a CharacteristicCategory
     * @example
     * // Get one CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicCategoryFindUniqueArgs>(args: SelectSubset<T, CharacteristicCategoryFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacteristicCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacteristicCategoryFindUniqueOrThrowArgs} args - Arguments to find a CharacteristicCategory
     * @example
     * // Get one CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacteristicCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryFindFirstArgs} args - Arguments to find a CharacteristicCategory
     * @example
     * // Get one CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicCategoryFindFirstArgs>(args?: SelectSubset<T, CharacteristicCategoryFindFirstArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacteristicCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryFindFirstOrThrowArgs} args - Arguments to find a CharacteristicCategory
     * @example
     * // Get one CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacteristicCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacteristicCategories
     * const characteristicCategories = await prisma.characteristicCategory.findMany()
     * 
     * // Get first 10 CharacteristicCategories
     * const characteristicCategories = await prisma.characteristicCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicCategoryWithIdOnly = await prisma.characteristicCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicCategoryFindManyArgs>(args?: SelectSubset<T, CharacteristicCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacteristicCategory.
     * @param {CharacteristicCategoryCreateArgs} args - Arguments to create a CharacteristicCategory.
     * @example
     * // Create one CharacteristicCategory
     * const CharacteristicCategory = await prisma.characteristicCategory.create({
     *   data: {
     *     // ... data to create a CharacteristicCategory
     *   }
     * })
     * 
     */
    create<T extends CharacteristicCategoryCreateArgs>(args: SelectSubset<T, CharacteristicCategoryCreateArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacteristicCategories.
     * @param {CharacteristicCategoryCreateManyArgs} args - Arguments to create many CharacteristicCategories.
     * @example
     * // Create many CharacteristicCategories
     * const characteristicCategory = await prisma.characteristicCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicCategoryCreateManyArgs>(args?: SelectSubset<T, CharacteristicCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacteristicCategories and returns the data saved in the database.
     * @param {CharacteristicCategoryCreateManyAndReturnArgs} args - Arguments to create many CharacteristicCategories.
     * @example
     * // Create many CharacteristicCategories
     * const characteristicCategory = await prisma.characteristicCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacteristicCategories and only return the `id`
     * const characteristicCategoryWithIdOnly = await prisma.characteristicCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacteristicCategory.
     * @param {CharacteristicCategoryDeleteArgs} args - Arguments to delete one CharacteristicCategory.
     * @example
     * // Delete one CharacteristicCategory
     * const CharacteristicCategory = await prisma.characteristicCategory.delete({
     *   where: {
     *     // ... filter to delete one CharacteristicCategory
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicCategoryDeleteArgs>(args: SelectSubset<T, CharacteristicCategoryDeleteArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacteristicCategory.
     * @param {CharacteristicCategoryUpdateArgs} args - Arguments to update one CharacteristicCategory.
     * @example
     * // Update one CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicCategoryUpdateArgs>(args: SelectSubset<T, CharacteristicCategoryUpdateArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacteristicCategories.
     * @param {CharacteristicCategoryDeleteManyArgs} args - Arguments to filter CharacteristicCategories to delete.
     * @example
     * // Delete a few CharacteristicCategories
     * const { count } = await prisma.characteristicCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicCategoryDeleteManyArgs>(args?: SelectSubset<T, CharacteristicCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacteristicCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacteristicCategories
     * const characteristicCategory = await prisma.characteristicCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicCategoryUpdateManyArgs>(args: SelectSubset<T, CharacteristicCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacteristicCategories and returns the data updated in the database.
     * @param {CharacteristicCategoryUpdateManyAndReturnArgs} args - Arguments to update many CharacteristicCategories.
     * @example
     * // Update many CharacteristicCategories
     * const characteristicCategory = await prisma.characteristicCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacteristicCategories and only return the `id`
     * const characteristicCategoryWithIdOnly = await prisma.characteristicCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacteristicCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacteristicCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacteristicCategory.
     * @param {CharacteristicCategoryUpsertArgs} args - Arguments to update or create a CharacteristicCategory.
     * @example
     * // Update or create a CharacteristicCategory
     * const characteristicCategory = await prisma.characteristicCategory.upsert({
     *   create: {
     *     // ... data to create a CharacteristicCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacteristicCategory we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicCategoryUpsertArgs>(args: SelectSubset<T, CharacteristicCategoryUpsertArgs<ExtArgs>>): Prisma__CharacteristicCategoryClient<$Result.GetResult<Prisma.$CharacteristicCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacteristicCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryCountArgs} args - Arguments to filter CharacteristicCategories to count.
     * @example
     * // Count the number of CharacteristicCategories
     * const count = await prisma.characteristicCategory.count({
     *   where: {
     *     // ... the filter for the CharacteristicCategories we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicCategoryCountArgs>(
      args?: Subset<T, CharacteristicCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacteristicCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicCategoryAggregateArgs>(args: Subset<T, CharacteristicCategoryAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicCategoryAggregateType<T>>

    /**
     * Group by CharacteristicCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacteristicCategory model
   */
  readonly fields: CharacteristicCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacteristicCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characteristic<T extends CharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicDefaultArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacteristicCategory model
   */
  interface CharacteristicCategoryFieldRefs {
    readonly id: FieldRef<"CharacteristicCategory", 'String'>
    readonly characteristicId: FieldRef<"CharacteristicCategory", 'String'>
    readonly categoryId: FieldRef<"CharacteristicCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacteristicCategory findUnique
   */
  export type CharacteristicCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicCategory to fetch.
     */
    where: CharacteristicCategoryWhereUniqueInput
  }

  /**
   * CharacteristicCategory findUniqueOrThrow
   */
  export type CharacteristicCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicCategory to fetch.
     */
    where: CharacteristicCategoryWhereUniqueInput
  }

  /**
   * CharacteristicCategory findFirst
   */
  export type CharacteristicCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicCategory to fetch.
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicCategories to fetch.
     */
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicCategories.
     */
    cursor?: CharacteristicCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicCategories.
     */
    distinct?: CharacteristicCategoryScalarFieldEnum | CharacteristicCategoryScalarFieldEnum[]
  }

  /**
   * CharacteristicCategory findFirstOrThrow
   */
  export type CharacteristicCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicCategory to fetch.
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicCategories to fetch.
     */
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicCategories.
     */
    cursor?: CharacteristicCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicCategories.
     */
    distinct?: CharacteristicCategoryScalarFieldEnum | CharacteristicCategoryScalarFieldEnum[]
  }

  /**
   * CharacteristicCategory findMany
   */
  export type CharacteristicCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicCategories to fetch.
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicCategories to fetch.
     */
    orderBy?: CharacteristicCategoryOrderByWithRelationInput | CharacteristicCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacteristicCategories.
     */
    cursor?: CharacteristicCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicCategories.
     */
    skip?: number
    distinct?: CharacteristicCategoryScalarFieldEnum | CharacteristicCategoryScalarFieldEnum[]
  }

  /**
   * CharacteristicCategory create
   */
  export type CharacteristicCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacteristicCategory.
     */
    data: XOR<CharacteristicCategoryCreateInput, CharacteristicCategoryUncheckedCreateInput>
  }

  /**
   * CharacteristicCategory createMany
   */
  export type CharacteristicCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacteristicCategories.
     */
    data: CharacteristicCategoryCreateManyInput | CharacteristicCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacteristicCategory createManyAndReturn
   */
  export type CharacteristicCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many CharacteristicCategories.
     */
    data: CharacteristicCategoryCreateManyInput | CharacteristicCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacteristicCategory update
   */
  export type CharacteristicCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacteristicCategory.
     */
    data: XOR<CharacteristicCategoryUpdateInput, CharacteristicCategoryUncheckedUpdateInput>
    /**
     * Choose, which CharacteristicCategory to update.
     */
    where: CharacteristicCategoryWhereUniqueInput
  }

  /**
   * CharacteristicCategory updateMany
   */
  export type CharacteristicCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacteristicCategories.
     */
    data: XOR<CharacteristicCategoryUpdateManyMutationInput, CharacteristicCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CharacteristicCategories to update
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * Limit how many CharacteristicCategories to update.
     */
    limit?: number
  }

  /**
   * CharacteristicCategory updateManyAndReturn
   */
  export type CharacteristicCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * The data used to update CharacteristicCategories.
     */
    data: XOR<CharacteristicCategoryUpdateManyMutationInput, CharacteristicCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CharacteristicCategories to update
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * Limit how many CharacteristicCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacteristicCategory upsert
   */
  export type CharacteristicCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacteristicCategory to update in case it exists.
     */
    where: CharacteristicCategoryWhereUniqueInput
    /**
     * In case the CharacteristicCategory found by the `where` argument doesn't exist, create a new CharacteristicCategory with this data.
     */
    create: XOR<CharacteristicCategoryCreateInput, CharacteristicCategoryUncheckedCreateInput>
    /**
     * In case the CharacteristicCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicCategoryUpdateInput, CharacteristicCategoryUncheckedUpdateInput>
  }

  /**
   * CharacteristicCategory delete
   */
  export type CharacteristicCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
    /**
     * Filter which CharacteristicCategory to delete.
     */
    where: CharacteristicCategoryWhereUniqueInput
  }

  /**
   * CharacteristicCategory deleteMany
   */
  export type CharacteristicCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicCategories to delete
     */
    where?: CharacteristicCategoryWhereInput
    /**
     * Limit how many CharacteristicCategories to delete.
     */
    limit?: number
  }

  /**
   * CharacteristicCategory without action
   */
  export type CharacteristicCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCategory
     */
    select?: CharacteristicCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicCategory
     */
    omit?: CharacteristicCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CharacteristicValue
   */

  export type AggregateCharacteristicValue = {
    _count: CharacteristicValueCountAggregateOutputType | null
    _avg: CharacteristicValueAvgAggregateOutputType | null
    _sum: CharacteristicValueSumAggregateOutputType | null
    _min: CharacteristicValueMinAggregateOutputType | null
    _max: CharacteristicValueMaxAggregateOutputType | null
  }

  export type CharacteristicValueAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type CharacteristicValueSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type CharacteristicValueMinAggregateOutputType = {
    id: string | null
    characteristicId: string | null
    value: string | null
    sortOrder: number | null
  }

  export type CharacteristicValueMaxAggregateOutputType = {
    id: string | null
    characteristicId: string | null
    value: string | null
    sortOrder: number | null
  }

  export type CharacteristicValueCountAggregateOutputType = {
    id: number
    characteristicId: number
    value: number
    sortOrder: number
    _all: number
  }


  export type CharacteristicValueAvgAggregateInputType = {
    sortOrder?: true
  }

  export type CharacteristicValueSumAggregateInputType = {
    sortOrder?: true
  }

  export type CharacteristicValueMinAggregateInputType = {
    id?: true
    characteristicId?: true
    value?: true
    sortOrder?: true
  }

  export type CharacteristicValueMaxAggregateInputType = {
    id?: true
    characteristicId?: true
    value?: true
    sortOrder?: true
  }

  export type CharacteristicValueCountAggregateInputType = {
    id?: true
    characteristicId?: true
    value?: true
    sortOrder?: true
    _all?: true
  }

  export type CharacteristicValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicValue to aggregate.
     */
    where?: CharacteristicValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicValues to fetch.
     */
    orderBy?: CharacteristicValueOrderByWithRelationInput | CharacteristicValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacteristicValues
    **/
    _count?: true | CharacteristicValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacteristicValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacteristicValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicValueMaxAggregateInputType
  }

  export type GetCharacteristicValueAggregateType<T extends CharacteristicValueAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristicValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristicValue[P]>
      : GetScalarType<T[P], AggregateCharacteristicValue[P]>
  }




  export type CharacteristicValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicValueWhereInput
    orderBy?: CharacteristicValueOrderByWithAggregationInput | CharacteristicValueOrderByWithAggregationInput[]
    by: CharacteristicValueScalarFieldEnum[] | CharacteristicValueScalarFieldEnum
    having?: CharacteristicValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicValueCountAggregateInputType | true
    _avg?: CharacteristicValueAvgAggregateInputType
    _sum?: CharacteristicValueSumAggregateInputType
    _min?: CharacteristicValueMinAggregateInputType
    _max?: CharacteristicValueMaxAggregateInputType
  }

  export type CharacteristicValueGroupByOutputType = {
    id: string
    characteristicId: string
    value: string
    sortOrder: number
    _count: CharacteristicValueCountAggregateOutputType | null
    _avg: CharacteristicValueAvgAggregateOutputType | null
    _sum: CharacteristicValueSumAggregateOutputType | null
    _min: CharacteristicValueMinAggregateOutputType | null
    _max: CharacteristicValueMaxAggregateOutputType | null
  }

  type GetCharacteristicValueGroupByPayload<T extends CharacteristicValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicValueGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicValueGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    value?: boolean
    sortOrder?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    productValues?: boolean | CharacteristicValue$productValuesArgs<ExtArgs>
    _count?: boolean | CharacteristicValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicValue"]>

  export type CharacteristicValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    value?: boolean
    sortOrder?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicValue"]>

  export type CharacteristicValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characteristicId?: boolean
    value?: boolean
    sortOrder?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicValue"]>

  export type CharacteristicValueSelectScalar = {
    id?: boolean
    characteristicId?: boolean
    value?: boolean
    sortOrder?: boolean
  }

  export type CharacteristicValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characteristicId" | "value" | "sortOrder", ExtArgs["result"]["characteristicValue"]>
  export type CharacteristicValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    productValues?: boolean | CharacteristicValue$productValuesArgs<ExtArgs>
    _count?: boolean | CharacteristicValueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacteristicValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }
  export type CharacteristicValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }

  export type $CharacteristicValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacteristicValue"
    objects: {
      characteristic: Prisma.$CharacteristicPayload<ExtArgs>
      productValues: Prisma.$ProductCharacteristicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characteristicId: string
      value: string
      sortOrder: number
    }, ExtArgs["result"]["characteristicValue"]>
    composites: {}
  }

  type CharacteristicValueGetPayload<S extends boolean | null | undefined | CharacteristicValueDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicValuePayload, S>

  type CharacteristicValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacteristicValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacteristicValueCountAggregateInputType | true
    }

  export interface CharacteristicValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacteristicValue'], meta: { name: 'CharacteristicValue' } }
    /**
     * Find zero or one CharacteristicValue that matches the filter.
     * @param {CharacteristicValueFindUniqueArgs} args - Arguments to find a CharacteristicValue
     * @example
     * // Get one CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicValueFindUniqueArgs>(args: SelectSubset<T, CharacteristicValueFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacteristicValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacteristicValueFindUniqueOrThrowArgs} args - Arguments to find a CharacteristicValue
     * @example
     * // Get one CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicValueFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacteristicValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueFindFirstArgs} args - Arguments to find a CharacteristicValue
     * @example
     * // Get one CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicValueFindFirstArgs>(args?: SelectSubset<T, CharacteristicValueFindFirstArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacteristicValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueFindFirstOrThrowArgs} args - Arguments to find a CharacteristicValue
     * @example
     * // Get one CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicValueFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacteristicValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacteristicValues
     * const characteristicValues = await prisma.characteristicValue.findMany()
     * 
     * // Get first 10 CharacteristicValues
     * const characteristicValues = await prisma.characteristicValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicValueWithIdOnly = await prisma.characteristicValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicValueFindManyArgs>(args?: SelectSubset<T, CharacteristicValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacteristicValue.
     * @param {CharacteristicValueCreateArgs} args - Arguments to create a CharacteristicValue.
     * @example
     * // Create one CharacteristicValue
     * const CharacteristicValue = await prisma.characteristicValue.create({
     *   data: {
     *     // ... data to create a CharacteristicValue
     *   }
     * })
     * 
     */
    create<T extends CharacteristicValueCreateArgs>(args: SelectSubset<T, CharacteristicValueCreateArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacteristicValues.
     * @param {CharacteristicValueCreateManyArgs} args - Arguments to create many CharacteristicValues.
     * @example
     * // Create many CharacteristicValues
     * const characteristicValue = await prisma.characteristicValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicValueCreateManyArgs>(args?: SelectSubset<T, CharacteristicValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacteristicValues and returns the data saved in the database.
     * @param {CharacteristicValueCreateManyAndReturnArgs} args - Arguments to create many CharacteristicValues.
     * @example
     * // Create many CharacteristicValues
     * const characteristicValue = await prisma.characteristicValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacteristicValues and only return the `id`
     * const characteristicValueWithIdOnly = await prisma.characteristicValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicValueCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacteristicValue.
     * @param {CharacteristicValueDeleteArgs} args - Arguments to delete one CharacteristicValue.
     * @example
     * // Delete one CharacteristicValue
     * const CharacteristicValue = await prisma.characteristicValue.delete({
     *   where: {
     *     // ... filter to delete one CharacteristicValue
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicValueDeleteArgs>(args: SelectSubset<T, CharacteristicValueDeleteArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacteristicValue.
     * @param {CharacteristicValueUpdateArgs} args - Arguments to update one CharacteristicValue.
     * @example
     * // Update one CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicValueUpdateArgs>(args: SelectSubset<T, CharacteristicValueUpdateArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacteristicValues.
     * @param {CharacteristicValueDeleteManyArgs} args - Arguments to filter CharacteristicValues to delete.
     * @example
     * // Delete a few CharacteristicValues
     * const { count } = await prisma.characteristicValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicValueDeleteManyArgs>(args?: SelectSubset<T, CharacteristicValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacteristicValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacteristicValues
     * const characteristicValue = await prisma.characteristicValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicValueUpdateManyArgs>(args: SelectSubset<T, CharacteristicValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacteristicValues and returns the data updated in the database.
     * @param {CharacteristicValueUpdateManyAndReturnArgs} args - Arguments to update many CharacteristicValues.
     * @example
     * // Update many CharacteristicValues
     * const characteristicValue = await prisma.characteristicValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacteristicValues and only return the `id`
     * const characteristicValueWithIdOnly = await prisma.characteristicValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacteristicValueUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacteristicValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacteristicValue.
     * @param {CharacteristicValueUpsertArgs} args - Arguments to update or create a CharacteristicValue.
     * @example
     * // Update or create a CharacteristicValue
     * const characteristicValue = await prisma.characteristicValue.upsert({
     *   create: {
     *     // ... data to create a CharacteristicValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacteristicValue we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicValueUpsertArgs>(args: SelectSubset<T, CharacteristicValueUpsertArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacteristicValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueCountArgs} args - Arguments to filter CharacteristicValues to count.
     * @example
     * // Count the number of CharacteristicValues
     * const count = await prisma.characteristicValue.count({
     *   where: {
     *     // ... the filter for the CharacteristicValues we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicValueCountArgs>(
      args?: Subset<T, CharacteristicValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacteristicValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicValueAggregateArgs>(args: Subset<T, CharacteristicValueAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicValueAggregateType<T>>

    /**
     * Group by CharacteristicValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicValueGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacteristicValue model
   */
  readonly fields: CharacteristicValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacteristicValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characteristic<T extends CharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicDefaultArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productValues<T extends CharacteristicValue$productValuesArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicValue$productValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacteristicValue model
   */
  interface CharacteristicValueFieldRefs {
    readonly id: FieldRef<"CharacteristicValue", 'String'>
    readonly characteristicId: FieldRef<"CharacteristicValue", 'String'>
    readonly value: FieldRef<"CharacteristicValue", 'String'>
    readonly sortOrder: FieldRef<"CharacteristicValue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CharacteristicValue findUnique
   */
  export type CharacteristicValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicValue to fetch.
     */
    where: CharacteristicValueWhereUniqueInput
  }

  /**
   * CharacteristicValue findUniqueOrThrow
   */
  export type CharacteristicValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicValue to fetch.
     */
    where: CharacteristicValueWhereUniqueInput
  }

  /**
   * CharacteristicValue findFirst
   */
  export type CharacteristicValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicValue to fetch.
     */
    where?: CharacteristicValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicValues to fetch.
     */
    orderBy?: CharacteristicValueOrderByWithRelationInput | CharacteristicValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicValues.
     */
    cursor?: CharacteristicValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicValues.
     */
    distinct?: CharacteristicValueScalarFieldEnum | CharacteristicValueScalarFieldEnum[]
  }

  /**
   * CharacteristicValue findFirstOrThrow
   */
  export type CharacteristicValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicValue to fetch.
     */
    where?: CharacteristicValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicValues to fetch.
     */
    orderBy?: CharacteristicValueOrderByWithRelationInput | CharacteristicValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicValues.
     */
    cursor?: CharacteristicValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicValues.
     */
    distinct?: CharacteristicValueScalarFieldEnum | CharacteristicValueScalarFieldEnum[]
  }

  /**
   * CharacteristicValue findMany
   */
  export type CharacteristicValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicValues to fetch.
     */
    where?: CharacteristicValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicValues to fetch.
     */
    orderBy?: CharacteristicValueOrderByWithRelationInput | CharacteristicValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacteristicValues.
     */
    cursor?: CharacteristicValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicValues.
     */
    skip?: number
    distinct?: CharacteristicValueScalarFieldEnum | CharacteristicValueScalarFieldEnum[]
  }

  /**
   * CharacteristicValue create
   */
  export type CharacteristicValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacteristicValue.
     */
    data: XOR<CharacteristicValueCreateInput, CharacteristicValueUncheckedCreateInput>
  }

  /**
   * CharacteristicValue createMany
   */
  export type CharacteristicValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacteristicValues.
     */
    data: CharacteristicValueCreateManyInput | CharacteristicValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacteristicValue createManyAndReturn
   */
  export type CharacteristicValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * The data used to create many CharacteristicValues.
     */
    data: CharacteristicValueCreateManyInput | CharacteristicValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacteristicValue update
   */
  export type CharacteristicValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacteristicValue.
     */
    data: XOR<CharacteristicValueUpdateInput, CharacteristicValueUncheckedUpdateInput>
    /**
     * Choose, which CharacteristicValue to update.
     */
    where: CharacteristicValueWhereUniqueInput
  }

  /**
   * CharacteristicValue updateMany
   */
  export type CharacteristicValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacteristicValues.
     */
    data: XOR<CharacteristicValueUpdateManyMutationInput, CharacteristicValueUncheckedUpdateManyInput>
    /**
     * Filter which CharacteristicValues to update
     */
    where?: CharacteristicValueWhereInput
    /**
     * Limit how many CharacteristicValues to update.
     */
    limit?: number
  }

  /**
   * CharacteristicValue updateManyAndReturn
   */
  export type CharacteristicValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * The data used to update CharacteristicValues.
     */
    data: XOR<CharacteristicValueUpdateManyMutationInput, CharacteristicValueUncheckedUpdateManyInput>
    /**
     * Filter which CharacteristicValues to update
     */
    where?: CharacteristicValueWhereInput
    /**
     * Limit how many CharacteristicValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacteristicValue upsert
   */
  export type CharacteristicValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacteristicValue to update in case it exists.
     */
    where: CharacteristicValueWhereUniqueInput
    /**
     * In case the CharacteristicValue found by the `where` argument doesn't exist, create a new CharacteristicValue with this data.
     */
    create: XOR<CharacteristicValueCreateInput, CharacteristicValueUncheckedCreateInput>
    /**
     * In case the CharacteristicValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicValueUpdateInput, CharacteristicValueUncheckedUpdateInput>
  }

  /**
   * CharacteristicValue delete
   */
  export type CharacteristicValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    /**
     * Filter which CharacteristicValue to delete.
     */
    where: CharacteristicValueWhereUniqueInput
  }

  /**
   * CharacteristicValue deleteMany
   */
  export type CharacteristicValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicValues to delete
     */
    where?: CharacteristicValueWhereInput
    /**
     * Limit how many CharacteristicValues to delete.
     */
    limit?: number
  }

  /**
   * CharacteristicValue.productValues
   */
  export type CharacteristicValue$productValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    cursor?: ProductCharacteristicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * CharacteristicValue without action
   */
  export type CharacteristicValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
  }


  /**
   * Model ProductCharacteristic
   */

  export type AggregateProductCharacteristic = {
    _count: ProductCharacteristicCountAggregateOutputType | null
    _min: ProductCharacteristicMinAggregateOutputType | null
    _max: ProductCharacteristicMaxAggregateOutputType | null
  }

  export type ProductCharacteristicMinAggregateOutputType = {
    id: string | null
    productId: string | null
    characteristicId: string | null
    value: string | null
    characteristicValueId: string | null
  }

  export type ProductCharacteristicMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    characteristicId: string | null
    value: string | null
    characteristicValueId: string | null
  }

  export type ProductCharacteristicCountAggregateOutputType = {
    id: number
    productId: number
    characteristicId: number
    value: number
    characteristicValueId: number
    _all: number
  }


  export type ProductCharacteristicMinAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    value?: true
    characteristicValueId?: true
  }

  export type ProductCharacteristicMaxAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    value?: true
    characteristicValueId?: true
  }

  export type ProductCharacteristicCountAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    value?: true
    characteristicValueId?: true
    _all?: true
  }

  export type ProductCharacteristicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristic to aggregate.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCharacteristics
    **/
    _count?: true | ProductCharacteristicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCharacteristicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCharacteristicMaxAggregateInputType
  }

  export type GetProductCharacteristicAggregateType<T extends ProductCharacteristicAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCharacteristic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCharacteristic[P]>
      : GetScalarType<T[P], AggregateProductCharacteristic[P]>
  }




  export type ProductCharacteristicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithAggregationInput | ProductCharacteristicOrderByWithAggregationInput[]
    by: ProductCharacteristicScalarFieldEnum[] | ProductCharacteristicScalarFieldEnum
    having?: ProductCharacteristicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCharacteristicCountAggregateInputType | true
    _min?: ProductCharacteristicMinAggregateInputType
    _max?: ProductCharacteristicMaxAggregateInputType
  }

  export type ProductCharacteristicGroupByOutputType = {
    id: string
    productId: string
    characteristicId: string
    value: string | null
    characteristicValueId: string | null
    _count: ProductCharacteristicCountAggregateOutputType | null
    _min: ProductCharacteristicMinAggregateOutputType | null
    _max: ProductCharacteristicMaxAggregateOutputType | null
  }

  type GetProductCharacteristicGroupByPayload<T extends ProductCharacteristicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCharacteristicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCharacteristicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCharacteristicGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCharacteristicGroupByOutputType[P]>
        }
      >
    >


  export type ProductCharacteristicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    value?: boolean
    characteristicValueId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristic"]>

  export type ProductCharacteristicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    value?: boolean
    characteristicValueId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristic"]>

  export type ProductCharacteristicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    value?: boolean
    characteristicValueId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristic"]>

  export type ProductCharacteristicSelectScalar = {
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    value?: boolean
    characteristicValueId?: boolean
  }

  export type ProductCharacteristicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "characteristicId" | "value" | "characteristicValueId", ExtArgs["result"]["productCharacteristic"]>
  export type ProductCharacteristicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }
  export type ProductCharacteristicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }
  export type ProductCharacteristicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    characteristicValue?: boolean | ProductCharacteristic$characteristicValueArgs<ExtArgs>
  }

  export type $ProductCharacteristicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCharacteristic"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      characteristic: Prisma.$CharacteristicPayload<ExtArgs>
      characteristicValue: Prisma.$CharacteristicValuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      characteristicId: string
      value: string | null
      characteristicValueId: string | null
    }, ExtArgs["result"]["productCharacteristic"]>
    composites: {}
  }

  type ProductCharacteristicGetPayload<S extends boolean | null | undefined | ProductCharacteristicDefaultArgs> = $Result.GetResult<Prisma.$ProductCharacteristicPayload, S>

  type ProductCharacteristicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductCharacteristicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCharacteristicCountAggregateInputType | true
    }

  export interface ProductCharacteristicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCharacteristic'], meta: { name: 'ProductCharacteristic' } }
    /**
     * Find zero or one ProductCharacteristic that matches the filter.
     * @param {ProductCharacteristicFindUniqueArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCharacteristicFindUniqueArgs>(args: SelectSubset<T, ProductCharacteristicFindUniqueArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductCharacteristic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductCharacteristicFindUniqueOrThrowArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCharacteristicFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCharacteristic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindFirstArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCharacteristicFindFirstArgs>(args?: SelectSubset<T, ProductCharacteristicFindFirstArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductCharacteristic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindFirstOrThrowArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCharacteristicFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCharacteristicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductCharacteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCharacteristics
     * const productCharacteristics = await prisma.productCharacteristic.findMany()
     * 
     * // Get first 10 ProductCharacteristics
     * const productCharacteristics = await prisma.productCharacteristic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCharacteristicWithIdOnly = await prisma.productCharacteristic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCharacteristicFindManyArgs>(args?: SelectSubset<T, ProductCharacteristicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductCharacteristic.
     * @param {ProductCharacteristicCreateArgs} args - Arguments to create a ProductCharacteristic.
     * @example
     * // Create one ProductCharacteristic
     * const ProductCharacteristic = await prisma.productCharacteristic.create({
     *   data: {
     *     // ... data to create a ProductCharacteristic
     *   }
     * })
     * 
     */
    create<T extends ProductCharacteristicCreateArgs>(args: SelectSubset<T, ProductCharacteristicCreateArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductCharacteristics.
     * @param {ProductCharacteristicCreateManyArgs} args - Arguments to create many ProductCharacteristics.
     * @example
     * // Create many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCharacteristicCreateManyArgs>(args?: SelectSubset<T, ProductCharacteristicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCharacteristics and returns the data saved in the database.
     * @param {ProductCharacteristicCreateManyAndReturnArgs} args - Arguments to create many ProductCharacteristics.
     * @example
     * // Create many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCharacteristics and only return the `id`
     * const productCharacteristicWithIdOnly = await prisma.productCharacteristic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCharacteristicCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCharacteristicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductCharacteristic.
     * @param {ProductCharacteristicDeleteArgs} args - Arguments to delete one ProductCharacteristic.
     * @example
     * // Delete one ProductCharacteristic
     * const ProductCharacteristic = await prisma.productCharacteristic.delete({
     *   where: {
     *     // ... filter to delete one ProductCharacteristic
     *   }
     * })
     * 
     */
    delete<T extends ProductCharacteristicDeleteArgs>(args: SelectSubset<T, ProductCharacteristicDeleteArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductCharacteristic.
     * @param {ProductCharacteristicUpdateArgs} args - Arguments to update one ProductCharacteristic.
     * @example
     * // Update one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCharacteristicUpdateArgs>(args: SelectSubset<T, ProductCharacteristicUpdateArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductCharacteristics.
     * @param {ProductCharacteristicDeleteManyArgs} args - Arguments to filter ProductCharacteristics to delete.
     * @example
     * // Delete a few ProductCharacteristics
     * const { count } = await prisma.productCharacteristic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCharacteristicDeleteManyArgs>(args?: SelectSubset<T, ProductCharacteristicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCharacteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCharacteristicUpdateManyArgs>(args: SelectSubset<T, ProductCharacteristicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCharacteristics and returns the data updated in the database.
     * @param {ProductCharacteristicUpdateManyAndReturnArgs} args - Arguments to update many ProductCharacteristics.
     * @example
     * // Update many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductCharacteristics and only return the `id`
     * const productCharacteristicWithIdOnly = await prisma.productCharacteristic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductCharacteristicUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductCharacteristicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductCharacteristic.
     * @param {ProductCharacteristicUpsertArgs} args - Arguments to update or create a ProductCharacteristic.
     * @example
     * // Update or create a ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.upsert({
     *   create: {
     *     // ... data to create a ProductCharacteristic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCharacteristic we want to update
     *   }
     * })
     */
    upsert<T extends ProductCharacteristicUpsertArgs>(args: SelectSubset<T, ProductCharacteristicUpsertArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductCharacteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicCountArgs} args - Arguments to filter ProductCharacteristics to count.
     * @example
     * // Count the number of ProductCharacteristics
     * const count = await prisma.productCharacteristic.count({
     *   where: {
     *     // ... the filter for the ProductCharacteristics we want to count
     *   }
     * })
    **/
    count<T extends ProductCharacteristicCountArgs>(
      args?: Subset<T, ProductCharacteristicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCharacteristicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCharacteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCharacteristicAggregateArgs>(args: Subset<T, ProductCharacteristicAggregateArgs>): Prisma.PrismaPromise<GetProductCharacteristicAggregateType<T>>

    /**
     * Group by ProductCharacteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCharacteristicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCharacteristicGroupByArgs['orderBy'] }
        : { orderBy?: ProductCharacteristicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCharacteristicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCharacteristicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCharacteristic model
   */
  readonly fields: ProductCharacteristicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCharacteristic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCharacteristicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characteristic<T extends CharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicDefaultArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characteristicValue<T extends ProductCharacteristic$characteristicValueArgs<ExtArgs> = {}>(args?: Subset<T, ProductCharacteristic$characteristicValueArgs<ExtArgs>>): Prisma__CharacteristicValueClient<$Result.GetResult<Prisma.$CharacteristicValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCharacteristic model
   */
  interface ProductCharacteristicFieldRefs {
    readonly id: FieldRef<"ProductCharacteristic", 'String'>
    readonly productId: FieldRef<"ProductCharacteristic", 'String'>
    readonly characteristicId: FieldRef<"ProductCharacteristic", 'String'>
    readonly value: FieldRef<"ProductCharacteristic", 'String'>
    readonly characteristicValueId: FieldRef<"ProductCharacteristic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCharacteristic findUnique
   */
  export type ProductCharacteristicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic findUniqueOrThrow
   */
  export type ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic findFirst
   */
  export type ProductCharacteristicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristics.
     */
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic findFirstOrThrow
   */
  export type ProductCharacteristicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristics.
     */
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic findMany
   */
  export type ProductCharacteristicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristics to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic create
   */
  export type ProductCharacteristicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCharacteristic.
     */
    data: XOR<ProductCharacteristicCreateInput, ProductCharacteristicUncheckedCreateInput>
  }

  /**
   * ProductCharacteristic createMany
   */
  export type ProductCharacteristicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCharacteristics.
     */
    data: ProductCharacteristicCreateManyInput | ProductCharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCharacteristic createManyAndReturn
   */
  export type ProductCharacteristicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * The data used to create many ProductCharacteristics.
     */
    data: ProductCharacteristicCreateManyInput | ProductCharacteristicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCharacteristic update
   */
  export type ProductCharacteristicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCharacteristic.
     */
    data: XOR<ProductCharacteristicUpdateInput, ProductCharacteristicUncheckedUpdateInput>
    /**
     * Choose, which ProductCharacteristic to update.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic updateMany
   */
  export type ProductCharacteristicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCharacteristics.
     */
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which ProductCharacteristics to update
     */
    where?: ProductCharacteristicWhereInput
    /**
     * Limit how many ProductCharacteristics to update.
     */
    limit?: number
  }

  /**
   * ProductCharacteristic updateManyAndReturn
   */
  export type ProductCharacteristicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * The data used to update ProductCharacteristics.
     */
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which ProductCharacteristics to update
     */
    where?: ProductCharacteristicWhereInput
    /**
     * Limit how many ProductCharacteristics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCharacteristic upsert
   */
  export type ProductCharacteristicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCharacteristic to update in case it exists.
     */
    where: ProductCharacteristicWhereUniqueInput
    /**
     * In case the ProductCharacteristic found by the `where` argument doesn't exist, create a new ProductCharacteristic with this data.
     */
    create: XOR<ProductCharacteristicCreateInput, ProductCharacteristicUncheckedCreateInput>
    /**
     * In case the ProductCharacteristic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCharacteristicUpdateInput, ProductCharacteristicUncheckedUpdateInput>
  }

  /**
   * ProductCharacteristic delete
   */
  export type ProductCharacteristicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter which ProductCharacteristic to delete.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic deleteMany
   */
  export type ProductCharacteristicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristics to delete
     */
    where?: ProductCharacteristicWhereInput
    /**
     * Limit how many ProductCharacteristics to delete.
     */
    limit?: number
  }

  /**
   * ProductCharacteristic.characteristicValue
   */
  export type ProductCharacteristic$characteristicValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicValue
     */
    select?: CharacteristicValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacteristicValue
     */
    omit?: CharacteristicValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicValueInclude<ExtArgs> | null
    where?: CharacteristicValueWhereInput
  }

  /**
   * ProductCharacteristic without action
   */
  export type ProductCharacteristicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductCharacteristic
     */
    omit?: ProductCharacteristicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
  }


  /**
   * Model VehicleMake
   */

  export type AggregateVehicleMake = {
    _count: VehicleMakeCountAggregateOutputType | null
    _min: VehicleMakeMinAggregateOutputType | null
    _max: VehicleMakeMaxAggregateOutputType | null
  }

  export type VehicleMakeMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    country: string | null
    logoUrl: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleMakeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    country: string | null
    logoUrl: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleMakeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    country: number
    logoUrl: number
    description: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    _all: number
  }


  export type VehicleMakeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country?: true
    logoUrl?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleMakeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country?: true
    logoUrl?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleMakeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    country?: true
    logoUrl?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    _all?: true
  }

  export type VehicleMakeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleMake to aggregate.
     */
    where?: VehicleMakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleMakes to fetch.
     */
    orderBy?: VehicleMakeOrderByWithRelationInput | VehicleMakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleMakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleMakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleMakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleMakes
    **/
    _count?: true | VehicleMakeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMakeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMakeMaxAggregateInputType
  }

  export type GetVehicleMakeAggregateType<T extends VehicleMakeAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleMake]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleMake[P]>
      : GetScalarType<T[P], AggregateVehicleMake[P]>
  }




  export type VehicleMakeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleMakeWhereInput
    orderBy?: VehicleMakeOrderByWithAggregationInput | VehicleMakeOrderByWithAggregationInput[]
    by: VehicleMakeScalarFieldEnum[] | VehicleMakeScalarFieldEnum
    having?: VehicleMakeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleMakeCountAggregateInputType | true
    _min?: VehicleMakeMinAggregateInputType
    _max?: VehicleMakeMaxAggregateInputType
  }

  export type VehicleMakeGroupByOutputType = {
    id: string
    name: string
    slug: string
    country: string | null
    logoUrl: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    _count: VehicleMakeCountAggregateOutputType | null
    _min: VehicleMakeMinAggregateOutputType | null
    _max: VehicleMakeMaxAggregateOutputType | null
  }

  type GetVehicleMakeGroupByPayload<T extends VehicleMakeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleMakeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleMakeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleMakeGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleMakeGroupByOutputType[P]>
        }
      >
    >


  export type VehicleMakeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    country?: boolean
    logoUrl?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    models?: boolean | VehicleMake$modelsArgs<ExtArgs>
    _count?: boolean | VehicleMakeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleMake"]>

  export type VehicleMakeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    country?: boolean
    logoUrl?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }, ExtArgs["result"]["vehicleMake"]>

  export type VehicleMakeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    country?: boolean
    logoUrl?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }, ExtArgs["result"]["vehicleMake"]>

  export type VehicleMakeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    country?: boolean
    logoUrl?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }

  export type VehicleMakeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "country" | "logoUrl" | "description" | "metaTitle" | "metaDescription" | "metaKeywords", ExtArgs["result"]["vehicleMake"]>
  export type VehicleMakeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | VehicleMake$modelsArgs<ExtArgs>
    _count?: boolean | VehicleMakeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleMakeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VehicleMakeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VehicleMakePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleMake"
    objects: {
      models: Prisma.$VehicleModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      country: string | null
      logoUrl: string | null
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
    }, ExtArgs["result"]["vehicleMake"]>
    composites: {}
  }

  type VehicleMakeGetPayload<S extends boolean | null | undefined | VehicleMakeDefaultArgs> = $Result.GetResult<Prisma.$VehicleMakePayload, S>

  type VehicleMakeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleMakeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleMakeCountAggregateInputType | true
    }

  export interface VehicleMakeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleMake'], meta: { name: 'VehicleMake' } }
    /**
     * Find zero or one VehicleMake that matches the filter.
     * @param {VehicleMakeFindUniqueArgs} args - Arguments to find a VehicleMake
     * @example
     * // Get one VehicleMake
     * const vehicleMake = await prisma.vehicleMake.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleMakeFindUniqueArgs>(args: SelectSubset<T, VehicleMakeFindUniqueArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleMake that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleMakeFindUniqueOrThrowArgs} args - Arguments to find a VehicleMake
     * @example
     * // Get one VehicleMake
     * const vehicleMake = await prisma.vehicleMake.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleMakeFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleMakeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleMake that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeFindFirstArgs} args - Arguments to find a VehicleMake
     * @example
     * // Get one VehicleMake
     * const vehicleMake = await prisma.vehicleMake.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleMakeFindFirstArgs>(args?: SelectSubset<T, VehicleMakeFindFirstArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleMake that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeFindFirstOrThrowArgs} args - Arguments to find a VehicleMake
     * @example
     * // Get one VehicleMake
     * const vehicleMake = await prisma.vehicleMake.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleMakeFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleMakeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleMakes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleMakes
     * const vehicleMakes = await prisma.vehicleMake.findMany()
     * 
     * // Get first 10 VehicleMakes
     * const vehicleMakes = await prisma.vehicleMake.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleMakeWithIdOnly = await prisma.vehicleMake.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleMakeFindManyArgs>(args?: SelectSubset<T, VehicleMakeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleMake.
     * @param {VehicleMakeCreateArgs} args - Arguments to create a VehicleMake.
     * @example
     * // Create one VehicleMake
     * const VehicleMake = await prisma.vehicleMake.create({
     *   data: {
     *     // ... data to create a VehicleMake
     *   }
     * })
     * 
     */
    create<T extends VehicleMakeCreateArgs>(args: SelectSubset<T, VehicleMakeCreateArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleMakes.
     * @param {VehicleMakeCreateManyArgs} args - Arguments to create many VehicleMakes.
     * @example
     * // Create many VehicleMakes
     * const vehicleMake = await prisma.vehicleMake.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleMakeCreateManyArgs>(args?: SelectSubset<T, VehicleMakeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleMakes and returns the data saved in the database.
     * @param {VehicleMakeCreateManyAndReturnArgs} args - Arguments to create many VehicleMakes.
     * @example
     * // Create many VehicleMakes
     * const vehicleMake = await prisma.vehicleMake.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleMakes and only return the `id`
     * const vehicleMakeWithIdOnly = await prisma.vehicleMake.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleMakeCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleMakeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleMake.
     * @param {VehicleMakeDeleteArgs} args - Arguments to delete one VehicleMake.
     * @example
     * // Delete one VehicleMake
     * const VehicleMake = await prisma.vehicleMake.delete({
     *   where: {
     *     // ... filter to delete one VehicleMake
     *   }
     * })
     * 
     */
    delete<T extends VehicleMakeDeleteArgs>(args: SelectSubset<T, VehicleMakeDeleteArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleMake.
     * @param {VehicleMakeUpdateArgs} args - Arguments to update one VehicleMake.
     * @example
     * // Update one VehicleMake
     * const vehicleMake = await prisma.vehicleMake.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleMakeUpdateArgs>(args: SelectSubset<T, VehicleMakeUpdateArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleMakes.
     * @param {VehicleMakeDeleteManyArgs} args - Arguments to filter VehicleMakes to delete.
     * @example
     * // Delete a few VehicleMakes
     * const { count } = await prisma.vehicleMake.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleMakeDeleteManyArgs>(args?: SelectSubset<T, VehicleMakeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleMakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleMakes
     * const vehicleMake = await prisma.vehicleMake.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleMakeUpdateManyArgs>(args: SelectSubset<T, VehicleMakeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleMakes and returns the data updated in the database.
     * @param {VehicleMakeUpdateManyAndReturnArgs} args - Arguments to update many VehicleMakes.
     * @example
     * // Update many VehicleMakes
     * const vehicleMake = await prisma.vehicleMake.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleMakes and only return the `id`
     * const vehicleMakeWithIdOnly = await prisma.vehicleMake.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleMakeUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleMakeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleMake.
     * @param {VehicleMakeUpsertArgs} args - Arguments to update or create a VehicleMake.
     * @example
     * // Update or create a VehicleMake
     * const vehicleMake = await prisma.vehicleMake.upsert({
     *   create: {
     *     // ... data to create a VehicleMake
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleMake we want to update
     *   }
     * })
     */
    upsert<T extends VehicleMakeUpsertArgs>(args: SelectSubset<T, VehicleMakeUpsertArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleMakes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeCountArgs} args - Arguments to filter VehicleMakes to count.
     * @example
     * // Count the number of VehicleMakes
     * const count = await prisma.vehicleMake.count({
     *   where: {
     *     // ... the filter for the VehicleMakes we want to count
     *   }
     * })
    **/
    count<T extends VehicleMakeCountArgs>(
      args?: Subset<T, VehicleMakeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleMakeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleMake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleMakeAggregateArgs>(args: Subset<T, VehicleMakeAggregateArgs>): Prisma.PrismaPromise<GetVehicleMakeAggregateType<T>>

    /**
     * Group by VehicleMake.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleMakeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleMakeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleMakeGroupByArgs['orderBy'] }
        : { orderBy?: VehicleMakeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleMakeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleMakeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleMake model
   */
  readonly fields: VehicleMakeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleMake.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleMakeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends VehicleMake$modelsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleMake$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleMake model
   */
  interface VehicleMakeFieldRefs {
    readonly id: FieldRef<"VehicleMake", 'String'>
    readonly name: FieldRef<"VehicleMake", 'String'>
    readonly slug: FieldRef<"VehicleMake", 'String'>
    readonly country: FieldRef<"VehicleMake", 'String'>
    readonly logoUrl: FieldRef<"VehicleMake", 'String'>
    readonly description: FieldRef<"VehicleMake", 'String'>
    readonly metaTitle: FieldRef<"VehicleMake", 'String'>
    readonly metaDescription: FieldRef<"VehicleMake", 'String'>
    readonly metaKeywords: FieldRef<"VehicleMake", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleMake findUnique
   */
  export type VehicleMakeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleMake to fetch.
     */
    where: VehicleMakeWhereUniqueInput
  }

  /**
   * VehicleMake findUniqueOrThrow
   */
  export type VehicleMakeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleMake to fetch.
     */
    where: VehicleMakeWhereUniqueInput
  }

  /**
   * VehicleMake findFirst
   */
  export type VehicleMakeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleMake to fetch.
     */
    where?: VehicleMakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleMakes to fetch.
     */
    orderBy?: VehicleMakeOrderByWithRelationInput | VehicleMakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleMakes.
     */
    cursor?: VehicleMakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleMakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleMakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleMakes.
     */
    distinct?: VehicleMakeScalarFieldEnum | VehicleMakeScalarFieldEnum[]
  }

  /**
   * VehicleMake findFirstOrThrow
   */
  export type VehicleMakeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleMake to fetch.
     */
    where?: VehicleMakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleMakes to fetch.
     */
    orderBy?: VehicleMakeOrderByWithRelationInput | VehicleMakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleMakes.
     */
    cursor?: VehicleMakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleMakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleMakes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleMakes.
     */
    distinct?: VehicleMakeScalarFieldEnum | VehicleMakeScalarFieldEnum[]
  }

  /**
   * VehicleMake findMany
   */
  export type VehicleMakeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter, which VehicleMakes to fetch.
     */
    where?: VehicleMakeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleMakes to fetch.
     */
    orderBy?: VehicleMakeOrderByWithRelationInput | VehicleMakeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleMakes.
     */
    cursor?: VehicleMakeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleMakes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleMakes.
     */
    skip?: number
    distinct?: VehicleMakeScalarFieldEnum | VehicleMakeScalarFieldEnum[]
  }

  /**
   * VehicleMake create
   */
  export type VehicleMakeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleMake.
     */
    data: XOR<VehicleMakeCreateInput, VehicleMakeUncheckedCreateInput>
  }

  /**
   * VehicleMake createMany
   */
  export type VehicleMakeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleMakes.
     */
    data: VehicleMakeCreateManyInput | VehicleMakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleMake createManyAndReturn
   */
  export type VehicleMakeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleMakes.
     */
    data: VehicleMakeCreateManyInput | VehicleMakeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleMake update
   */
  export type VehicleMakeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleMake.
     */
    data: XOR<VehicleMakeUpdateInput, VehicleMakeUncheckedUpdateInput>
    /**
     * Choose, which VehicleMake to update.
     */
    where: VehicleMakeWhereUniqueInput
  }

  /**
   * VehicleMake updateMany
   */
  export type VehicleMakeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleMakes.
     */
    data: XOR<VehicleMakeUpdateManyMutationInput, VehicleMakeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleMakes to update
     */
    where?: VehicleMakeWhereInput
    /**
     * Limit how many VehicleMakes to update.
     */
    limit?: number
  }

  /**
   * VehicleMake updateManyAndReturn
   */
  export type VehicleMakeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * The data used to update VehicleMakes.
     */
    data: XOR<VehicleMakeUpdateManyMutationInput, VehicleMakeUncheckedUpdateManyInput>
    /**
     * Filter which VehicleMakes to update
     */
    where?: VehicleMakeWhereInput
    /**
     * Limit how many VehicleMakes to update.
     */
    limit?: number
  }

  /**
   * VehicleMake upsert
   */
  export type VehicleMakeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleMake to update in case it exists.
     */
    where: VehicleMakeWhereUniqueInput
    /**
     * In case the VehicleMake found by the `where` argument doesn't exist, create a new VehicleMake with this data.
     */
    create: XOR<VehicleMakeCreateInput, VehicleMakeUncheckedCreateInput>
    /**
     * In case the VehicleMake was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleMakeUpdateInput, VehicleMakeUncheckedUpdateInput>
  }

  /**
   * VehicleMake delete
   */
  export type VehicleMakeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
    /**
     * Filter which VehicleMake to delete.
     */
    where: VehicleMakeWhereUniqueInput
  }

  /**
   * VehicleMake deleteMany
   */
  export type VehicleMakeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleMakes to delete
     */
    where?: VehicleMakeWhereInput
    /**
     * Limit how many VehicleMakes to delete.
     */
    limit?: number
  }

  /**
   * VehicleMake.models
   */
  export type VehicleMake$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    where?: VehicleModelWhereInput
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    cursor?: VehicleModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleMake without action
   */
  export type VehicleMakeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleMake
     */
    select?: VehicleMakeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleMake
     */
    omit?: VehicleMakeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleMakeInclude<ExtArgs> | null
  }


  /**
   * Model VehicleModel
   */

  export type AggregateVehicleModel = {
    _count: VehicleModelCountAggregateOutputType | null
    _avg: VehicleModelAvgAggregateOutputType | null
    _sum: VehicleModelSumAggregateOutputType | null
    _min: VehicleModelMinAggregateOutputType | null
    _max: VehicleModelMaxAggregateOutputType | null
  }

  export type VehicleModelAvgAggregateOutputType = {
    startYear: number | null
    endYear: number | null
  }

  export type VehicleModelSumAggregateOutputType = {
    startYear: number | null
    endYear: number | null
  }

  export type VehicleModelMinAggregateOutputType = {
    id: string | null
    makeId: string | null
    name: string | null
    slug: string | null
    modelCode: string | null
    startYear: number | null
    endYear: number | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleModelMaxAggregateOutputType = {
    id: string | null
    makeId: string | null
    name: string | null
    slug: string | null
    modelCode: string | null
    startYear: number | null
    endYear: number | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleModelCountAggregateOutputType = {
    id: number
    makeId: number
    name: number
    slug: number
    modelCode: number
    startYear: number
    endYear: number
    description: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    _all: number
  }


  export type VehicleModelAvgAggregateInputType = {
    startYear?: true
    endYear?: true
  }

  export type VehicleModelSumAggregateInputType = {
    startYear?: true
    endYear?: true
  }

  export type VehicleModelMinAggregateInputType = {
    id?: true
    makeId?: true
    name?: true
    slug?: true
    modelCode?: true
    startYear?: true
    endYear?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleModelMaxAggregateInputType = {
    id?: true
    makeId?: true
    name?: true
    slug?: true
    modelCode?: true
    startYear?: true
    endYear?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleModelCountAggregateInputType = {
    id?: true
    makeId?: true
    name?: true
    slug?: true
    modelCode?: true
    startYear?: true
    endYear?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    _all?: true
  }

  export type VehicleModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModel to aggregate.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleModels
    **/
    _count?: true | VehicleModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleModelMaxAggregateInputType
  }

  export type GetVehicleModelAggregateType<T extends VehicleModelAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleModel[P]>
      : GetScalarType<T[P], AggregateVehicleModel[P]>
  }




  export type VehicleModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleModelWhereInput
    orderBy?: VehicleModelOrderByWithAggregationInput | VehicleModelOrderByWithAggregationInput[]
    by: VehicleModelScalarFieldEnum[] | VehicleModelScalarFieldEnum
    having?: VehicleModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleModelCountAggregateInputType | true
    _avg?: VehicleModelAvgAggregateInputType
    _sum?: VehicleModelSumAggregateInputType
    _min?: VehicleModelMinAggregateInputType
    _max?: VehicleModelMaxAggregateInputType
  }

  export type VehicleModelGroupByOutputType = {
    id: string
    makeId: string
    name: string
    slug: string
    modelCode: string | null
    startYear: number
    endYear: number | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    _count: VehicleModelCountAggregateOutputType | null
    _avg: VehicleModelAvgAggregateOutputType | null
    _sum: VehicleModelSumAggregateOutputType | null
    _min: VehicleModelMinAggregateOutputType | null
    _max: VehicleModelMaxAggregateOutputType | null
  }

  type GetVehicleModelGroupByPayload<T extends VehicleModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleModelGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleModelGroupByOutputType[P]>
        }
      >
    >


  export type VehicleModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    makeId?: boolean
    name?: boolean
    slug?: boolean
    modelCode?: boolean
    startYear?: boolean
    endYear?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
    generations?: boolean | VehicleModel$generationsArgs<ExtArgs>
    _count?: boolean | VehicleModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModel"]>

  export type VehicleModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    makeId?: boolean
    name?: boolean
    slug?: boolean
    modelCode?: boolean
    startYear?: boolean
    endYear?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModel"]>

  export type VehicleModelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    makeId?: boolean
    name?: boolean
    slug?: boolean
    modelCode?: boolean
    startYear?: boolean
    endYear?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModel"]>

  export type VehicleModelSelectScalar = {
    id?: boolean
    makeId?: boolean
    name?: boolean
    slug?: boolean
    modelCode?: boolean
    startYear?: boolean
    endYear?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }

  export type VehicleModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "makeId" | "name" | "slug" | "modelCode" | "startYear" | "endYear" | "description" | "metaTitle" | "metaDescription" | "metaKeywords", ExtArgs["result"]["vehicleModel"]>
  export type VehicleModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
    generations?: boolean | VehicleModel$generationsArgs<ExtArgs>
    _count?: boolean | VehicleModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
  }
  export type VehicleModelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    make?: boolean | VehicleMakeDefaultArgs<ExtArgs>
  }

  export type $VehicleModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleModel"
    objects: {
      make: Prisma.$VehicleMakePayload<ExtArgs>
      generations: Prisma.$VehicleGenerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      makeId: string
      name: string
      slug: string
      modelCode: string | null
      startYear: number
      endYear: number | null
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
    }, ExtArgs["result"]["vehicleModel"]>
    composites: {}
  }

  type VehicleModelGetPayload<S extends boolean | null | undefined | VehicleModelDefaultArgs> = $Result.GetResult<Prisma.$VehicleModelPayload, S>

  type VehicleModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleModelCountAggregateInputType | true
    }

  export interface VehicleModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleModel'], meta: { name: 'VehicleModel' } }
    /**
     * Find zero or one VehicleModel that matches the filter.
     * @param {VehicleModelFindUniqueArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleModelFindUniqueArgs>(args: SelectSubset<T, VehicleModelFindUniqueArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleModelFindUniqueOrThrowArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleModelFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindFirstArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleModelFindFirstArgs>(args?: SelectSubset<T, VehicleModelFindFirstArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindFirstOrThrowArgs} args - Arguments to find a VehicleModel
     * @example
     * // Get one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleModelFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleModels
     * const vehicleModels = await prisma.vehicleModel.findMany()
     * 
     * // Get first 10 VehicleModels
     * const vehicleModels = await prisma.vehicleModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleModelWithIdOnly = await prisma.vehicleModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleModelFindManyArgs>(args?: SelectSubset<T, VehicleModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleModel.
     * @param {VehicleModelCreateArgs} args - Arguments to create a VehicleModel.
     * @example
     * // Create one VehicleModel
     * const VehicleModel = await prisma.vehicleModel.create({
     *   data: {
     *     // ... data to create a VehicleModel
     *   }
     * })
     * 
     */
    create<T extends VehicleModelCreateArgs>(args: SelectSubset<T, VehicleModelCreateArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleModels.
     * @param {VehicleModelCreateManyArgs} args - Arguments to create many VehicleModels.
     * @example
     * // Create many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleModelCreateManyArgs>(args?: SelectSubset<T, VehicleModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleModels and returns the data saved in the database.
     * @param {VehicleModelCreateManyAndReturnArgs} args - Arguments to create many VehicleModels.
     * @example
     * // Create many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleModels and only return the `id`
     * const vehicleModelWithIdOnly = await prisma.vehicleModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleModelCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleModel.
     * @param {VehicleModelDeleteArgs} args - Arguments to delete one VehicleModel.
     * @example
     * // Delete one VehicleModel
     * const VehicleModel = await prisma.vehicleModel.delete({
     *   where: {
     *     // ... filter to delete one VehicleModel
     *   }
     * })
     * 
     */
    delete<T extends VehicleModelDeleteArgs>(args: SelectSubset<T, VehicleModelDeleteArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleModel.
     * @param {VehicleModelUpdateArgs} args - Arguments to update one VehicleModel.
     * @example
     * // Update one VehicleModel
     * const vehicleModel = await prisma.vehicleModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleModelUpdateArgs>(args: SelectSubset<T, VehicleModelUpdateArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleModels.
     * @param {VehicleModelDeleteManyArgs} args - Arguments to filter VehicleModels to delete.
     * @example
     * // Delete a few VehicleModels
     * const { count } = await prisma.vehicleModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleModelDeleteManyArgs>(args?: SelectSubset<T, VehicleModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleModelUpdateManyArgs>(args: SelectSubset<T, VehicleModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleModels and returns the data updated in the database.
     * @param {VehicleModelUpdateManyAndReturnArgs} args - Arguments to update many VehicleModels.
     * @example
     * // Update many VehicleModels
     * const vehicleModel = await prisma.vehicleModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleModels and only return the `id`
     * const vehicleModelWithIdOnly = await prisma.vehicleModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleModelUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleModelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleModel.
     * @param {VehicleModelUpsertArgs} args - Arguments to update or create a VehicleModel.
     * @example
     * // Update or create a VehicleModel
     * const vehicleModel = await prisma.vehicleModel.upsert({
     *   create: {
     *     // ... data to create a VehicleModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleModel we want to update
     *   }
     * })
     */
    upsert<T extends VehicleModelUpsertArgs>(args: SelectSubset<T, VehicleModelUpsertArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelCountArgs} args - Arguments to filter VehicleModels to count.
     * @example
     * // Count the number of VehicleModels
     * const count = await prisma.vehicleModel.count({
     *   where: {
     *     // ... the filter for the VehicleModels we want to count
     *   }
     * })
    **/
    count<T extends VehicleModelCountArgs>(
      args?: Subset<T, VehicleModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleModelAggregateArgs>(args: Subset<T, VehicleModelAggregateArgs>): Prisma.PrismaPromise<GetVehicleModelAggregateType<T>>

    /**
     * Group by VehicleModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleModelGroupByArgs['orderBy'] }
        : { orderBy?: VehicleModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleModel model
   */
  readonly fields: VehicleModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    make<T extends VehicleMakeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleMakeDefaultArgs<ExtArgs>>): Prisma__VehicleMakeClient<$Result.GetResult<Prisma.$VehicleMakePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generations<T extends VehicleModel$generationsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModel$generationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleModel model
   */
  interface VehicleModelFieldRefs {
    readonly id: FieldRef<"VehicleModel", 'String'>
    readonly makeId: FieldRef<"VehicleModel", 'String'>
    readonly name: FieldRef<"VehicleModel", 'String'>
    readonly slug: FieldRef<"VehicleModel", 'String'>
    readonly modelCode: FieldRef<"VehicleModel", 'String'>
    readonly startYear: FieldRef<"VehicleModel", 'Int'>
    readonly endYear: FieldRef<"VehicleModel", 'Int'>
    readonly description: FieldRef<"VehicleModel", 'String'>
    readonly metaTitle: FieldRef<"VehicleModel", 'String'>
    readonly metaDescription: FieldRef<"VehicleModel", 'String'>
    readonly metaKeywords: FieldRef<"VehicleModel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleModel findUnique
   */
  export type VehicleModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel findUniqueOrThrow
   */
  export type VehicleModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel findFirst
   */
  export type VehicleModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModels.
     */
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel findFirstOrThrow
   */
  export type VehicleModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModel to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModels.
     */
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel findMany
   */
  export type VehicleModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModels to fetch.
     */
    where?: VehicleModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModels to fetch.
     */
    orderBy?: VehicleModelOrderByWithRelationInput | VehicleModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleModels.
     */
    cursor?: VehicleModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModels.
     */
    skip?: number
    distinct?: VehicleModelScalarFieldEnum | VehicleModelScalarFieldEnum[]
  }

  /**
   * VehicleModel create
   */
  export type VehicleModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleModel.
     */
    data: XOR<VehicleModelCreateInput, VehicleModelUncheckedCreateInput>
  }

  /**
   * VehicleModel createMany
   */
  export type VehicleModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleModels.
     */
    data: VehicleModelCreateManyInput | VehicleModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleModel createManyAndReturn
   */
  export type VehicleModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleModels.
     */
    data: VehicleModelCreateManyInput | VehicleModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleModel update
   */
  export type VehicleModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleModel.
     */
    data: XOR<VehicleModelUpdateInput, VehicleModelUncheckedUpdateInput>
    /**
     * Choose, which VehicleModel to update.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel updateMany
   */
  export type VehicleModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleModels.
     */
    data: XOR<VehicleModelUpdateManyMutationInput, VehicleModelUncheckedUpdateManyInput>
    /**
     * Filter which VehicleModels to update
     */
    where?: VehicleModelWhereInput
    /**
     * Limit how many VehicleModels to update.
     */
    limit?: number
  }

  /**
   * VehicleModel updateManyAndReturn
   */
  export type VehicleModelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * The data used to update VehicleModels.
     */
    data: XOR<VehicleModelUpdateManyMutationInput, VehicleModelUncheckedUpdateManyInput>
    /**
     * Filter which VehicleModels to update
     */
    where?: VehicleModelWhereInput
    /**
     * Limit how many VehicleModels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleModel upsert
   */
  export type VehicleModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleModel to update in case it exists.
     */
    where: VehicleModelWhereUniqueInput
    /**
     * In case the VehicleModel found by the `where` argument doesn't exist, create a new VehicleModel with this data.
     */
    create: XOR<VehicleModelCreateInput, VehicleModelUncheckedCreateInput>
    /**
     * In case the VehicleModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleModelUpdateInput, VehicleModelUncheckedUpdateInput>
  }

  /**
   * VehicleModel delete
   */
  export type VehicleModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
    /**
     * Filter which VehicleModel to delete.
     */
    where: VehicleModelWhereUniqueInput
  }

  /**
   * VehicleModel deleteMany
   */
  export type VehicleModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModels to delete
     */
    where?: VehicleModelWhereInput
    /**
     * Limit how many VehicleModels to delete.
     */
    limit?: number
  }

  /**
   * VehicleModel.generations
   */
  export type VehicleModel$generationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    where?: VehicleGenerationWhereInput
    orderBy?: VehicleGenerationOrderByWithRelationInput | VehicleGenerationOrderByWithRelationInput[]
    cursor?: VehicleGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleGenerationScalarFieldEnum | VehicleGenerationScalarFieldEnum[]
  }

  /**
   * VehicleModel without action
   */
  export type VehicleModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModel
     */
    select?: VehicleModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModel
     */
    omit?: VehicleModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModelInclude<ExtArgs> | null
  }


  /**
   * Model VehicleGeneration
   */

  export type AggregateVehicleGeneration = {
    _count: VehicleGenerationCountAggregateOutputType | null
    _avg: VehicleGenerationAvgAggregateOutputType | null
    _sum: VehicleGenerationSumAggregateOutputType | null
    _min: VehicleGenerationMinAggregateOutputType | null
    _max: VehicleGenerationMaxAggregateOutputType | null
  }

  export type VehicleGenerationAvgAggregateOutputType = {
    startYear: number | null
    endYear: number | null
  }

  export type VehicleGenerationSumAggregateOutputType = {
    startYear: number | null
    endYear: number | null
  }

  export type VehicleGenerationMinAggregateOutputType = {
    id: string | null
    modelId: string | null
    name: string | null
    slug: string | null
    startYear: number | null
    endYear: number | null
    bodyType: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleGenerationMaxAggregateOutputType = {
    id: string | null
    modelId: string | null
    name: string | null
    slug: string | null
    startYear: number | null
    endYear: number | null
    bodyType: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
  }

  export type VehicleGenerationCountAggregateOutputType = {
    id: number
    modelId: number
    name: number
    slug: number
    startYear: number
    endYear: number
    bodyType: number
    description: number
    metaTitle: number
    metaDescription: number
    metaKeywords: number
    _all: number
  }


  export type VehicleGenerationAvgAggregateInputType = {
    startYear?: true
    endYear?: true
  }

  export type VehicleGenerationSumAggregateInputType = {
    startYear?: true
    endYear?: true
  }

  export type VehicleGenerationMinAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    slug?: true
    startYear?: true
    endYear?: true
    bodyType?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleGenerationMaxAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    slug?: true
    startYear?: true
    endYear?: true
    bodyType?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
  }

  export type VehicleGenerationCountAggregateInputType = {
    id?: true
    modelId?: true
    name?: true
    slug?: true
    startYear?: true
    endYear?: true
    bodyType?: true
    description?: true
    metaTitle?: true
    metaDescription?: true
    metaKeywords?: true
    _all?: true
  }

  export type VehicleGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleGeneration to aggregate.
     */
    where?: VehicleGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleGenerations to fetch.
     */
    orderBy?: VehicleGenerationOrderByWithRelationInput | VehicleGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleGenerations
    **/
    _count?: true | VehicleGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleGenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleGenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleGenerationMaxAggregateInputType
  }

  export type GetVehicleGenerationAggregateType<T extends VehicleGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleGeneration[P]>
      : GetScalarType<T[P], AggregateVehicleGeneration[P]>
  }




  export type VehicleGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleGenerationWhereInput
    orderBy?: VehicleGenerationOrderByWithAggregationInput | VehicleGenerationOrderByWithAggregationInput[]
    by: VehicleGenerationScalarFieldEnum[] | VehicleGenerationScalarFieldEnum
    having?: VehicleGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleGenerationCountAggregateInputType | true
    _avg?: VehicleGenerationAvgAggregateInputType
    _sum?: VehicleGenerationSumAggregateInputType
    _min?: VehicleGenerationMinAggregateInputType
    _max?: VehicleGenerationMaxAggregateInputType
  }

  export type VehicleGenerationGroupByOutputType = {
    id: string
    modelId: string
    name: string
    slug: string
    startYear: number
    endYear: number | null
    bodyType: string | null
    description: string | null
    metaTitle: string | null
    metaDescription: string | null
    metaKeywords: string | null
    _count: VehicleGenerationCountAggregateOutputType | null
    _avg: VehicleGenerationAvgAggregateOutputType | null
    _sum: VehicleGenerationSumAggregateOutputType | null
    _min: VehicleGenerationMinAggregateOutputType | null
    _max: VehicleGenerationMaxAggregateOutputType | null
  }

  type GetVehicleGenerationGroupByPayload<T extends VehicleGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGenerationGroupByOutputType[P]>
        }
      >
    >


  export type VehicleGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    name?: boolean
    slug?: boolean
    startYear?: boolean
    endYear?: boolean
    bodyType?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
    modifications?: boolean | VehicleGeneration$modificationsArgs<ExtArgs>
    _count?: boolean | VehicleGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleGeneration"]>

  export type VehicleGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    name?: boolean
    slug?: boolean
    startYear?: boolean
    endYear?: boolean
    bodyType?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleGeneration"]>

  export type VehicleGenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelId?: boolean
    name?: boolean
    slug?: boolean
    startYear?: boolean
    endYear?: boolean
    bodyType?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleGeneration"]>

  export type VehicleGenerationSelectScalar = {
    id?: boolean
    modelId?: boolean
    name?: boolean
    slug?: boolean
    startYear?: boolean
    endYear?: boolean
    bodyType?: boolean
    description?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
  }

  export type VehicleGenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelId" | "name" | "slug" | "startYear" | "endYear" | "bodyType" | "description" | "metaTitle" | "metaDescription" | "metaKeywords", ExtArgs["result"]["vehicleGeneration"]>
  export type VehicleGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
    modifications?: boolean | VehicleGeneration$modificationsArgs<ExtArgs>
    _count?: boolean | VehicleGenerationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }
  export type VehicleGenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | VehicleModelDefaultArgs<ExtArgs>
  }

  export type $VehicleGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleGeneration"
    objects: {
      model: Prisma.$VehicleModelPayload<ExtArgs>
      modifications: Prisma.$VehicleModificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelId: string
      name: string
      slug: string
      startYear: number
      endYear: number | null
      bodyType: string | null
      description: string | null
      metaTitle: string | null
      metaDescription: string | null
      metaKeywords: string | null
    }, ExtArgs["result"]["vehicleGeneration"]>
    composites: {}
  }

  type VehicleGenerationGetPayload<S extends boolean | null | undefined | VehicleGenerationDefaultArgs> = $Result.GetResult<Prisma.$VehicleGenerationPayload, S>

  type VehicleGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleGenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleGenerationCountAggregateInputType | true
    }

  export interface VehicleGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleGeneration'], meta: { name: 'VehicleGeneration' } }
    /**
     * Find zero or one VehicleGeneration that matches the filter.
     * @param {VehicleGenerationFindUniqueArgs} args - Arguments to find a VehicleGeneration
     * @example
     * // Get one VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleGenerationFindUniqueArgs>(args: SelectSubset<T, VehicleGenerationFindUniqueArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleGeneration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleGenerationFindUniqueOrThrowArgs} args - Arguments to find a VehicleGeneration
     * @example
     * // Get one VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationFindFirstArgs} args - Arguments to find a VehicleGeneration
     * @example
     * // Get one VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleGenerationFindFirstArgs>(args?: SelectSubset<T, VehicleGenerationFindFirstArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationFindFirstOrThrowArgs} args - Arguments to find a VehicleGeneration
     * @example
     * // Get one VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleGenerations
     * const vehicleGenerations = await prisma.vehicleGeneration.findMany()
     * 
     * // Get first 10 VehicleGenerations
     * const vehicleGenerations = await prisma.vehicleGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleGenerationWithIdOnly = await prisma.vehicleGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleGenerationFindManyArgs>(args?: SelectSubset<T, VehicleGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleGeneration.
     * @param {VehicleGenerationCreateArgs} args - Arguments to create a VehicleGeneration.
     * @example
     * // Create one VehicleGeneration
     * const VehicleGeneration = await prisma.vehicleGeneration.create({
     *   data: {
     *     // ... data to create a VehicleGeneration
     *   }
     * })
     * 
     */
    create<T extends VehicleGenerationCreateArgs>(args: SelectSubset<T, VehicleGenerationCreateArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleGenerations.
     * @param {VehicleGenerationCreateManyArgs} args - Arguments to create many VehicleGenerations.
     * @example
     * // Create many VehicleGenerations
     * const vehicleGeneration = await prisma.vehicleGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleGenerationCreateManyArgs>(args?: SelectSubset<T, VehicleGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleGenerations and returns the data saved in the database.
     * @param {VehicleGenerationCreateManyAndReturnArgs} args - Arguments to create many VehicleGenerations.
     * @example
     * // Create many VehicleGenerations
     * const vehicleGeneration = await prisma.vehicleGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleGenerations and only return the `id`
     * const vehicleGenerationWithIdOnly = await prisma.vehicleGeneration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleGeneration.
     * @param {VehicleGenerationDeleteArgs} args - Arguments to delete one VehicleGeneration.
     * @example
     * // Delete one VehicleGeneration
     * const VehicleGeneration = await prisma.vehicleGeneration.delete({
     *   where: {
     *     // ... filter to delete one VehicleGeneration
     *   }
     * })
     * 
     */
    delete<T extends VehicleGenerationDeleteArgs>(args: SelectSubset<T, VehicleGenerationDeleteArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleGeneration.
     * @param {VehicleGenerationUpdateArgs} args - Arguments to update one VehicleGeneration.
     * @example
     * // Update one VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleGenerationUpdateArgs>(args: SelectSubset<T, VehicleGenerationUpdateArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleGenerations.
     * @param {VehicleGenerationDeleteManyArgs} args - Arguments to filter VehicleGenerations to delete.
     * @example
     * // Delete a few VehicleGenerations
     * const { count } = await prisma.vehicleGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleGenerationDeleteManyArgs>(args?: SelectSubset<T, VehicleGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleGenerations
     * const vehicleGeneration = await prisma.vehicleGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleGenerationUpdateManyArgs>(args: SelectSubset<T, VehicleGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleGenerations and returns the data updated in the database.
     * @param {VehicleGenerationUpdateManyAndReturnArgs} args - Arguments to update many VehicleGenerations.
     * @example
     * // Update many VehicleGenerations
     * const vehicleGeneration = await prisma.vehicleGeneration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleGenerations and only return the `id`
     * const vehicleGenerationWithIdOnly = await prisma.vehicleGeneration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleGenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleGenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleGeneration.
     * @param {VehicleGenerationUpsertArgs} args - Arguments to update or create a VehicleGeneration.
     * @example
     * // Update or create a VehicleGeneration
     * const vehicleGeneration = await prisma.vehicleGeneration.upsert({
     *   create: {
     *     // ... data to create a VehicleGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleGeneration we want to update
     *   }
     * })
     */
    upsert<T extends VehicleGenerationUpsertArgs>(args: SelectSubset<T, VehicleGenerationUpsertArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationCountArgs} args - Arguments to filter VehicleGenerations to count.
     * @example
     * // Count the number of VehicleGenerations
     * const count = await prisma.vehicleGeneration.count({
     *   where: {
     *     // ... the filter for the VehicleGenerations we want to count
     *   }
     * })
    **/
    count<T extends VehicleGenerationCountArgs>(
      args?: Subset<T, VehicleGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleGenerationAggregateArgs>(args: Subset<T, VehicleGenerationAggregateArgs>): Prisma.PrismaPromise<GetVehicleGenerationAggregateType<T>>

    /**
     * Group by VehicleGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGenerationGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleGeneration model
   */
  readonly fields: VehicleGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends VehicleModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModelDefaultArgs<ExtArgs>>): Prisma__VehicleModelClient<$Result.GetResult<Prisma.$VehicleModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modifications<T extends VehicleGeneration$modificationsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleGeneration$modificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleGeneration model
   */
  interface VehicleGenerationFieldRefs {
    readonly id: FieldRef<"VehicleGeneration", 'String'>
    readonly modelId: FieldRef<"VehicleGeneration", 'String'>
    readonly name: FieldRef<"VehicleGeneration", 'String'>
    readonly slug: FieldRef<"VehicleGeneration", 'String'>
    readonly startYear: FieldRef<"VehicleGeneration", 'Int'>
    readonly endYear: FieldRef<"VehicleGeneration", 'Int'>
    readonly bodyType: FieldRef<"VehicleGeneration", 'String'>
    readonly description: FieldRef<"VehicleGeneration", 'String'>
    readonly metaTitle: FieldRef<"VehicleGeneration", 'String'>
    readonly metaDescription: FieldRef<"VehicleGeneration", 'String'>
    readonly metaKeywords: FieldRef<"VehicleGeneration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleGeneration findUnique
   */
  export type VehicleGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleGeneration to fetch.
     */
    where: VehicleGenerationWhereUniqueInput
  }

  /**
   * VehicleGeneration findUniqueOrThrow
   */
  export type VehicleGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleGeneration to fetch.
     */
    where: VehicleGenerationWhereUniqueInput
  }

  /**
   * VehicleGeneration findFirst
   */
  export type VehicleGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleGeneration to fetch.
     */
    where?: VehicleGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleGenerations to fetch.
     */
    orderBy?: VehicleGenerationOrderByWithRelationInput | VehicleGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleGenerations.
     */
    cursor?: VehicleGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleGenerations.
     */
    distinct?: VehicleGenerationScalarFieldEnum | VehicleGenerationScalarFieldEnum[]
  }

  /**
   * VehicleGeneration findFirstOrThrow
   */
  export type VehicleGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleGeneration to fetch.
     */
    where?: VehicleGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleGenerations to fetch.
     */
    orderBy?: VehicleGenerationOrderByWithRelationInput | VehicleGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleGenerations.
     */
    cursor?: VehicleGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleGenerations.
     */
    distinct?: VehicleGenerationScalarFieldEnum | VehicleGenerationScalarFieldEnum[]
  }

  /**
   * VehicleGeneration findMany
   */
  export type VehicleGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleGenerations to fetch.
     */
    where?: VehicleGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleGenerations to fetch.
     */
    orderBy?: VehicleGenerationOrderByWithRelationInput | VehicleGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleGenerations.
     */
    cursor?: VehicleGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleGenerations.
     */
    skip?: number
    distinct?: VehicleGenerationScalarFieldEnum | VehicleGenerationScalarFieldEnum[]
  }

  /**
   * VehicleGeneration create
   */
  export type VehicleGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleGeneration.
     */
    data: XOR<VehicleGenerationCreateInput, VehicleGenerationUncheckedCreateInput>
  }

  /**
   * VehicleGeneration createMany
   */
  export type VehicleGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleGenerations.
     */
    data: VehicleGenerationCreateManyInput | VehicleGenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleGeneration createManyAndReturn
   */
  export type VehicleGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleGenerations.
     */
    data: VehicleGenerationCreateManyInput | VehicleGenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleGeneration update
   */
  export type VehicleGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleGeneration.
     */
    data: XOR<VehicleGenerationUpdateInput, VehicleGenerationUncheckedUpdateInput>
    /**
     * Choose, which VehicleGeneration to update.
     */
    where: VehicleGenerationWhereUniqueInput
  }

  /**
   * VehicleGeneration updateMany
   */
  export type VehicleGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleGenerations.
     */
    data: XOR<VehicleGenerationUpdateManyMutationInput, VehicleGenerationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleGenerations to update
     */
    where?: VehicleGenerationWhereInput
    /**
     * Limit how many VehicleGenerations to update.
     */
    limit?: number
  }

  /**
   * VehicleGeneration updateManyAndReturn
   */
  export type VehicleGenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * The data used to update VehicleGenerations.
     */
    data: XOR<VehicleGenerationUpdateManyMutationInput, VehicleGenerationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleGenerations to update
     */
    where?: VehicleGenerationWhereInput
    /**
     * Limit how many VehicleGenerations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleGeneration upsert
   */
  export type VehicleGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleGeneration to update in case it exists.
     */
    where: VehicleGenerationWhereUniqueInput
    /**
     * In case the VehicleGeneration found by the `where` argument doesn't exist, create a new VehicleGeneration with this data.
     */
    create: XOR<VehicleGenerationCreateInput, VehicleGenerationUncheckedCreateInput>
    /**
     * In case the VehicleGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleGenerationUpdateInput, VehicleGenerationUncheckedUpdateInput>
  }

  /**
   * VehicleGeneration delete
   */
  export type VehicleGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
    /**
     * Filter which VehicleGeneration to delete.
     */
    where: VehicleGenerationWhereUniqueInput
  }

  /**
   * VehicleGeneration deleteMany
   */
  export type VehicleGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleGenerations to delete
     */
    where?: VehicleGenerationWhereInput
    /**
     * Limit how many VehicleGenerations to delete.
     */
    limit?: number
  }

  /**
   * VehicleGeneration.modifications
   */
  export type VehicleGeneration$modificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    where?: VehicleModificationWhereInput
    orderBy?: VehicleModificationOrderByWithRelationInput | VehicleModificationOrderByWithRelationInput[]
    cursor?: VehicleModificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleModificationScalarFieldEnum | VehicleModificationScalarFieldEnum[]
  }

  /**
   * VehicleGeneration without action
   */
  export type VehicleGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleGeneration
     */
    select?: VehicleGenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleGeneration
     */
    omit?: VehicleGenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleGenerationInclude<ExtArgs> | null
  }


  /**
   * Model VehicleModification
   */

  export type AggregateVehicleModification = {
    _count: VehicleModificationCountAggregateOutputType | null
    _avg: VehicleModificationAvgAggregateOutputType | null
    _sum: VehicleModificationSumAggregateOutputType | null
    _min: VehicleModificationMinAggregateOutputType | null
    _max: VehicleModificationMaxAggregateOutputType | null
  }

  export type VehicleModificationAvgAggregateOutputType = {
    powerHp: number | null
  }

  export type VehicleModificationSumAggregateOutputType = {
    powerHp: number | null
  }

  export type VehicleModificationMinAggregateOutputType = {
    id: string | null
    generationId: string | null
    name: string | null
    engineCode: string | null
    fuelType: string | null
    powerHp: number | null
    transmission: string | null
  }

  export type VehicleModificationMaxAggregateOutputType = {
    id: string | null
    generationId: string | null
    name: string | null
    engineCode: string | null
    fuelType: string | null
    powerHp: number | null
    transmission: string | null
  }

  export type VehicleModificationCountAggregateOutputType = {
    id: number
    generationId: number
    name: number
    engineCode: number
    fuelType: number
    powerHp: number
    transmission: number
    _all: number
  }


  export type VehicleModificationAvgAggregateInputType = {
    powerHp?: true
  }

  export type VehicleModificationSumAggregateInputType = {
    powerHp?: true
  }

  export type VehicleModificationMinAggregateInputType = {
    id?: true
    generationId?: true
    name?: true
    engineCode?: true
    fuelType?: true
    powerHp?: true
    transmission?: true
  }

  export type VehicleModificationMaxAggregateInputType = {
    id?: true
    generationId?: true
    name?: true
    engineCode?: true
    fuelType?: true
    powerHp?: true
    transmission?: true
  }

  export type VehicleModificationCountAggregateInputType = {
    id?: true
    generationId?: true
    name?: true
    engineCode?: true
    fuelType?: true
    powerHp?: true
    transmission?: true
    _all?: true
  }

  export type VehicleModificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModification to aggregate.
     */
    where?: VehicleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModifications to fetch.
     */
    orderBy?: VehicleModificationOrderByWithRelationInput | VehicleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleModifications
    **/
    _count?: true | VehicleModificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleModificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleModificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleModificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleModificationMaxAggregateInputType
  }

  export type GetVehicleModificationAggregateType<T extends VehicleModificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleModification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleModification[P]>
      : GetScalarType<T[P], AggregateVehicleModification[P]>
  }




  export type VehicleModificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleModificationWhereInput
    orderBy?: VehicleModificationOrderByWithAggregationInput | VehicleModificationOrderByWithAggregationInput[]
    by: VehicleModificationScalarFieldEnum[] | VehicleModificationScalarFieldEnum
    having?: VehicleModificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleModificationCountAggregateInputType | true
    _avg?: VehicleModificationAvgAggregateInputType
    _sum?: VehicleModificationSumAggregateInputType
    _min?: VehicleModificationMinAggregateInputType
    _max?: VehicleModificationMaxAggregateInputType
  }

  export type VehicleModificationGroupByOutputType = {
    id: string
    generationId: string
    name: string
    engineCode: string | null
    fuelType: string | null
    powerHp: number | null
    transmission: string | null
    _count: VehicleModificationCountAggregateOutputType | null
    _avg: VehicleModificationAvgAggregateOutputType | null
    _sum: VehicleModificationSumAggregateOutputType | null
    _min: VehicleModificationMinAggregateOutputType | null
    _max: VehicleModificationMaxAggregateOutputType | null
  }

  type GetVehicleModificationGroupByPayload<T extends VehicleModificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleModificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleModificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleModificationGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleModificationGroupByOutputType[P]>
        }
      >
    >


  export type VehicleModificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    generationId?: boolean
    name?: boolean
    engineCode?: boolean
    fuelType?: boolean
    powerHp?: boolean
    transmission?: boolean
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
    applications?: boolean | VehicleModification$applicationsArgs<ExtArgs>
    _count?: boolean | VehicleModificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModification"]>

  export type VehicleModificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    generationId?: boolean
    name?: boolean
    engineCode?: boolean
    fuelType?: boolean
    powerHp?: boolean
    transmission?: boolean
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModification"]>

  export type VehicleModificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    generationId?: boolean
    name?: boolean
    engineCode?: boolean
    fuelType?: boolean
    powerHp?: boolean
    transmission?: boolean
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleModification"]>

  export type VehicleModificationSelectScalar = {
    id?: boolean
    generationId?: boolean
    name?: boolean
    engineCode?: boolean
    fuelType?: boolean
    powerHp?: boolean
    transmission?: boolean
  }

  export type VehicleModificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "generationId" | "name" | "engineCode" | "fuelType" | "powerHp" | "transmission", ExtArgs["result"]["vehicleModification"]>
  export type VehicleModificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
    applications?: boolean | VehicleModification$applicationsArgs<ExtArgs>
    _count?: boolean | VehicleModificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleModificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
  }
  export type VehicleModificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | VehicleGenerationDefaultArgs<ExtArgs>
  }

  export type $VehicleModificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleModification"
    objects: {
      generation: Prisma.$VehicleGenerationPayload<ExtArgs>
      applications: Prisma.$VehicleApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      generationId: string
      name: string
      engineCode: string | null
      fuelType: string | null
      powerHp: number | null
      transmission: string | null
    }, ExtArgs["result"]["vehicleModification"]>
    composites: {}
  }

  type VehicleModificationGetPayload<S extends boolean | null | undefined | VehicleModificationDefaultArgs> = $Result.GetResult<Prisma.$VehicleModificationPayload, S>

  type VehicleModificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleModificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleModificationCountAggregateInputType | true
    }

  export interface VehicleModificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleModification'], meta: { name: 'VehicleModification' } }
    /**
     * Find zero or one VehicleModification that matches the filter.
     * @param {VehicleModificationFindUniqueArgs} args - Arguments to find a VehicleModification
     * @example
     * // Get one VehicleModification
     * const vehicleModification = await prisma.vehicleModification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleModificationFindUniqueArgs>(args: SelectSubset<T, VehicleModificationFindUniqueArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleModification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleModificationFindUniqueOrThrowArgs} args - Arguments to find a VehicleModification
     * @example
     * // Get one VehicleModification
     * const vehicleModification = await prisma.vehicleModification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleModificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleModificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleModification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationFindFirstArgs} args - Arguments to find a VehicleModification
     * @example
     * // Get one VehicleModification
     * const vehicleModification = await prisma.vehicleModification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleModificationFindFirstArgs>(args?: SelectSubset<T, VehicleModificationFindFirstArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleModification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationFindFirstOrThrowArgs} args - Arguments to find a VehicleModification
     * @example
     * // Get one VehicleModification
     * const vehicleModification = await prisma.vehicleModification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleModificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleModificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleModifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleModifications
     * const vehicleModifications = await prisma.vehicleModification.findMany()
     * 
     * // Get first 10 VehicleModifications
     * const vehicleModifications = await prisma.vehicleModification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleModificationWithIdOnly = await prisma.vehicleModification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleModificationFindManyArgs>(args?: SelectSubset<T, VehicleModificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleModification.
     * @param {VehicleModificationCreateArgs} args - Arguments to create a VehicleModification.
     * @example
     * // Create one VehicleModification
     * const VehicleModification = await prisma.vehicleModification.create({
     *   data: {
     *     // ... data to create a VehicleModification
     *   }
     * })
     * 
     */
    create<T extends VehicleModificationCreateArgs>(args: SelectSubset<T, VehicleModificationCreateArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleModifications.
     * @param {VehicleModificationCreateManyArgs} args - Arguments to create many VehicleModifications.
     * @example
     * // Create many VehicleModifications
     * const vehicleModification = await prisma.vehicleModification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleModificationCreateManyArgs>(args?: SelectSubset<T, VehicleModificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleModifications and returns the data saved in the database.
     * @param {VehicleModificationCreateManyAndReturnArgs} args - Arguments to create many VehicleModifications.
     * @example
     * // Create many VehicleModifications
     * const vehicleModification = await prisma.vehicleModification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleModifications and only return the `id`
     * const vehicleModificationWithIdOnly = await prisma.vehicleModification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleModificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleModificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleModification.
     * @param {VehicleModificationDeleteArgs} args - Arguments to delete one VehicleModification.
     * @example
     * // Delete one VehicleModification
     * const VehicleModification = await prisma.vehicleModification.delete({
     *   where: {
     *     // ... filter to delete one VehicleModification
     *   }
     * })
     * 
     */
    delete<T extends VehicleModificationDeleteArgs>(args: SelectSubset<T, VehicleModificationDeleteArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleModification.
     * @param {VehicleModificationUpdateArgs} args - Arguments to update one VehicleModification.
     * @example
     * // Update one VehicleModification
     * const vehicleModification = await prisma.vehicleModification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleModificationUpdateArgs>(args: SelectSubset<T, VehicleModificationUpdateArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleModifications.
     * @param {VehicleModificationDeleteManyArgs} args - Arguments to filter VehicleModifications to delete.
     * @example
     * // Delete a few VehicleModifications
     * const { count } = await prisma.vehicleModification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleModificationDeleteManyArgs>(args?: SelectSubset<T, VehicleModificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleModifications
     * const vehicleModification = await prisma.vehicleModification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleModificationUpdateManyArgs>(args: SelectSubset<T, VehicleModificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleModifications and returns the data updated in the database.
     * @param {VehicleModificationUpdateManyAndReturnArgs} args - Arguments to update many VehicleModifications.
     * @example
     * // Update many VehicleModifications
     * const vehicleModification = await prisma.vehicleModification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleModifications and only return the `id`
     * const vehicleModificationWithIdOnly = await prisma.vehicleModification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleModificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleModificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleModification.
     * @param {VehicleModificationUpsertArgs} args - Arguments to update or create a VehicleModification.
     * @example
     * // Update or create a VehicleModification
     * const vehicleModification = await prisma.vehicleModification.upsert({
     *   create: {
     *     // ... data to create a VehicleModification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleModification we want to update
     *   }
     * })
     */
    upsert<T extends VehicleModificationUpsertArgs>(args: SelectSubset<T, VehicleModificationUpsertArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationCountArgs} args - Arguments to filter VehicleModifications to count.
     * @example
     * // Count the number of VehicleModifications
     * const count = await prisma.vehicleModification.count({
     *   where: {
     *     // ... the filter for the VehicleModifications we want to count
     *   }
     * })
    **/
    count<T extends VehicleModificationCountArgs>(
      args?: Subset<T, VehicleModificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleModificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleModificationAggregateArgs>(args: Subset<T, VehicleModificationAggregateArgs>): Prisma.PrismaPromise<GetVehicleModificationAggregateType<T>>

    /**
     * Group by VehicleModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleModificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleModificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleModificationGroupByArgs['orderBy'] }
        : { orderBy?: VehicleModificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleModificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleModificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleModification model
   */
  readonly fields: VehicleModificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleModification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleModificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generation<T extends VehicleGenerationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleGenerationDefaultArgs<ExtArgs>>): Prisma__VehicleGenerationClient<$Result.GetResult<Prisma.$VehicleGenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    applications<T extends VehicleModification$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModification$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleModification model
   */
  interface VehicleModificationFieldRefs {
    readonly id: FieldRef<"VehicleModification", 'String'>
    readonly generationId: FieldRef<"VehicleModification", 'String'>
    readonly name: FieldRef<"VehicleModification", 'String'>
    readonly engineCode: FieldRef<"VehicleModification", 'String'>
    readonly fuelType: FieldRef<"VehicleModification", 'String'>
    readonly powerHp: FieldRef<"VehicleModification", 'Int'>
    readonly transmission: FieldRef<"VehicleModification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VehicleModification findUnique
   */
  export type VehicleModificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModification to fetch.
     */
    where: VehicleModificationWhereUniqueInput
  }

  /**
   * VehicleModification findUniqueOrThrow
   */
  export type VehicleModificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModification to fetch.
     */
    where: VehicleModificationWhereUniqueInput
  }

  /**
   * VehicleModification findFirst
   */
  export type VehicleModificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModification to fetch.
     */
    where?: VehicleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModifications to fetch.
     */
    orderBy?: VehicleModificationOrderByWithRelationInput | VehicleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModifications.
     */
    cursor?: VehicleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModifications.
     */
    distinct?: VehicleModificationScalarFieldEnum | VehicleModificationScalarFieldEnum[]
  }

  /**
   * VehicleModification findFirstOrThrow
   */
  export type VehicleModificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModification to fetch.
     */
    where?: VehicleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModifications to fetch.
     */
    orderBy?: VehicleModificationOrderByWithRelationInput | VehicleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleModifications.
     */
    cursor?: VehicleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleModifications.
     */
    distinct?: VehicleModificationScalarFieldEnum | VehicleModificationScalarFieldEnum[]
  }

  /**
   * VehicleModification findMany
   */
  export type VehicleModificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleModifications to fetch.
     */
    where?: VehicleModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleModifications to fetch.
     */
    orderBy?: VehicleModificationOrderByWithRelationInput | VehicleModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleModifications.
     */
    cursor?: VehicleModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleModifications.
     */
    skip?: number
    distinct?: VehicleModificationScalarFieldEnum | VehicleModificationScalarFieldEnum[]
  }

  /**
   * VehicleModification create
   */
  export type VehicleModificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleModification.
     */
    data: XOR<VehicleModificationCreateInput, VehicleModificationUncheckedCreateInput>
  }

  /**
   * VehicleModification createMany
   */
  export type VehicleModificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleModifications.
     */
    data: VehicleModificationCreateManyInput | VehicleModificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleModification createManyAndReturn
   */
  export type VehicleModificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleModifications.
     */
    data: VehicleModificationCreateManyInput | VehicleModificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleModification update
   */
  export type VehicleModificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleModification.
     */
    data: XOR<VehicleModificationUpdateInput, VehicleModificationUncheckedUpdateInput>
    /**
     * Choose, which VehicleModification to update.
     */
    where: VehicleModificationWhereUniqueInput
  }

  /**
   * VehicleModification updateMany
   */
  export type VehicleModificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleModifications.
     */
    data: XOR<VehicleModificationUpdateManyMutationInput, VehicleModificationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleModifications to update
     */
    where?: VehicleModificationWhereInput
    /**
     * Limit how many VehicleModifications to update.
     */
    limit?: number
  }

  /**
   * VehicleModification updateManyAndReturn
   */
  export type VehicleModificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * The data used to update VehicleModifications.
     */
    data: XOR<VehicleModificationUpdateManyMutationInput, VehicleModificationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleModifications to update
     */
    where?: VehicleModificationWhereInput
    /**
     * Limit how many VehicleModifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleModification upsert
   */
  export type VehicleModificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleModification to update in case it exists.
     */
    where: VehicleModificationWhereUniqueInput
    /**
     * In case the VehicleModification found by the `where` argument doesn't exist, create a new VehicleModification with this data.
     */
    create: XOR<VehicleModificationCreateInput, VehicleModificationUncheckedCreateInput>
    /**
     * In case the VehicleModification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleModificationUpdateInput, VehicleModificationUncheckedUpdateInput>
  }

  /**
   * VehicleModification delete
   */
  export type VehicleModificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
    /**
     * Filter which VehicleModification to delete.
     */
    where: VehicleModificationWhereUniqueInput
  }

  /**
   * VehicleModification deleteMany
   */
  export type VehicleModificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleModifications to delete
     */
    where?: VehicleModificationWhereInput
    /**
     * Limit how many VehicleModifications to delete.
     */
    limit?: number
  }

  /**
   * VehicleModification.applications
   */
  export type VehicleModification$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    where?: VehicleApplicationWhereInput
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    cursor?: VehicleApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleApplicationScalarFieldEnum | VehicleApplicationScalarFieldEnum[]
  }

  /**
   * VehicleModification without action
   */
  export type VehicleModificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleModification
     */
    select?: VehicleModificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleModification
     */
    omit?: VehicleModificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleModificationInclude<ExtArgs> | null
  }


  /**
   * Model VehicleApplication
   */

  export type AggregateVehicleApplication = {
    _count: VehicleApplicationCountAggregateOutputType | null
    _min: VehicleApplicationMinAggregateOutputType | null
    _max: VehicleApplicationMaxAggregateOutputType | null
  }

  export type VehicleApplicationMinAggregateOutputType = {
    id: string | null
    productId: string | null
    modificationId: string | null
    kTypeId: string | null
    notes: string | null
    isVerified: boolean | null
  }

  export type VehicleApplicationMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    modificationId: string | null
    kTypeId: string | null
    notes: string | null
    isVerified: boolean | null
  }

  export type VehicleApplicationCountAggregateOutputType = {
    id: number
    productId: number
    modificationId: number
    kTypeId: number
    notes: number
    isVerified: number
    _all: number
  }


  export type VehicleApplicationMinAggregateInputType = {
    id?: true
    productId?: true
    modificationId?: true
    kTypeId?: true
    notes?: true
    isVerified?: true
  }

  export type VehicleApplicationMaxAggregateInputType = {
    id?: true
    productId?: true
    modificationId?: true
    kTypeId?: true
    notes?: true
    isVerified?: true
  }

  export type VehicleApplicationCountAggregateInputType = {
    id?: true
    productId?: true
    modificationId?: true
    kTypeId?: true
    notes?: true
    isVerified?: true
    _all?: true
  }

  export type VehicleApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleApplication to aggregate.
     */
    where?: VehicleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleApplications to fetch.
     */
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleApplications
    **/
    _count?: true | VehicleApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleApplicationMaxAggregateInputType
  }

  export type GetVehicleApplicationAggregateType<T extends VehicleApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleApplication[P]>
      : GetScalarType<T[P], AggregateVehicleApplication[P]>
  }




  export type VehicleApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleApplicationWhereInput
    orderBy?: VehicleApplicationOrderByWithAggregationInput | VehicleApplicationOrderByWithAggregationInput[]
    by: VehicleApplicationScalarFieldEnum[] | VehicleApplicationScalarFieldEnum
    having?: VehicleApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleApplicationCountAggregateInputType | true
    _min?: VehicleApplicationMinAggregateInputType
    _max?: VehicleApplicationMaxAggregateInputType
  }

  export type VehicleApplicationGroupByOutputType = {
    id: string
    productId: string
    modificationId: string
    kTypeId: string | null
    notes: string | null
    isVerified: boolean
    _count: VehicleApplicationCountAggregateOutputType | null
    _min: VehicleApplicationMinAggregateOutputType | null
    _max: VehicleApplicationMaxAggregateOutputType | null
  }

  type GetVehicleApplicationGroupByPayload<T extends VehicleApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleApplicationGroupByOutputType[P]>
        }
      >
    >


  export type VehicleApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    modificationId?: boolean
    kTypeId?: boolean
    notes?: boolean
    isVerified?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleApplication"]>

  export type VehicleApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    modificationId?: boolean
    kTypeId?: boolean
    notes?: boolean
    isVerified?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleApplication"]>

  export type VehicleApplicationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    modificationId?: boolean
    kTypeId?: boolean
    notes?: boolean
    isVerified?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleApplication"]>

  export type VehicleApplicationSelectScalar = {
    id?: boolean
    productId?: boolean
    modificationId?: boolean
    kTypeId?: boolean
    notes?: boolean
    isVerified?: boolean
  }

  export type VehicleApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "modificationId" | "kTypeId" | "notes" | "isVerified", ExtArgs["result"]["vehicleApplication"]>
  export type VehicleApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }
  export type VehicleApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }
  export type VehicleApplicationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    modification?: boolean | VehicleModificationDefaultArgs<ExtArgs>
  }

  export type $VehicleApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleApplication"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      modification: Prisma.$VehicleModificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      modificationId: string
      kTypeId: string | null
      notes: string | null
      isVerified: boolean
    }, ExtArgs["result"]["vehicleApplication"]>
    composites: {}
  }

  type VehicleApplicationGetPayload<S extends boolean | null | undefined | VehicleApplicationDefaultArgs> = $Result.GetResult<Prisma.$VehicleApplicationPayload, S>

  type VehicleApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleApplicationCountAggregateInputType | true
    }

  export interface VehicleApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleApplication'], meta: { name: 'VehicleApplication' } }
    /**
     * Find zero or one VehicleApplication that matches the filter.
     * @param {VehicleApplicationFindUniqueArgs} args - Arguments to find a VehicleApplication
     * @example
     * // Get one VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleApplicationFindUniqueArgs>(args: SelectSubset<T, VehicleApplicationFindUniqueArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VehicleApplication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleApplicationFindUniqueOrThrowArgs} args - Arguments to find a VehicleApplication
     * @example
     * // Get one VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationFindFirstArgs} args - Arguments to find a VehicleApplication
     * @example
     * // Get one VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleApplicationFindFirstArgs>(args?: SelectSubset<T, VehicleApplicationFindFirstArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VehicleApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationFindFirstOrThrowArgs} args - Arguments to find a VehicleApplication
     * @example
     * // Get one VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VehicleApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleApplications
     * const vehicleApplications = await prisma.vehicleApplication.findMany()
     * 
     * // Get first 10 VehicleApplications
     * const vehicleApplications = await prisma.vehicleApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleApplicationWithIdOnly = await prisma.vehicleApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleApplicationFindManyArgs>(args?: SelectSubset<T, VehicleApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VehicleApplication.
     * @param {VehicleApplicationCreateArgs} args - Arguments to create a VehicleApplication.
     * @example
     * // Create one VehicleApplication
     * const VehicleApplication = await prisma.vehicleApplication.create({
     *   data: {
     *     // ... data to create a VehicleApplication
     *   }
     * })
     * 
     */
    create<T extends VehicleApplicationCreateArgs>(args: SelectSubset<T, VehicleApplicationCreateArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VehicleApplications.
     * @param {VehicleApplicationCreateManyArgs} args - Arguments to create many VehicleApplications.
     * @example
     * // Create many VehicleApplications
     * const vehicleApplication = await prisma.vehicleApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleApplicationCreateManyArgs>(args?: SelectSubset<T, VehicleApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VehicleApplications and returns the data saved in the database.
     * @param {VehicleApplicationCreateManyAndReturnArgs} args - Arguments to create many VehicleApplications.
     * @example
     * // Create many VehicleApplications
     * const vehicleApplication = await prisma.vehicleApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VehicleApplications and only return the `id`
     * const vehicleApplicationWithIdOnly = await prisma.vehicleApplication.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VehicleApplication.
     * @param {VehicleApplicationDeleteArgs} args - Arguments to delete one VehicleApplication.
     * @example
     * // Delete one VehicleApplication
     * const VehicleApplication = await prisma.vehicleApplication.delete({
     *   where: {
     *     // ... filter to delete one VehicleApplication
     *   }
     * })
     * 
     */
    delete<T extends VehicleApplicationDeleteArgs>(args: SelectSubset<T, VehicleApplicationDeleteArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VehicleApplication.
     * @param {VehicleApplicationUpdateArgs} args - Arguments to update one VehicleApplication.
     * @example
     * // Update one VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleApplicationUpdateArgs>(args: SelectSubset<T, VehicleApplicationUpdateArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VehicleApplications.
     * @param {VehicleApplicationDeleteManyArgs} args - Arguments to filter VehicleApplications to delete.
     * @example
     * // Delete a few VehicleApplications
     * const { count } = await prisma.vehicleApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleApplicationDeleteManyArgs>(args?: SelectSubset<T, VehicleApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleApplications
     * const vehicleApplication = await prisma.vehicleApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleApplicationUpdateManyArgs>(args: SelectSubset<T, VehicleApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleApplications and returns the data updated in the database.
     * @param {VehicleApplicationUpdateManyAndReturnArgs} args - Arguments to update many VehicleApplications.
     * @example
     * // Update many VehicleApplications
     * const vehicleApplication = await prisma.vehicleApplication.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VehicleApplications and only return the `id`
     * const vehicleApplicationWithIdOnly = await prisma.vehicleApplication.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleApplicationUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleApplicationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VehicleApplication.
     * @param {VehicleApplicationUpsertArgs} args - Arguments to update or create a VehicleApplication.
     * @example
     * // Update or create a VehicleApplication
     * const vehicleApplication = await prisma.vehicleApplication.upsert({
     *   create: {
     *     // ... data to create a VehicleApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleApplication we want to update
     *   }
     * })
     */
    upsert<T extends VehicleApplicationUpsertArgs>(args: SelectSubset<T, VehicleApplicationUpsertArgs<ExtArgs>>): Prisma__VehicleApplicationClient<$Result.GetResult<Prisma.$VehicleApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VehicleApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationCountArgs} args - Arguments to filter VehicleApplications to count.
     * @example
     * // Count the number of VehicleApplications
     * const count = await prisma.vehicleApplication.count({
     *   where: {
     *     // ... the filter for the VehicleApplications we want to count
     *   }
     * })
    **/
    count<T extends VehicleApplicationCountArgs>(
      args?: Subset<T, VehicleApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleApplicationAggregateArgs>(args: Subset<T, VehicleApplicationAggregateArgs>): Prisma.PrismaPromise<GetVehicleApplicationAggregateType<T>>

    /**
     * Group by VehicleApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleApplicationGroupByArgs['orderBy'] }
        : { orderBy?: VehicleApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleApplication model
   */
  readonly fields: VehicleApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    modification<T extends VehicleModificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleModificationDefaultArgs<ExtArgs>>): Prisma__VehicleModificationClient<$Result.GetResult<Prisma.$VehicleModificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleApplication model
   */
  interface VehicleApplicationFieldRefs {
    readonly id: FieldRef<"VehicleApplication", 'String'>
    readonly productId: FieldRef<"VehicleApplication", 'String'>
    readonly modificationId: FieldRef<"VehicleApplication", 'String'>
    readonly kTypeId: FieldRef<"VehicleApplication", 'String'>
    readonly notes: FieldRef<"VehicleApplication", 'String'>
    readonly isVerified: FieldRef<"VehicleApplication", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VehicleApplication findUnique
   */
  export type VehicleApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleApplication to fetch.
     */
    where: VehicleApplicationWhereUniqueInput
  }

  /**
   * VehicleApplication findUniqueOrThrow
   */
  export type VehicleApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleApplication to fetch.
     */
    where: VehicleApplicationWhereUniqueInput
  }

  /**
   * VehicleApplication findFirst
   */
  export type VehicleApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleApplication to fetch.
     */
    where?: VehicleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleApplications to fetch.
     */
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleApplications.
     */
    cursor?: VehicleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleApplications.
     */
    distinct?: VehicleApplicationScalarFieldEnum | VehicleApplicationScalarFieldEnum[]
  }

  /**
   * VehicleApplication findFirstOrThrow
   */
  export type VehicleApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleApplication to fetch.
     */
    where?: VehicleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleApplications to fetch.
     */
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleApplications.
     */
    cursor?: VehicleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleApplications.
     */
    distinct?: VehicleApplicationScalarFieldEnum | VehicleApplicationScalarFieldEnum[]
  }

  /**
   * VehicleApplication findMany
   */
  export type VehicleApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter, which VehicleApplications to fetch.
     */
    where?: VehicleApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleApplications to fetch.
     */
    orderBy?: VehicleApplicationOrderByWithRelationInput | VehicleApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleApplications.
     */
    cursor?: VehicleApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleApplications.
     */
    skip?: number
    distinct?: VehicleApplicationScalarFieldEnum | VehicleApplicationScalarFieldEnum[]
  }

  /**
   * VehicleApplication create
   */
  export type VehicleApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleApplication.
     */
    data: XOR<VehicleApplicationCreateInput, VehicleApplicationUncheckedCreateInput>
  }

  /**
   * VehicleApplication createMany
   */
  export type VehicleApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleApplications.
     */
    data: VehicleApplicationCreateManyInput | VehicleApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleApplication createManyAndReturn
   */
  export type VehicleApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * The data used to create many VehicleApplications.
     */
    data: VehicleApplicationCreateManyInput | VehicleApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleApplication update
   */
  export type VehicleApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleApplication.
     */
    data: XOR<VehicleApplicationUpdateInput, VehicleApplicationUncheckedUpdateInput>
    /**
     * Choose, which VehicleApplication to update.
     */
    where: VehicleApplicationWhereUniqueInput
  }

  /**
   * VehicleApplication updateMany
   */
  export type VehicleApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleApplications.
     */
    data: XOR<VehicleApplicationUpdateManyMutationInput, VehicleApplicationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleApplications to update
     */
    where?: VehicleApplicationWhereInput
    /**
     * Limit how many VehicleApplications to update.
     */
    limit?: number
  }

  /**
   * VehicleApplication updateManyAndReturn
   */
  export type VehicleApplicationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * The data used to update VehicleApplications.
     */
    data: XOR<VehicleApplicationUpdateManyMutationInput, VehicleApplicationUncheckedUpdateManyInput>
    /**
     * Filter which VehicleApplications to update
     */
    where?: VehicleApplicationWhereInput
    /**
     * Limit how many VehicleApplications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VehicleApplication upsert
   */
  export type VehicleApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleApplication to update in case it exists.
     */
    where: VehicleApplicationWhereUniqueInput
    /**
     * In case the VehicleApplication found by the `where` argument doesn't exist, create a new VehicleApplication with this data.
     */
    create: XOR<VehicleApplicationCreateInput, VehicleApplicationUncheckedCreateInput>
    /**
     * In case the VehicleApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleApplicationUpdateInput, VehicleApplicationUncheckedUpdateInput>
  }

  /**
   * VehicleApplication delete
   */
  export type VehicleApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
    /**
     * Filter which VehicleApplication to delete.
     */
    where: VehicleApplicationWhereUniqueInput
  }

  /**
   * VehicleApplication deleteMany
   */
  export type VehicleApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleApplications to delete
     */
    where?: VehicleApplicationWhereInput
    /**
     * Limit how many VehicleApplications to delete.
     */
    limit?: number
  }

  /**
   * VehicleApplication without action
   */
  export type VehicleApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleApplication
     */
    select?: VehicleApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VehicleApplication
     */
    omit?: VehicleApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleApplicationInclude<ExtArgs> | null
  }


  /**
   * Model CrossReference
   */

  export type AggregateCrossReference = {
    _count: CrossReferenceCountAggregateOutputType | null
    _avg: CrossReferenceAvgAggregateOutputType | null
    _sum: CrossReferenceSumAggregateOutputType | null
    _min: CrossReferenceMinAggregateOutputType | null
    _max: CrossReferenceMaxAggregateOutputType | null
  }

  export type CrossReferenceAvgAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type CrossReferenceSumAggregateOutputType = {
    confidenceScore: Decimal | null
  }

  export type CrossReferenceMinAggregateOutputType = {
    id: string | null
    productId: string | null
    crossPartNumber: string | null
    crossBrandId: string | null
    crossType: $Enums.CrossType | null
    confidenceScore: Decimal | null
    verifiedByExpert: boolean | null
  }

  export type CrossReferenceMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    crossPartNumber: string | null
    crossBrandId: string | null
    crossType: $Enums.CrossType | null
    confidenceScore: Decimal | null
    verifiedByExpert: boolean | null
  }

  export type CrossReferenceCountAggregateOutputType = {
    id: number
    productId: number
    crossPartNumber: number
    crossBrandId: number
    crossType: number
    confidenceScore: number
    verifiedByExpert: number
    _all: number
  }


  export type CrossReferenceAvgAggregateInputType = {
    confidenceScore?: true
  }

  export type CrossReferenceSumAggregateInputType = {
    confidenceScore?: true
  }

  export type CrossReferenceMinAggregateInputType = {
    id?: true
    productId?: true
    crossPartNumber?: true
    crossBrandId?: true
    crossType?: true
    confidenceScore?: true
    verifiedByExpert?: true
  }

  export type CrossReferenceMaxAggregateInputType = {
    id?: true
    productId?: true
    crossPartNumber?: true
    crossBrandId?: true
    crossType?: true
    confidenceScore?: true
    verifiedByExpert?: true
  }

  export type CrossReferenceCountAggregateInputType = {
    id?: true
    productId?: true
    crossPartNumber?: true
    crossBrandId?: true
    crossType?: true
    confidenceScore?: true
    verifiedByExpert?: true
    _all?: true
  }

  export type CrossReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrossReference to aggregate.
     */
    where?: CrossReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossReferences to fetch.
     */
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrossReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CrossReferences
    **/
    _count?: true | CrossReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CrossReferenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CrossReferenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrossReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrossReferenceMaxAggregateInputType
  }

  export type GetCrossReferenceAggregateType<T extends CrossReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateCrossReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrossReference[P]>
      : GetScalarType<T[P], AggregateCrossReference[P]>
  }




  export type CrossReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrossReferenceWhereInput
    orderBy?: CrossReferenceOrderByWithAggregationInput | CrossReferenceOrderByWithAggregationInput[]
    by: CrossReferenceScalarFieldEnum[] | CrossReferenceScalarFieldEnum
    having?: CrossReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrossReferenceCountAggregateInputType | true
    _avg?: CrossReferenceAvgAggregateInputType
    _sum?: CrossReferenceSumAggregateInputType
    _min?: CrossReferenceMinAggregateInputType
    _max?: CrossReferenceMaxAggregateInputType
  }

  export type CrossReferenceGroupByOutputType = {
    id: string
    productId: string
    crossPartNumber: string
    crossBrandId: string
    crossType: $Enums.CrossType
    confidenceScore: Decimal
    verifiedByExpert: boolean
    _count: CrossReferenceCountAggregateOutputType | null
    _avg: CrossReferenceAvgAggregateOutputType | null
    _sum: CrossReferenceSumAggregateOutputType | null
    _min: CrossReferenceMinAggregateOutputType | null
    _max: CrossReferenceMaxAggregateOutputType | null
  }

  type GetCrossReferenceGroupByPayload<T extends CrossReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrossReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrossReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrossReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], CrossReferenceGroupByOutputType[P]>
        }
      >
    >


  export type CrossReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    crossPartNumber?: boolean
    crossBrandId?: boolean
    crossType?: boolean
    confidenceScore?: boolean
    verifiedByExpert?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crossReference"]>

  export type CrossReferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    crossPartNumber?: boolean
    crossBrandId?: boolean
    crossType?: boolean
    confidenceScore?: boolean
    verifiedByExpert?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crossReference"]>

  export type CrossReferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    crossPartNumber?: boolean
    crossBrandId?: boolean
    crossType?: boolean
    confidenceScore?: boolean
    verifiedByExpert?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crossReference"]>

  export type CrossReferenceSelectScalar = {
    id?: boolean
    productId?: boolean
    crossPartNumber?: boolean
    crossBrandId?: boolean
    crossType?: boolean
    confidenceScore?: boolean
    verifiedByExpert?: boolean
  }

  export type CrossReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "crossPartNumber" | "crossBrandId" | "crossType" | "confidenceScore" | "verifiedByExpert", ExtArgs["result"]["crossReference"]>
  export type CrossReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type CrossReferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type CrossReferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    crossBrand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $CrossReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CrossReference"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      crossBrand: Prisma.$BrandPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      crossPartNumber: string
      crossBrandId: string
      crossType: $Enums.CrossType
      confidenceScore: Prisma.Decimal
      verifiedByExpert: boolean
    }, ExtArgs["result"]["crossReference"]>
    composites: {}
  }

  type CrossReferenceGetPayload<S extends boolean | null | undefined | CrossReferenceDefaultArgs> = $Result.GetResult<Prisma.$CrossReferencePayload, S>

  type CrossReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrossReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrossReferenceCountAggregateInputType | true
    }

  export interface CrossReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CrossReference'], meta: { name: 'CrossReference' } }
    /**
     * Find zero or one CrossReference that matches the filter.
     * @param {CrossReferenceFindUniqueArgs} args - Arguments to find a CrossReference
     * @example
     * // Get one CrossReference
     * const crossReference = await prisma.crossReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrossReferenceFindUniqueArgs>(args: SelectSubset<T, CrossReferenceFindUniqueArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CrossReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrossReferenceFindUniqueOrThrowArgs} args - Arguments to find a CrossReference
     * @example
     * // Get one CrossReference
     * const crossReference = await prisma.crossReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrossReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, CrossReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrossReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceFindFirstArgs} args - Arguments to find a CrossReference
     * @example
     * // Get one CrossReference
     * const crossReference = await prisma.crossReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrossReferenceFindFirstArgs>(args?: SelectSubset<T, CrossReferenceFindFirstArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CrossReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceFindFirstOrThrowArgs} args - Arguments to find a CrossReference
     * @example
     * // Get one CrossReference
     * const crossReference = await prisma.crossReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrossReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, CrossReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CrossReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CrossReferences
     * const crossReferences = await prisma.crossReference.findMany()
     * 
     * // Get first 10 CrossReferences
     * const crossReferences = await prisma.crossReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crossReferenceWithIdOnly = await prisma.crossReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrossReferenceFindManyArgs>(args?: SelectSubset<T, CrossReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CrossReference.
     * @param {CrossReferenceCreateArgs} args - Arguments to create a CrossReference.
     * @example
     * // Create one CrossReference
     * const CrossReference = await prisma.crossReference.create({
     *   data: {
     *     // ... data to create a CrossReference
     *   }
     * })
     * 
     */
    create<T extends CrossReferenceCreateArgs>(args: SelectSubset<T, CrossReferenceCreateArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CrossReferences.
     * @param {CrossReferenceCreateManyArgs} args - Arguments to create many CrossReferences.
     * @example
     * // Create many CrossReferences
     * const crossReference = await prisma.crossReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrossReferenceCreateManyArgs>(args?: SelectSubset<T, CrossReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CrossReferences and returns the data saved in the database.
     * @param {CrossReferenceCreateManyAndReturnArgs} args - Arguments to create many CrossReferences.
     * @example
     * // Create many CrossReferences
     * const crossReference = await prisma.crossReference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CrossReferences and only return the `id`
     * const crossReferenceWithIdOnly = await prisma.crossReference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrossReferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, CrossReferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CrossReference.
     * @param {CrossReferenceDeleteArgs} args - Arguments to delete one CrossReference.
     * @example
     * // Delete one CrossReference
     * const CrossReference = await prisma.crossReference.delete({
     *   where: {
     *     // ... filter to delete one CrossReference
     *   }
     * })
     * 
     */
    delete<T extends CrossReferenceDeleteArgs>(args: SelectSubset<T, CrossReferenceDeleteArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CrossReference.
     * @param {CrossReferenceUpdateArgs} args - Arguments to update one CrossReference.
     * @example
     * // Update one CrossReference
     * const crossReference = await prisma.crossReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrossReferenceUpdateArgs>(args: SelectSubset<T, CrossReferenceUpdateArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CrossReferences.
     * @param {CrossReferenceDeleteManyArgs} args - Arguments to filter CrossReferences to delete.
     * @example
     * // Delete a few CrossReferences
     * const { count } = await prisma.crossReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrossReferenceDeleteManyArgs>(args?: SelectSubset<T, CrossReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrossReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CrossReferences
     * const crossReference = await prisma.crossReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrossReferenceUpdateManyArgs>(args: SelectSubset<T, CrossReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CrossReferences and returns the data updated in the database.
     * @param {CrossReferenceUpdateManyAndReturnArgs} args - Arguments to update many CrossReferences.
     * @example
     * // Update many CrossReferences
     * const crossReference = await prisma.crossReference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CrossReferences and only return the `id`
     * const crossReferenceWithIdOnly = await prisma.crossReference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrossReferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, CrossReferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CrossReference.
     * @param {CrossReferenceUpsertArgs} args - Arguments to update or create a CrossReference.
     * @example
     * // Update or create a CrossReference
     * const crossReference = await prisma.crossReference.upsert({
     *   create: {
     *     // ... data to create a CrossReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CrossReference we want to update
     *   }
     * })
     */
    upsert<T extends CrossReferenceUpsertArgs>(args: SelectSubset<T, CrossReferenceUpsertArgs<ExtArgs>>): Prisma__CrossReferenceClient<$Result.GetResult<Prisma.$CrossReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CrossReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceCountArgs} args - Arguments to filter CrossReferences to count.
     * @example
     * // Count the number of CrossReferences
     * const count = await prisma.crossReference.count({
     *   where: {
     *     // ... the filter for the CrossReferences we want to count
     *   }
     * })
    **/
    count<T extends CrossReferenceCountArgs>(
      args?: Subset<T, CrossReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrossReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CrossReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrossReferenceAggregateArgs>(args: Subset<T, CrossReferenceAggregateArgs>): Prisma.PrismaPromise<GetCrossReferenceAggregateType<T>>

    /**
     * Group by CrossReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrossReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrossReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrossReferenceGroupByArgs['orderBy'] }
        : { orderBy?: CrossReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrossReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrossReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CrossReference model
   */
  readonly fields: CrossReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CrossReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrossReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    crossBrand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CrossReference model
   */
  interface CrossReferenceFieldRefs {
    readonly id: FieldRef<"CrossReference", 'String'>
    readonly productId: FieldRef<"CrossReference", 'String'>
    readonly crossPartNumber: FieldRef<"CrossReference", 'String'>
    readonly crossBrandId: FieldRef<"CrossReference", 'String'>
    readonly crossType: FieldRef<"CrossReference", 'CrossType'>
    readonly confidenceScore: FieldRef<"CrossReference", 'Decimal'>
    readonly verifiedByExpert: FieldRef<"CrossReference", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * CrossReference findUnique
   */
  export type CrossReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter, which CrossReference to fetch.
     */
    where: CrossReferenceWhereUniqueInput
  }

  /**
   * CrossReference findUniqueOrThrow
   */
  export type CrossReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter, which CrossReference to fetch.
     */
    where: CrossReferenceWhereUniqueInput
  }

  /**
   * CrossReference findFirst
   */
  export type CrossReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter, which CrossReference to fetch.
     */
    where?: CrossReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossReferences to fetch.
     */
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrossReferences.
     */
    cursor?: CrossReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrossReferences.
     */
    distinct?: CrossReferenceScalarFieldEnum | CrossReferenceScalarFieldEnum[]
  }

  /**
   * CrossReference findFirstOrThrow
   */
  export type CrossReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter, which CrossReference to fetch.
     */
    where?: CrossReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossReferences to fetch.
     */
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CrossReferences.
     */
    cursor?: CrossReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CrossReferences.
     */
    distinct?: CrossReferenceScalarFieldEnum | CrossReferenceScalarFieldEnum[]
  }

  /**
   * CrossReference findMany
   */
  export type CrossReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter, which CrossReferences to fetch.
     */
    where?: CrossReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CrossReferences to fetch.
     */
    orderBy?: CrossReferenceOrderByWithRelationInput | CrossReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CrossReferences.
     */
    cursor?: CrossReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CrossReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CrossReferences.
     */
    skip?: number
    distinct?: CrossReferenceScalarFieldEnum | CrossReferenceScalarFieldEnum[]
  }

  /**
   * CrossReference create
   */
  export type CrossReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a CrossReference.
     */
    data: XOR<CrossReferenceCreateInput, CrossReferenceUncheckedCreateInput>
  }

  /**
   * CrossReference createMany
   */
  export type CrossReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CrossReferences.
     */
    data: CrossReferenceCreateManyInput | CrossReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CrossReference createManyAndReturn
   */
  export type CrossReferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * The data used to create many CrossReferences.
     */
    data: CrossReferenceCreateManyInput | CrossReferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrossReference update
   */
  export type CrossReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a CrossReference.
     */
    data: XOR<CrossReferenceUpdateInput, CrossReferenceUncheckedUpdateInput>
    /**
     * Choose, which CrossReference to update.
     */
    where: CrossReferenceWhereUniqueInput
  }

  /**
   * CrossReference updateMany
   */
  export type CrossReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CrossReferences.
     */
    data: XOR<CrossReferenceUpdateManyMutationInput, CrossReferenceUncheckedUpdateManyInput>
    /**
     * Filter which CrossReferences to update
     */
    where?: CrossReferenceWhereInput
    /**
     * Limit how many CrossReferences to update.
     */
    limit?: number
  }

  /**
   * CrossReference updateManyAndReturn
   */
  export type CrossReferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * The data used to update CrossReferences.
     */
    data: XOR<CrossReferenceUpdateManyMutationInput, CrossReferenceUncheckedUpdateManyInput>
    /**
     * Filter which CrossReferences to update
     */
    where?: CrossReferenceWhereInput
    /**
     * Limit how many CrossReferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CrossReference upsert
   */
  export type CrossReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the CrossReference to update in case it exists.
     */
    where: CrossReferenceWhereUniqueInput
    /**
     * In case the CrossReference found by the `where` argument doesn't exist, create a new CrossReference with this data.
     */
    create: XOR<CrossReferenceCreateInput, CrossReferenceUncheckedCreateInput>
    /**
     * In case the CrossReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrossReferenceUpdateInput, CrossReferenceUncheckedUpdateInput>
  }

  /**
   * CrossReference delete
   */
  export type CrossReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
    /**
     * Filter which CrossReference to delete.
     */
    where: CrossReferenceWhereUniqueInput
  }

  /**
   * CrossReference deleteMany
   */
  export type CrossReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CrossReferences to delete
     */
    where?: CrossReferenceWhereInput
    /**
     * Limit how many CrossReferences to delete.
     */
    limit?: number
  }

  /**
   * CrossReference without action
   */
  export type CrossReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrossReference
     */
    select?: CrossReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CrossReference
     */
    omit?: CrossReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrossReferenceInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    productId: string | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    productId: number
    createdAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    productId: string
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "productId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly productId: FieldRef<"Favorite", 'String'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model ViewHistory
   */

  export type AggregateViewHistory = {
    _count: ViewHistoryCountAggregateOutputType | null
    _min: ViewHistoryMinAggregateOutputType | null
    _max: ViewHistoryMaxAggregateOutputType | null
  }

  export type ViewHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    productId: string | null
    categoryId: string | null
    viewedAt: Date | null
  }

  export type ViewHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    productId: string | null
    categoryId: string | null
    viewedAt: Date | null
  }

  export type ViewHistoryCountAggregateOutputType = {
    id: number
    userId: number
    anonymousId: number
    productId: number
    categoryId: number
    viewedAt: number
    _all: number
  }


  export type ViewHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    productId?: true
    categoryId?: true
    viewedAt?: true
  }

  export type ViewHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    productId?: true
    categoryId?: true
    viewedAt?: true
  }

  export type ViewHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    productId?: true
    categoryId?: true
    viewedAt?: true
    _all?: true
  }

  export type ViewHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewHistory to aggregate.
     */
    where?: ViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewHistories to fetch.
     */
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewHistories
    **/
    _count?: true | ViewHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewHistoryMaxAggregateInputType
  }

  export type GetViewHistoryAggregateType<T extends ViewHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateViewHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewHistory[P]>
      : GetScalarType<T[P], AggregateViewHistory[P]>
  }




  export type ViewHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewHistoryWhereInput
    orderBy?: ViewHistoryOrderByWithAggregationInput | ViewHistoryOrderByWithAggregationInput[]
    by: ViewHistoryScalarFieldEnum[] | ViewHistoryScalarFieldEnum
    having?: ViewHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewHistoryCountAggregateInputType | true
    _min?: ViewHistoryMinAggregateInputType
    _max?: ViewHistoryMaxAggregateInputType
  }

  export type ViewHistoryGroupByOutputType = {
    id: string
    userId: string | null
    anonymousId: string | null
    productId: string | null
    categoryId: string | null
    viewedAt: Date
    _count: ViewHistoryCountAggregateOutputType | null
    _min: ViewHistoryMinAggregateOutputType | null
    _max: ViewHistoryMaxAggregateOutputType | null
  }

  type GetViewHistoryGroupByPayload<T extends ViewHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ViewHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ViewHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    productId?: boolean
    categoryId?: boolean
    viewedAt?: boolean
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["viewHistory"]>

  export type ViewHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    productId?: boolean
    categoryId?: boolean
    viewedAt?: boolean
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["viewHistory"]>

  export type ViewHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    productId?: boolean
    categoryId?: boolean
    viewedAt?: boolean
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["viewHistory"]>

  export type ViewHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    productId?: boolean
    categoryId?: boolean
    viewedAt?: boolean
  }

  export type ViewHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonymousId" | "productId" | "categoryId" | "viewedAt", ExtArgs["result"]["viewHistory"]>
  export type ViewHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }
  export type ViewHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }
  export type ViewHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ViewHistory$userArgs<ExtArgs>
    anonymousUser?: boolean | ViewHistory$anonymousUserArgs<ExtArgs>
    product?: boolean | ViewHistory$productArgs<ExtArgs>
    category?: boolean | ViewHistory$categoryArgs<ExtArgs>
  }

  export type $ViewHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      anonymousUser: Prisma.$AnonymousUserPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonymousId: string | null
      productId: string | null
      categoryId: string | null
      viewedAt: Date
    }, ExtArgs["result"]["viewHistory"]>
    composites: {}
  }

  type ViewHistoryGetPayload<S extends boolean | null | undefined | ViewHistoryDefaultArgs> = $Result.GetResult<Prisma.$ViewHistoryPayload, S>

  type ViewHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewHistoryCountAggregateInputType | true
    }

  export interface ViewHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewHistory'], meta: { name: 'ViewHistory' } }
    /**
     * Find zero or one ViewHistory that matches the filter.
     * @param {ViewHistoryFindUniqueArgs} args - Arguments to find a ViewHistory
     * @example
     * // Get one ViewHistory
     * const viewHistory = await prisma.viewHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewHistoryFindUniqueArgs>(args: SelectSubset<T, ViewHistoryFindUniqueArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewHistoryFindUniqueOrThrowArgs} args - Arguments to find a ViewHistory
     * @example
     * // Get one ViewHistory
     * const viewHistory = await prisma.viewHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryFindFirstArgs} args - Arguments to find a ViewHistory
     * @example
     * // Get one ViewHistory
     * const viewHistory = await prisma.viewHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewHistoryFindFirstArgs>(args?: SelectSubset<T, ViewHistoryFindFirstArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryFindFirstOrThrowArgs} args - Arguments to find a ViewHistory
     * @example
     * // Get one ViewHistory
     * const viewHistory = await prisma.viewHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewHistories
     * const viewHistories = await prisma.viewHistory.findMany()
     * 
     * // Get first 10 ViewHistories
     * const viewHistories = await prisma.viewHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewHistoryWithIdOnly = await prisma.viewHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewHistoryFindManyArgs>(args?: SelectSubset<T, ViewHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewHistory.
     * @param {ViewHistoryCreateArgs} args - Arguments to create a ViewHistory.
     * @example
     * // Create one ViewHistory
     * const ViewHistory = await prisma.viewHistory.create({
     *   data: {
     *     // ... data to create a ViewHistory
     *   }
     * })
     * 
     */
    create<T extends ViewHistoryCreateArgs>(args: SelectSubset<T, ViewHistoryCreateArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewHistories.
     * @param {ViewHistoryCreateManyArgs} args - Arguments to create many ViewHistories.
     * @example
     * // Create many ViewHistories
     * const viewHistory = await prisma.viewHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewHistoryCreateManyArgs>(args?: SelectSubset<T, ViewHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewHistories and returns the data saved in the database.
     * @param {ViewHistoryCreateManyAndReturnArgs} args - Arguments to create many ViewHistories.
     * @example
     * // Create many ViewHistories
     * const viewHistory = await prisma.viewHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewHistories and only return the `id`
     * const viewHistoryWithIdOnly = await prisma.viewHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViewHistory.
     * @param {ViewHistoryDeleteArgs} args - Arguments to delete one ViewHistory.
     * @example
     * // Delete one ViewHistory
     * const ViewHistory = await prisma.viewHistory.delete({
     *   where: {
     *     // ... filter to delete one ViewHistory
     *   }
     * })
     * 
     */
    delete<T extends ViewHistoryDeleteArgs>(args: SelectSubset<T, ViewHistoryDeleteArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewHistory.
     * @param {ViewHistoryUpdateArgs} args - Arguments to update one ViewHistory.
     * @example
     * // Update one ViewHistory
     * const viewHistory = await prisma.viewHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewHistoryUpdateArgs>(args: SelectSubset<T, ViewHistoryUpdateArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewHistories.
     * @param {ViewHistoryDeleteManyArgs} args - Arguments to filter ViewHistories to delete.
     * @example
     * // Delete a few ViewHistories
     * const { count } = await prisma.viewHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewHistoryDeleteManyArgs>(args?: SelectSubset<T, ViewHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewHistories
     * const viewHistory = await prisma.viewHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewHistoryUpdateManyArgs>(args: SelectSubset<T, ViewHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewHistories and returns the data updated in the database.
     * @param {ViewHistoryUpdateManyAndReturnArgs} args - Arguments to update many ViewHistories.
     * @example
     * // Update many ViewHistories
     * const viewHistory = await prisma.viewHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewHistories and only return the `id`
     * const viewHistoryWithIdOnly = await prisma.viewHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViewHistory.
     * @param {ViewHistoryUpsertArgs} args - Arguments to update or create a ViewHistory.
     * @example
     * // Update or create a ViewHistory
     * const viewHistory = await prisma.viewHistory.upsert({
     *   create: {
     *     // ... data to create a ViewHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewHistory we want to update
     *   }
     * })
     */
    upsert<T extends ViewHistoryUpsertArgs>(args: SelectSubset<T, ViewHistoryUpsertArgs<ExtArgs>>): Prisma__ViewHistoryClient<$Result.GetResult<Prisma.$ViewHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryCountArgs} args - Arguments to filter ViewHistories to count.
     * @example
     * // Count the number of ViewHistories
     * const count = await prisma.viewHistory.count({
     *   where: {
     *     // ... the filter for the ViewHistories we want to count
     *   }
     * })
    **/
    count<T extends ViewHistoryCountArgs>(
      args?: Subset<T, ViewHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewHistoryAggregateArgs>(args: Subset<T, ViewHistoryAggregateArgs>): Prisma.PrismaPromise<GetViewHistoryAggregateType<T>>

    /**
     * Group by ViewHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ViewHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewHistory model
   */
  readonly fields: ViewHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ViewHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, ViewHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    anonymousUser<T extends ViewHistory$anonymousUserArgs<ExtArgs> = {}>(args?: Subset<T, ViewHistory$anonymousUserArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends ViewHistory$productArgs<ExtArgs> = {}>(args?: Subset<T, ViewHistory$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends ViewHistory$categoryArgs<ExtArgs> = {}>(args?: Subset<T, ViewHistory$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewHistory model
   */
  interface ViewHistoryFieldRefs {
    readonly id: FieldRef<"ViewHistory", 'String'>
    readonly userId: FieldRef<"ViewHistory", 'String'>
    readonly anonymousId: FieldRef<"ViewHistory", 'String'>
    readonly productId: FieldRef<"ViewHistory", 'String'>
    readonly categoryId: FieldRef<"ViewHistory", 'String'>
    readonly viewedAt: FieldRef<"ViewHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ViewHistory findUnique
   */
  export type ViewHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ViewHistory to fetch.
     */
    where: ViewHistoryWhereUniqueInput
  }

  /**
   * ViewHistory findUniqueOrThrow
   */
  export type ViewHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ViewHistory to fetch.
     */
    where: ViewHistoryWhereUniqueInput
  }

  /**
   * ViewHistory findFirst
   */
  export type ViewHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ViewHistory to fetch.
     */
    where?: ViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewHistories to fetch.
     */
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewHistories.
     */
    cursor?: ViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewHistories.
     */
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * ViewHistory findFirstOrThrow
   */
  export type ViewHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ViewHistory to fetch.
     */
    where?: ViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewHistories to fetch.
     */
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewHistories.
     */
    cursor?: ViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewHistories.
     */
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * ViewHistory findMany
   */
  export type ViewHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ViewHistories to fetch.
     */
    where?: ViewHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewHistories to fetch.
     */
    orderBy?: ViewHistoryOrderByWithRelationInput | ViewHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewHistories.
     */
    cursor?: ViewHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewHistories.
     */
    skip?: number
    distinct?: ViewHistoryScalarFieldEnum | ViewHistoryScalarFieldEnum[]
  }

  /**
   * ViewHistory create
   */
  export type ViewHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewHistory.
     */
    data?: XOR<ViewHistoryCreateInput, ViewHistoryUncheckedCreateInput>
  }

  /**
   * ViewHistory createMany
   */
  export type ViewHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewHistories.
     */
    data: ViewHistoryCreateManyInput | ViewHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViewHistory createManyAndReturn
   */
  export type ViewHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ViewHistories.
     */
    data: ViewHistoryCreateManyInput | ViewHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewHistory update
   */
  export type ViewHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewHistory.
     */
    data: XOR<ViewHistoryUpdateInput, ViewHistoryUncheckedUpdateInput>
    /**
     * Choose, which ViewHistory to update.
     */
    where: ViewHistoryWhereUniqueInput
  }

  /**
   * ViewHistory updateMany
   */
  export type ViewHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewHistories.
     */
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ViewHistories to update
     */
    where?: ViewHistoryWhereInput
    /**
     * Limit how many ViewHistories to update.
     */
    limit?: number
  }

  /**
   * ViewHistory updateManyAndReturn
   */
  export type ViewHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ViewHistories.
     */
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ViewHistories to update
     */
    where?: ViewHistoryWhereInput
    /**
     * Limit how many ViewHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ViewHistory upsert
   */
  export type ViewHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewHistory to update in case it exists.
     */
    where: ViewHistoryWhereUniqueInput
    /**
     * In case the ViewHistory found by the `where` argument doesn't exist, create a new ViewHistory with this data.
     */
    create: XOR<ViewHistoryCreateInput, ViewHistoryUncheckedCreateInput>
    /**
     * In case the ViewHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewHistoryUpdateInput, ViewHistoryUncheckedUpdateInput>
  }

  /**
   * ViewHistory delete
   */
  export type ViewHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
    /**
     * Filter which ViewHistory to delete.
     */
    where: ViewHistoryWhereUniqueInput
  }

  /**
   * ViewHistory deleteMany
   */
  export type ViewHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewHistories to delete
     */
    where?: ViewHistoryWhereInput
    /**
     * Limit how many ViewHistories to delete.
     */
    limit?: number
  }

  /**
   * ViewHistory.user
   */
  export type ViewHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ViewHistory.anonymousUser
   */
  export type ViewHistory$anonymousUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    where?: AnonymousUserWhereInput
  }

  /**
   * ViewHistory.product
   */
  export type ViewHistory$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * ViewHistory.category
   */
  export type ViewHistory$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * ViewHistory without action
   */
  export type ViewHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewHistory
     */
    select?: ViewHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewHistory
     */
    omit?: ViewHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    userId: number
    anonymousId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CartMinAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cart to aggregate.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type CartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartWhereInput
    orderBy?: CartOrderByWithAggregationInput | CartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: CartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: string
    userId: string | null
    anonymousId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CartCountAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends CartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type CartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type CartSelectScalar = {
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonymousId" | "createdAt" | "updatedAt", ExtArgs["result"]["cart"]>
  export type CartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
    items?: boolean | Cart$itemsArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CartIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
  }
  export type CartIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Cart$userArgs<ExtArgs>
    anonymousUser?: boolean | Cart$anonymousUserArgs<ExtArgs>
  }

  export type $CartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cart"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      anonymousUser: Prisma.$AnonymousUserPayload<ExtArgs> | null
      items: Prisma.$CartItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonymousId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }

  type CartGetPayload<S extends boolean | null | undefined | CartDefaultArgs> = $Result.GetResult<Prisma.$CartPayload, S>

  type CartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartCountAggregateInputType | true
    }

  export interface CartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cart'], meta: { name: 'Cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {CartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartFindUniqueArgs>(args: SelectSubset<T, CartFindUniqueArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartFindUniqueOrThrowArgs>(args: SelectSubset<T, CartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartFindFirstArgs>(args?: SelectSubset<T, CartFindFirstArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartFindFirstOrThrowArgs>(args?: SelectSubset<T, CartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartFindManyArgs>(args?: SelectSubset<T, CartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cart.
     * @param {CartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
     */
    create<T extends CartCreateArgs>(args: SelectSubset<T, CartCreateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Carts.
     * @param {CartCreateManyArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartCreateManyArgs>(args?: SelectSubset<T, CartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Carts and returns the data saved in the database.
     * @param {CartCreateManyAndReturnArgs} args - Arguments to create many Carts.
     * @example
     * // Create many Carts
     * const cart = await prisma.cart.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartCreateManyAndReturnArgs>(args?: SelectSubset<T, CartCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cart.
     * @param {CartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
     */
    delete<T extends CartDeleteArgs>(args: SelectSubset<T, CartDeleteArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cart.
     * @param {CartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartUpdateArgs>(args: SelectSubset<T, CartUpdateArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Carts.
     * @param {CartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartDeleteManyArgs>(args?: SelectSubset<T, CartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartUpdateManyArgs>(args: SelectSubset<T, CartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts and returns the data updated in the database.
     * @param {CartUpdateManyAndReturnArgs} args - Arguments to update many Carts.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Carts and only return the `id`
     * const cartWithIdOnly = await prisma.cart.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartUpdateManyAndReturnArgs>(args: SelectSubset<T, CartUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cart.
     * @param {CartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
     */
    upsert<T extends CartUpsertArgs>(args: SelectSubset<T, CartUpsertArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends CartCountArgs>(
      args?: Subset<T, CartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartGroupByArgs['orderBy'] }
        : { orderBy?: CartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cart model
   */
  readonly fields: CartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Cart$userArgs<ExtArgs> = {}>(args?: Subset<T, Cart$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    anonymousUser<T extends Cart$anonymousUserArgs<ExtArgs> = {}>(args?: Subset<T, Cart$anonymousUserArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Cart$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Cart$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cart model
   */
  interface CartFieldRefs {
    readonly id: FieldRef<"Cart", 'String'>
    readonly userId: FieldRef<"Cart", 'String'>
    readonly anonymousId: FieldRef<"Cart", 'String'>
    readonly createdAt: FieldRef<"Cart", 'DateTime'>
    readonly updatedAt: FieldRef<"Cart", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cart findUnique
   */
  export type CartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findUniqueOrThrow
   */
  export type CartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart findFirst
   */
  export type CartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findFirstOrThrow
   */
  export type CartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Cart to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart findMany
   */
  export type CartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter, which Carts to fetch.
     */
    where?: CartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carts to fetch.
     */
    orderBy?: CartOrderByWithRelationInput | CartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carts.
     */
    cursor?: CartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }

  /**
   * Cart create
   */
  export type CartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to create a Cart.
     */
    data: XOR<CartCreateInput, CartUncheckedCreateInput>
  }

  /**
   * Cart createMany
   */
  export type CartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cart createManyAndReturn
   */
  export type CartCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to create many Carts.
     */
    data: CartCreateManyInput | CartCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart update
   */
  export type CartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The data needed to update a Cart.
     */
    data: XOR<CartUpdateInput, CartUncheckedUpdateInput>
    /**
     * Choose, which Cart to update.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart updateMany
   */
  export type CartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
  }

  /**
   * Cart updateManyAndReturn
   */
  export type CartUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * The data used to update Carts.
     */
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyInput>
    /**
     * Filter which Carts to update
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cart upsert
   */
  export type CartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * The filter to search for the Cart to update in case it exists.
     */
    where: CartWhereUniqueInput
    /**
     * In case the Cart found by the `where` argument doesn't exist, create a new Cart with this data.
     */
    create: XOR<CartCreateInput, CartUncheckedCreateInput>
    /**
     * In case the Cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartUpdateInput, CartUncheckedUpdateInput>
  }

  /**
   * Cart delete
   */
  export type CartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
    /**
     * Filter which Cart to delete.
     */
    where: CartWhereUniqueInput
  }

  /**
   * Cart deleteMany
   */
  export type CartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Carts to delete
     */
    where?: CartWhereInput
    /**
     * Limit how many Carts to delete.
     */
    limit?: number
  }

  /**
   * Cart.user
   */
  export type Cart$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cart.anonymousUser
   */
  export type Cart$anonymousUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    where?: AnonymousUserWhereInput
  }

  /**
   * Cart.items
   */
  export type Cart$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * Cart without action
   */
  export type CartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cart
     */
    select?: CartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cart
     */
    omit?: CartOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartInclude<ExtArgs> | null
  }


  /**
   * Model CartItem
   */

  export type AggregateCartItem = {
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  export type CartItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type CartItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
  }

  export type CartItemMinAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    chatProductId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type CartItemMaxAggregateOutputType = {
    id: string | null
    cartId: string | null
    productId: string | null
    chatProductId: string | null
    quantity: number | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type CartItemCountAggregateOutputType = {
    id: number
    cartId: number
    productId: number
    chatProductId: number
    quantity: number
    price: number
    createdAt: number
    _all: number
  }


  export type CartItemAvgAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemSumAggregateInputType = {
    quantity?: true
    price?: true
  }

  export type CartItemMinAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type CartItemMaxAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    createdAt?: true
  }

  export type CartItemCountAggregateInputType = {
    id?: true
    cartId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type CartItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItem to aggregate.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CartItems
    **/
    _count?: true | CartItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartItemMaxAggregateInputType
  }

  export type GetCartItemAggregateType<T extends CartItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCartItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCartItem[P]>
      : GetScalarType<T[P], AggregateCartItem[P]>
  }




  export type CartItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithAggregationInput | CartItemOrderByWithAggregationInput[]
    by: CartItemScalarFieldEnum[] | CartItemScalarFieldEnum
    having?: CartItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartItemCountAggregateInputType | true
    _avg?: CartItemAvgAggregateInputType
    _sum?: CartItemSumAggregateInputType
    _min?: CartItemMinAggregateInputType
    _max?: CartItemMaxAggregateInputType
  }

  export type CartItemGroupByOutputType = {
    id: string
    cartId: string
    productId: string | null
    chatProductId: string | null
    quantity: number
    price: Decimal
    createdAt: Date
    _count: CartItemCountAggregateOutputType | null
    _avg: CartItemAvgAggregateOutputType | null
    _sum: CartItemSumAggregateOutputType | null
    _min: CartItemMinAggregateOutputType | null
    _max: CartItemMaxAggregateOutputType | null
  }

  type GetCartItemGroupByPayload<T extends CartItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartItemGroupByOutputType[P]>
            : GetScalarType<T[P], CartItemGroupByOutputType[P]>
        }
      >
    >


  export type CartItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cartId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["cartItem"]>

  export type CartItemSelectScalar = {
    id?: boolean
    cartId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type CartItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cartId" | "productId" | "chatProductId" | "quantity" | "price" | "createdAt", ExtArgs["result"]["cartItem"]>
  export type CartItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }
  export type CartItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }
  export type CartItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | CartDefaultArgs<ExtArgs>
    product?: boolean | CartItem$productArgs<ExtArgs>
    chatProduct?: boolean | CartItem$chatProductArgs<ExtArgs>
  }

  export type $CartItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CartItem"
    objects: {
      cart: Prisma.$CartPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      chatProduct: Prisma.$ChatProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cartId: string
      productId: string | null
      chatProductId: string | null
      quantity: number
      price: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["cartItem"]>
    composites: {}
  }

  type CartItemGetPayload<S extends boolean | null | undefined | CartItemDefaultArgs> = $Result.GetResult<Prisma.$CartItemPayload, S>

  type CartItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CartItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CartItemCountAggregateInputType | true
    }

  export interface CartItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CartItem'], meta: { name: 'CartItem' } }
    /**
     * Find zero or one CartItem that matches the filter.
     * @param {CartItemFindUniqueArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CartItemFindUniqueArgs>(args: SelectSubset<T, CartItemFindUniqueArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CartItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CartItemFindUniqueOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CartItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CartItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CartItemFindFirstArgs>(args?: SelectSubset<T, CartItemFindFirstArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CartItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindFirstOrThrowArgs} args - Arguments to find a CartItem
     * @example
     * // Get one CartItem
     * const cartItem = await prisma.cartItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CartItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CartItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CartItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CartItems
     * const cartItems = await prisma.cartItem.findMany()
     * 
     * // Get first 10 CartItems
     * const cartItems = await prisma.cartItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CartItemFindManyArgs>(args?: SelectSubset<T, CartItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CartItem.
     * @param {CartItemCreateArgs} args - Arguments to create a CartItem.
     * @example
     * // Create one CartItem
     * const CartItem = await prisma.cartItem.create({
     *   data: {
     *     // ... data to create a CartItem
     *   }
     * })
     * 
     */
    create<T extends CartItemCreateArgs>(args: SelectSubset<T, CartItemCreateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CartItems.
     * @param {CartItemCreateManyArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CartItemCreateManyArgs>(args?: SelectSubset<T, CartItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CartItems and returns the data saved in the database.
     * @param {CartItemCreateManyAndReturnArgs} args - Arguments to create many CartItems.
     * @example
     * // Create many CartItems
     * const cartItem = await prisma.cartItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CartItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CartItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CartItem.
     * @param {CartItemDeleteArgs} args - Arguments to delete one CartItem.
     * @example
     * // Delete one CartItem
     * const CartItem = await prisma.cartItem.delete({
     *   where: {
     *     // ... filter to delete one CartItem
     *   }
     * })
     * 
     */
    delete<T extends CartItemDeleteArgs>(args: SelectSubset<T, CartItemDeleteArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CartItem.
     * @param {CartItemUpdateArgs} args - Arguments to update one CartItem.
     * @example
     * // Update one CartItem
     * const cartItem = await prisma.cartItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CartItemUpdateArgs>(args: SelectSubset<T, CartItemUpdateArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CartItems.
     * @param {CartItemDeleteManyArgs} args - Arguments to filter CartItems to delete.
     * @example
     * // Delete a few CartItems
     * const { count } = await prisma.cartItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CartItemDeleteManyArgs>(args?: SelectSubset<T, CartItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CartItemUpdateManyArgs>(args: SelectSubset<T, CartItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CartItems and returns the data updated in the database.
     * @param {CartItemUpdateManyAndReturnArgs} args - Arguments to update many CartItems.
     * @example
     * // Update many CartItems
     * const cartItem = await prisma.cartItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CartItems and only return the `id`
     * const cartItemWithIdOnly = await prisma.cartItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CartItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CartItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CartItem.
     * @param {CartItemUpsertArgs} args - Arguments to update or create a CartItem.
     * @example
     * // Update or create a CartItem
     * const cartItem = await prisma.cartItem.upsert({
     *   create: {
     *     // ... data to create a CartItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CartItem we want to update
     *   }
     * })
     */
    upsert<T extends CartItemUpsertArgs>(args: SelectSubset<T, CartItemUpsertArgs<ExtArgs>>): Prisma__CartItemClient<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CartItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemCountArgs} args - Arguments to filter CartItems to count.
     * @example
     * // Count the number of CartItems
     * const count = await prisma.cartItem.count({
     *   where: {
     *     // ... the filter for the CartItems we want to count
     *   }
     * })
    **/
    count<T extends CartItemCountArgs>(
      args?: Subset<T, CartItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartItemAggregateArgs>(args: Subset<T, CartItemAggregateArgs>): Prisma.PrismaPromise<GetCartItemAggregateType<T>>

    /**
     * Group by CartItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CartItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CartItemGroupByArgs['orderBy'] }
        : { orderBy?: CartItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CartItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CartItem model
   */
  readonly fields: CartItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CartItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CartItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cart<T extends CartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CartDefaultArgs<ExtArgs>>): Prisma__CartClient<$Result.GetResult<Prisma.$CartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends CartItem$productArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chatProduct<T extends CartItem$chatProductArgs<ExtArgs> = {}>(args?: Subset<T, CartItem$chatProductArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CartItem model
   */
  interface CartItemFieldRefs {
    readonly id: FieldRef<"CartItem", 'String'>
    readonly cartId: FieldRef<"CartItem", 'String'>
    readonly productId: FieldRef<"CartItem", 'String'>
    readonly chatProductId: FieldRef<"CartItem", 'String'>
    readonly quantity: FieldRef<"CartItem", 'Int'>
    readonly price: FieldRef<"CartItem", 'Decimal'>
    readonly createdAt: FieldRef<"CartItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CartItem findUnique
   */
  export type CartItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findUniqueOrThrow
   */
  export type CartItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem findFirst
   */
  export type CartItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findFirstOrThrow
   */
  export type CartItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItem to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CartItems.
     */
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem findMany
   */
  export type CartItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter, which CartItems to fetch.
     */
    where?: CartItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CartItems to fetch.
     */
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CartItems.
     */
    cursor?: CartItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CartItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CartItems.
     */
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * CartItem create
   */
  export type CartItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CartItem.
     */
    data: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
  }

  /**
   * CartItem createMany
   */
  export type CartItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CartItem createManyAndReturn
   */
  export type CartItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to create many CartItems.
     */
    data: CartItemCreateManyInput | CartItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem update
   */
  export type CartItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CartItem.
     */
    data: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
    /**
     * Choose, which CartItem to update.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem updateMany
   */
  export type CartItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
  }

  /**
   * CartItem updateManyAndReturn
   */
  export type CartItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * The data used to update CartItems.
     */
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyInput>
    /**
     * Filter which CartItems to update
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CartItem upsert
   */
  export type CartItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CartItem to update in case it exists.
     */
    where: CartItemWhereUniqueInput
    /**
     * In case the CartItem found by the `where` argument doesn't exist, create a new CartItem with this data.
     */
    create: XOR<CartItemCreateInput, CartItemUncheckedCreateInput>
    /**
     * In case the CartItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CartItemUpdateInput, CartItemUncheckedUpdateInput>
  }

  /**
   * CartItem delete
   */
  export type CartItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    /**
     * Filter which CartItem to delete.
     */
    where: CartItemWhereUniqueInput
  }

  /**
   * CartItem deleteMany
   */
  export type CartItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CartItems to delete
     */
    where?: CartItemWhereInput
    /**
     * Limit how many CartItems to delete.
     */
    limit?: number
  }

  /**
   * CartItem.product
   */
  export type CartItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * CartItem.chatProduct
   */
  export type CartItem$chatProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    where?: ChatProductWhereInput
  }

  /**
   * CartItem without action
   */
  export type CartItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
  }


  /**
   * Model ChatProduct
   */

  export type AggregateChatProduct = {
    _count: ChatProductCountAggregateOutputType | null
    _avg: ChatProductAvgAggregateOutputType | null
    _sum: ChatProductSumAggregateOutputType | null
    _min: ChatProductMinAggregateOutputType | null
    _max: ChatProductMaxAggregateOutputType | null
  }

  export type ChatProductAvgAggregateOutputType = {
    price: Decimal | null
    comparePrice: Decimal | null
    deliveryDays: number | null
  }

  export type ChatProductSumAggregateOutputType = {
    price: Decimal | null
    comparePrice: Decimal | null
    deliveryDays: number | null
  }

  export type ChatProductMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    name: string | null
    brand: string | null
    sku: string | null
    price: Decimal | null
    comparePrice: Decimal | null
    isOriginal: boolean | null
    deliveryDays: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChatProductMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    name: string | null
    brand: string | null
    sku: string | null
    price: Decimal | null
    comparePrice: Decimal | null
    isOriginal: boolean | null
    deliveryDays: number | null
    description: string | null
    createdAt: Date | null
  }

  export type ChatProductCountAggregateOutputType = {
    id: number
    messageId: number
    name: number
    brand: number
    sku: number
    price: number
    comparePrice: number
    isOriginal: number
    deliveryDays: number
    description: number
    createdAt: number
    _all: number
  }


  export type ChatProductAvgAggregateInputType = {
    price?: true
    comparePrice?: true
    deliveryDays?: true
  }

  export type ChatProductSumAggregateInputType = {
    price?: true
    comparePrice?: true
    deliveryDays?: true
  }

  export type ChatProductMinAggregateInputType = {
    id?: true
    messageId?: true
    name?: true
    brand?: true
    sku?: true
    price?: true
    comparePrice?: true
    isOriginal?: true
    deliveryDays?: true
    description?: true
    createdAt?: true
  }

  export type ChatProductMaxAggregateInputType = {
    id?: true
    messageId?: true
    name?: true
    brand?: true
    sku?: true
    price?: true
    comparePrice?: true
    isOriginal?: true
    deliveryDays?: true
    description?: true
    createdAt?: true
  }

  export type ChatProductCountAggregateInputType = {
    id?: true
    messageId?: true
    name?: true
    brand?: true
    sku?: true
    price?: true
    comparePrice?: true
    isOriginal?: true
    deliveryDays?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type ChatProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatProduct to aggregate.
     */
    where?: ChatProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProducts to fetch.
     */
    orderBy?: ChatProductOrderByWithRelationInput | ChatProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatProducts
    **/
    _count?: true | ChatProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatProductMaxAggregateInputType
  }

  export type GetChatProductAggregateType<T extends ChatProductAggregateArgs> = {
        [P in keyof T & keyof AggregateChatProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatProduct[P]>
      : GetScalarType<T[P], AggregateChatProduct[P]>
  }




  export type ChatProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatProductWhereInput
    orderBy?: ChatProductOrderByWithAggregationInput | ChatProductOrderByWithAggregationInput[]
    by: ChatProductScalarFieldEnum[] | ChatProductScalarFieldEnum
    having?: ChatProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatProductCountAggregateInputType | true
    _avg?: ChatProductAvgAggregateInputType
    _sum?: ChatProductSumAggregateInputType
    _min?: ChatProductMinAggregateInputType
    _max?: ChatProductMaxAggregateInputType
  }

  export type ChatProductGroupByOutputType = {
    id: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal
    comparePrice: Decimal | null
    isOriginal: boolean
    deliveryDays: number | null
    description: string | null
    createdAt: Date
    _count: ChatProductCountAggregateOutputType | null
    _avg: ChatProductAvgAggregateOutputType | null
    _sum: ChatProductSumAggregateOutputType | null
    _min: ChatProductMinAggregateOutputType | null
    _max: ChatProductMaxAggregateOutputType | null
  }

  type GetChatProductGroupByPayload<T extends ChatProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatProductGroupByOutputType[P]>
            : GetScalarType<T[P], ChatProductGroupByOutputType[P]>
        }
      >
    >


  export type ChatProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    name?: boolean
    brand?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    isOriginal?: boolean
    deliveryDays?: boolean
    description?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    images?: boolean | ChatProduct$imagesArgs<ExtArgs>
    cartItems?: boolean | ChatProduct$cartItemsArgs<ExtArgs>
    orderItems?: boolean | ChatProduct$orderItemsArgs<ExtArgs>
    _count?: boolean | ChatProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProduct"]>

  export type ChatProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    name?: boolean
    brand?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    isOriginal?: boolean
    deliveryDays?: boolean
    description?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProduct"]>

  export type ChatProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    name?: boolean
    brand?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    isOriginal?: boolean
    deliveryDays?: boolean
    description?: boolean
    createdAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProduct"]>

  export type ChatProductSelectScalar = {
    id?: boolean
    messageId?: boolean
    name?: boolean
    brand?: boolean
    sku?: boolean
    price?: boolean
    comparePrice?: boolean
    isOriginal?: boolean
    deliveryDays?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type ChatProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "name" | "brand" | "sku" | "price" | "comparePrice" | "isOriginal" | "deliveryDays" | "description" | "createdAt", ExtArgs["result"]["chatProduct"]>
  export type ChatProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    images?: boolean | ChatProduct$imagesArgs<ExtArgs>
    cartItems?: boolean | ChatProduct$cartItemsArgs<ExtArgs>
    orderItems?: boolean | ChatProduct$orderItemsArgs<ExtArgs>
    _count?: boolean | ChatProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type ChatProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $ChatProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatProduct"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      images: Prisma.$ChatProductImagePayload<ExtArgs>[]
      cartItems: Prisma.$CartItemPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      name: string
      brand: string
      sku: string
      price: Prisma.Decimal
      comparePrice: Prisma.Decimal | null
      isOriginal: boolean
      deliveryDays: number | null
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["chatProduct"]>
    composites: {}
  }

  type ChatProductGetPayload<S extends boolean | null | undefined | ChatProductDefaultArgs> = $Result.GetResult<Prisma.$ChatProductPayload, S>

  type ChatProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatProductCountAggregateInputType | true
    }

  export interface ChatProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatProduct'], meta: { name: 'ChatProduct' } }
    /**
     * Find zero or one ChatProduct that matches the filter.
     * @param {ChatProductFindUniqueArgs} args - Arguments to find a ChatProduct
     * @example
     * // Get one ChatProduct
     * const chatProduct = await prisma.chatProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatProductFindUniqueArgs>(args: SelectSubset<T, ChatProductFindUniqueArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatProductFindUniqueOrThrowArgs} args - Arguments to find a ChatProduct
     * @example
     * // Get one ChatProduct
     * const chatProduct = await prisma.chatProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductFindFirstArgs} args - Arguments to find a ChatProduct
     * @example
     * // Get one ChatProduct
     * const chatProduct = await prisma.chatProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatProductFindFirstArgs>(args?: SelectSubset<T, ChatProductFindFirstArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductFindFirstOrThrowArgs} args - Arguments to find a ChatProduct
     * @example
     * // Get one ChatProduct
     * const chatProduct = await prisma.chatProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatProducts
     * const chatProducts = await prisma.chatProduct.findMany()
     * 
     * // Get first 10 ChatProducts
     * const chatProducts = await prisma.chatProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatProductWithIdOnly = await prisma.chatProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatProductFindManyArgs>(args?: SelectSubset<T, ChatProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatProduct.
     * @param {ChatProductCreateArgs} args - Arguments to create a ChatProduct.
     * @example
     * // Create one ChatProduct
     * const ChatProduct = await prisma.chatProduct.create({
     *   data: {
     *     // ... data to create a ChatProduct
     *   }
     * })
     * 
     */
    create<T extends ChatProductCreateArgs>(args: SelectSubset<T, ChatProductCreateArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatProducts.
     * @param {ChatProductCreateManyArgs} args - Arguments to create many ChatProducts.
     * @example
     * // Create many ChatProducts
     * const chatProduct = await prisma.chatProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatProductCreateManyArgs>(args?: SelectSubset<T, ChatProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatProducts and returns the data saved in the database.
     * @param {ChatProductCreateManyAndReturnArgs} args - Arguments to create many ChatProducts.
     * @example
     * // Create many ChatProducts
     * const chatProduct = await prisma.chatProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatProducts and only return the `id`
     * const chatProductWithIdOnly = await prisma.chatProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatProduct.
     * @param {ChatProductDeleteArgs} args - Arguments to delete one ChatProduct.
     * @example
     * // Delete one ChatProduct
     * const ChatProduct = await prisma.chatProduct.delete({
     *   where: {
     *     // ... filter to delete one ChatProduct
     *   }
     * })
     * 
     */
    delete<T extends ChatProductDeleteArgs>(args: SelectSubset<T, ChatProductDeleteArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatProduct.
     * @param {ChatProductUpdateArgs} args - Arguments to update one ChatProduct.
     * @example
     * // Update one ChatProduct
     * const chatProduct = await prisma.chatProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatProductUpdateArgs>(args: SelectSubset<T, ChatProductUpdateArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatProducts.
     * @param {ChatProductDeleteManyArgs} args - Arguments to filter ChatProducts to delete.
     * @example
     * // Delete a few ChatProducts
     * const { count } = await prisma.chatProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatProductDeleteManyArgs>(args?: SelectSubset<T, ChatProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatProducts
     * const chatProduct = await prisma.chatProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatProductUpdateManyArgs>(args: SelectSubset<T, ChatProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatProducts and returns the data updated in the database.
     * @param {ChatProductUpdateManyAndReturnArgs} args - Arguments to update many ChatProducts.
     * @example
     * // Update many ChatProducts
     * const chatProduct = await prisma.chatProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatProducts and only return the `id`
     * const chatProductWithIdOnly = await prisma.chatProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatProduct.
     * @param {ChatProductUpsertArgs} args - Arguments to update or create a ChatProduct.
     * @example
     * // Update or create a ChatProduct
     * const chatProduct = await prisma.chatProduct.upsert({
     *   create: {
     *     // ... data to create a ChatProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatProduct we want to update
     *   }
     * })
     */
    upsert<T extends ChatProductUpsertArgs>(args: SelectSubset<T, ChatProductUpsertArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductCountArgs} args - Arguments to filter ChatProducts to count.
     * @example
     * // Count the number of ChatProducts
     * const count = await prisma.chatProduct.count({
     *   where: {
     *     // ... the filter for the ChatProducts we want to count
     *   }
     * })
    **/
    count<T extends ChatProductCountArgs>(
      args?: Subset<T, ChatProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatProductAggregateArgs>(args: Subset<T, ChatProductAggregateArgs>): Prisma.PrismaPromise<GetChatProductAggregateType<T>>

    /**
     * Group by ChatProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatProductGroupByArgs['orderBy'] }
        : { orderBy?: ChatProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatProduct model
   */
  readonly fields: ChatProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends ChatProduct$imagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatProduct$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cartItems<T extends ChatProduct$cartItemsArgs<ExtArgs> = {}>(args?: Subset<T, ChatProduct$cartItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CartItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends ChatProduct$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, ChatProduct$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatProduct model
   */
  interface ChatProductFieldRefs {
    readonly id: FieldRef<"ChatProduct", 'String'>
    readonly messageId: FieldRef<"ChatProduct", 'String'>
    readonly name: FieldRef<"ChatProduct", 'String'>
    readonly brand: FieldRef<"ChatProduct", 'String'>
    readonly sku: FieldRef<"ChatProduct", 'String'>
    readonly price: FieldRef<"ChatProduct", 'Decimal'>
    readonly comparePrice: FieldRef<"ChatProduct", 'Decimal'>
    readonly isOriginal: FieldRef<"ChatProduct", 'Boolean'>
    readonly deliveryDays: FieldRef<"ChatProduct", 'Int'>
    readonly description: FieldRef<"ChatProduct", 'String'>
    readonly createdAt: FieldRef<"ChatProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatProduct findUnique
   */
  export type ChatProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter, which ChatProduct to fetch.
     */
    where: ChatProductWhereUniqueInput
  }

  /**
   * ChatProduct findUniqueOrThrow
   */
  export type ChatProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter, which ChatProduct to fetch.
     */
    where: ChatProductWhereUniqueInput
  }

  /**
   * ChatProduct findFirst
   */
  export type ChatProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter, which ChatProduct to fetch.
     */
    where?: ChatProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProducts to fetch.
     */
    orderBy?: ChatProductOrderByWithRelationInput | ChatProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatProducts.
     */
    cursor?: ChatProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatProducts.
     */
    distinct?: ChatProductScalarFieldEnum | ChatProductScalarFieldEnum[]
  }

  /**
   * ChatProduct findFirstOrThrow
   */
  export type ChatProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter, which ChatProduct to fetch.
     */
    where?: ChatProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProducts to fetch.
     */
    orderBy?: ChatProductOrderByWithRelationInput | ChatProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatProducts.
     */
    cursor?: ChatProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatProducts.
     */
    distinct?: ChatProductScalarFieldEnum | ChatProductScalarFieldEnum[]
  }

  /**
   * ChatProduct findMany
   */
  export type ChatProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter, which ChatProducts to fetch.
     */
    where?: ChatProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProducts to fetch.
     */
    orderBy?: ChatProductOrderByWithRelationInput | ChatProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatProducts.
     */
    cursor?: ChatProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProducts.
     */
    skip?: number
    distinct?: ChatProductScalarFieldEnum | ChatProductScalarFieldEnum[]
  }

  /**
   * ChatProduct create
   */
  export type ChatProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatProduct.
     */
    data: XOR<ChatProductCreateInput, ChatProductUncheckedCreateInput>
  }

  /**
   * ChatProduct createMany
   */
  export type ChatProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatProducts.
     */
    data: ChatProductCreateManyInput | ChatProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatProduct createManyAndReturn
   */
  export type ChatProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * The data used to create many ChatProducts.
     */
    data: ChatProductCreateManyInput | ChatProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatProduct update
   */
  export type ChatProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatProduct.
     */
    data: XOR<ChatProductUpdateInput, ChatProductUncheckedUpdateInput>
    /**
     * Choose, which ChatProduct to update.
     */
    where: ChatProductWhereUniqueInput
  }

  /**
   * ChatProduct updateMany
   */
  export type ChatProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatProducts.
     */
    data: XOR<ChatProductUpdateManyMutationInput, ChatProductUncheckedUpdateManyInput>
    /**
     * Filter which ChatProducts to update
     */
    where?: ChatProductWhereInput
    /**
     * Limit how many ChatProducts to update.
     */
    limit?: number
  }

  /**
   * ChatProduct updateManyAndReturn
   */
  export type ChatProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * The data used to update ChatProducts.
     */
    data: XOR<ChatProductUpdateManyMutationInput, ChatProductUncheckedUpdateManyInput>
    /**
     * Filter which ChatProducts to update
     */
    where?: ChatProductWhereInput
    /**
     * Limit how many ChatProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatProduct upsert
   */
  export type ChatProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatProduct to update in case it exists.
     */
    where: ChatProductWhereUniqueInput
    /**
     * In case the ChatProduct found by the `where` argument doesn't exist, create a new ChatProduct with this data.
     */
    create: XOR<ChatProductCreateInput, ChatProductUncheckedCreateInput>
    /**
     * In case the ChatProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatProductUpdateInput, ChatProductUncheckedUpdateInput>
  }

  /**
   * ChatProduct delete
   */
  export type ChatProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    /**
     * Filter which ChatProduct to delete.
     */
    where: ChatProductWhereUniqueInput
  }

  /**
   * ChatProduct deleteMany
   */
  export type ChatProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatProducts to delete
     */
    where?: ChatProductWhereInput
    /**
     * Limit how many ChatProducts to delete.
     */
    limit?: number
  }

  /**
   * ChatProduct.images
   */
  export type ChatProduct$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    where?: ChatProductImageWhereInput
    orderBy?: ChatProductImageOrderByWithRelationInput | ChatProductImageOrderByWithRelationInput[]
    cursor?: ChatProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatProductImageScalarFieldEnum | ChatProductImageScalarFieldEnum[]
  }

  /**
   * ChatProduct.cartItems
   */
  export type ChatProduct$cartItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartItem
     */
    select?: CartItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CartItem
     */
    omit?: CartItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CartItemInclude<ExtArgs> | null
    where?: CartItemWhereInput
    orderBy?: CartItemOrderByWithRelationInput | CartItemOrderByWithRelationInput[]
    cursor?: CartItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartItemScalarFieldEnum | CartItemScalarFieldEnum[]
  }

  /**
   * ChatProduct.orderItems
   */
  export type ChatProduct$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * ChatProduct without action
   */
  export type ChatProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
  }


  /**
   * Model ChatProductImage
   */

  export type AggregateChatProductImage = {
    _count: ChatProductImageCountAggregateOutputType | null
    _avg: ChatProductImageAvgAggregateOutputType | null
    _sum: ChatProductImageSumAggregateOutputType | null
    _min: ChatProductImageMinAggregateOutputType | null
    _max: ChatProductImageMaxAggregateOutputType | null
  }

  export type ChatProductImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChatProductImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChatProductImageMinAggregateOutputType = {
    id: string | null
    chatProductId: string | null
    url: string | null
    alt: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ChatProductImageMaxAggregateOutputType = {
    id: string | null
    chatProductId: string | null
    url: string | null
    alt: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ChatProductImageCountAggregateOutputType = {
    id: number
    chatProductId: number
    url: number
    alt: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type ChatProductImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChatProductImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChatProductImageMinAggregateInputType = {
    id?: true
    chatProductId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ChatProductImageMaxAggregateInputType = {
    id?: true
    chatProductId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ChatProductImageCountAggregateInputType = {
    id?: true
    chatProductId?: true
    url?: true
    alt?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type ChatProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatProductImage to aggregate.
     */
    where?: ChatProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProductImages to fetch.
     */
    orderBy?: ChatProductImageOrderByWithRelationInput | ChatProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatProductImages
    **/
    _count?: true | ChatProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatProductImageMaxAggregateInputType
  }

  export type GetChatProductImageAggregateType<T extends ChatProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatProductImage[P]>
      : GetScalarType<T[P], AggregateChatProductImage[P]>
  }




  export type ChatProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatProductImageWhereInput
    orderBy?: ChatProductImageOrderByWithAggregationInput | ChatProductImageOrderByWithAggregationInput[]
    by: ChatProductImageScalarFieldEnum[] | ChatProductImageScalarFieldEnum
    having?: ChatProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatProductImageCountAggregateInputType | true
    _avg?: ChatProductImageAvgAggregateInputType
    _sum?: ChatProductImageSumAggregateInputType
    _min?: ChatProductImageMinAggregateInputType
    _max?: ChatProductImageMaxAggregateInputType
  }

  export type ChatProductImageGroupByOutputType = {
    id: string
    chatProductId: string
    url: string
    alt: string | null
    sortOrder: number
    createdAt: Date
    _count: ChatProductImageCountAggregateOutputType | null
    _avg: ChatProductImageAvgAggregateOutputType | null
    _sum: ChatProductImageSumAggregateOutputType | null
    _min: ChatProductImageMinAggregateOutputType | null
    _max: ChatProductImageMaxAggregateOutputType | null
  }

  type GetChatProductImageGroupByPayload<T extends ChatProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ChatProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatProductId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProductImage"]>

  export type ChatProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatProductId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProductImage"]>

  export type ChatProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatProductId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatProductImage"]>

  export type ChatProductImageSelectScalar = {
    id?: boolean
    chatProductId?: boolean
    url?: boolean
    alt?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type ChatProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatProductId" | "url" | "alt" | "sortOrder" | "createdAt", ExtArgs["result"]["chatProductImage"]>
  export type ChatProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }
  export type ChatProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }
  export type ChatProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatProduct?: boolean | ChatProductDefaultArgs<ExtArgs>
  }

  export type $ChatProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatProductImage"
    objects: {
      chatProduct: Prisma.$ChatProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatProductId: string
      url: string
      alt: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["chatProductImage"]>
    composites: {}
  }

  type ChatProductImageGetPayload<S extends boolean | null | undefined | ChatProductImageDefaultArgs> = $Result.GetResult<Prisma.$ChatProductImagePayload, S>

  type ChatProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatProductImageCountAggregateInputType | true
    }

  export interface ChatProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatProductImage'], meta: { name: 'ChatProductImage' } }
    /**
     * Find zero or one ChatProductImage that matches the filter.
     * @param {ChatProductImageFindUniqueArgs} args - Arguments to find a ChatProductImage
     * @example
     * // Get one ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatProductImageFindUniqueArgs>(args: SelectSubset<T, ChatProductImageFindUniqueArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatProductImageFindUniqueOrThrowArgs} args - Arguments to find a ChatProductImage
     * @example
     * // Get one ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageFindFirstArgs} args - Arguments to find a ChatProductImage
     * @example
     * // Get one ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatProductImageFindFirstArgs>(args?: SelectSubset<T, ChatProductImageFindFirstArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageFindFirstOrThrowArgs} args - Arguments to find a ChatProductImage
     * @example
     * // Get one ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatProductImages
     * const chatProductImages = await prisma.chatProductImage.findMany()
     * 
     * // Get first 10 ChatProductImages
     * const chatProductImages = await prisma.chatProductImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatProductImageWithIdOnly = await prisma.chatProductImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatProductImageFindManyArgs>(args?: SelectSubset<T, ChatProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatProductImage.
     * @param {ChatProductImageCreateArgs} args - Arguments to create a ChatProductImage.
     * @example
     * // Create one ChatProductImage
     * const ChatProductImage = await prisma.chatProductImage.create({
     *   data: {
     *     // ... data to create a ChatProductImage
     *   }
     * })
     * 
     */
    create<T extends ChatProductImageCreateArgs>(args: SelectSubset<T, ChatProductImageCreateArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatProductImages.
     * @param {ChatProductImageCreateManyArgs} args - Arguments to create many ChatProductImages.
     * @example
     * // Create many ChatProductImages
     * const chatProductImage = await prisma.chatProductImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatProductImageCreateManyArgs>(args?: SelectSubset<T, ChatProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatProductImages and returns the data saved in the database.
     * @param {ChatProductImageCreateManyAndReturnArgs} args - Arguments to create many ChatProductImages.
     * @example
     * // Create many ChatProductImages
     * const chatProductImage = await prisma.chatProductImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatProductImages and only return the `id`
     * const chatProductImageWithIdOnly = await prisma.chatProductImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatProductImage.
     * @param {ChatProductImageDeleteArgs} args - Arguments to delete one ChatProductImage.
     * @example
     * // Delete one ChatProductImage
     * const ChatProductImage = await prisma.chatProductImage.delete({
     *   where: {
     *     // ... filter to delete one ChatProductImage
     *   }
     * })
     * 
     */
    delete<T extends ChatProductImageDeleteArgs>(args: SelectSubset<T, ChatProductImageDeleteArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatProductImage.
     * @param {ChatProductImageUpdateArgs} args - Arguments to update one ChatProductImage.
     * @example
     * // Update one ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatProductImageUpdateArgs>(args: SelectSubset<T, ChatProductImageUpdateArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatProductImages.
     * @param {ChatProductImageDeleteManyArgs} args - Arguments to filter ChatProductImages to delete.
     * @example
     * // Delete a few ChatProductImages
     * const { count } = await prisma.chatProductImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatProductImageDeleteManyArgs>(args?: SelectSubset<T, ChatProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatProductImages
     * const chatProductImage = await prisma.chatProductImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatProductImageUpdateManyArgs>(args: SelectSubset<T, ChatProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatProductImages and returns the data updated in the database.
     * @param {ChatProductImageUpdateManyAndReturnArgs} args - Arguments to update many ChatProductImages.
     * @example
     * // Update many ChatProductImages
     * const chatProductImage = await prisma.chatProductImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatProductImages and only return the `id`
     * const chatProductImageWithIdOnly = await prisma.chatProductImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatProductImage.
     * @param {ChatProductImageUpsertArgs} args - Arguments to update or create a ChatProductImage.
     * @example
     * // Update or create a ChatProductImage
     * const chatProductImage = await prisma.chatProductImage.upsert({
     *   create: {
     *     // ... data to create a ChatProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ChatProductImageUpsertArgs>(args: SelectSubset<T, ChatProductImageUpsertArgs<ExtArgs>>): Prisma__ChatProductImageClient<$Result.GetResult<Prisma.$ChatProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageCountArgs} args - Arguments to filter ChatProductImages to count.
     * @example
     * // Count the number of ChatProductImages
     * const count = await prisma.chatProductImage.count({
     *   where: {
     *     // ... the filter for the ChatProductImages we want to count
     *   }
     * })
    **/
    count<T extends ChatProductImageCountArgs>(
      args?: Subset<T, ChatProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatProductImageAggregateArgs>(args: Subset<T, ChatProductImageAggregateArgs>): Prisma.PrismaPromise<GetChatProductImageAggregateType<T>>

    /**
     * Group by ChatProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ChatProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatProductImage model
   */
  readonly fields: ChatProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatProduct<T extends ChatProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatProductDefaultArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatProductImage model
   */
  interface ChatProductImageFieldRefs {
    readonly id: FieldRef<"ChatProductImage", 'String'>
    readonly chatProductId: FieldRef<"ChatProductImage", 'String'>
    readonly url: FieldRef<"ChatProductImage", 'String'>
    readonly alt: FieldRef<"ChatProductImage", 'String'>
    readonly sortOrder: FieldRef<"ChatProductImage", 'Int'>
    readonly createdAt: FieldRef<"ChatProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatProductImage findUnique
   */
  export type ChatProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ChatProductImage to fetch.
     */
    where: ChatProductImageWhereUniqueInput
  }

  /**
   * ChatProductImage findUniqueOrThrow
   */
  export type ChatProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ChatProductImage to fetch.
     */
    where: ChatProductImageWhereUniqueInput
  }

  /**
   * ChatProductImage findFirst
   */
  export type ChatProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ChatProductImage to fetch.
     */
    where?: ChatProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProductImages to fetch.
     */
    orderBy?: ChatProductImageOrderByWithRelationInput | ChatProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatProductImages.
     */
    cursor?: ChatProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatProductImages.
     */
    distinct?: ChatProductImageScalarFieldEnum | ChatProductImageScalarFieldEnum[]
  }

  /**
   * ChatProductImage findFirstOrThrow
   */
  export type ChatProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ChatProductImage to fetch.
     */
    where?: ChatProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProductImages to fetch.
     */
    orderBy?: ChatProductImageOrderByWithRelationInput | ChatProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatProductImages.
     */
    cursor?: ChatProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatProductImages.
     */
    distinct?: ChatProductImageScalarFieldEnum | ChatProductImageScalarFieldEnum[]
  }

  /**
   * ChatProductImage findMany
   */
  export type ChatProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ChatProductImages to fetch.
     */
    where?: ChatProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatProductImages to fetch.
     */
    orderBy?: ChatProductImageOrderByWithRelationInput | ChatProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatProductImages.
     */
    cursor?: ChatProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatProductImages.
     */
    skip?: number
    distinct?: ChatProductImageScalarFieldEnum | ChatProductImageScalarFieldEnum[]
  }

  /**
   * ChatProductImage create
   */
  export type ChatProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatProductImage.
     */
    data: XOR<ChatProductImageCreateInput, ChatProductImageUncheckedCreateInput>
  }

  /**
   * ChatProductImage createMany
   */
  export type ChatProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatProductImages.
     */
    data: ChatProductImageCreateManyInput | ChatProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatProductImage createManyAndReturn
   */
  export type ChatProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatProductImages.
     */
    data: ChatProductImageCreateManyInput | ChatProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatProductImage update
   */
  export type ChatProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatProductImage.
     */
    data: XOR<ChatProductImageUpdateInput, ChatProductImageUncheckedUpdateInput>
    /**
     * Choose, which ChatProductImage to update.
     */
    where: ChatProductImageWhereUniqueInput
  }

  /**
   * ChatProductImage updateMany
   */
  export type ChatProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatProductImages.
     */
    data: XOR<ChatProductImageUpdateManyMutationInput, ChatProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ChatProductImages to update
     */
    where?: ChatProductImageWhereInput
    /**
     * Limit how many ChatProductImages to update.
     */
    limit?: number
  }

  /**
   * ChatProductImage updateManyAndReturn
   */
  export type ChatProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ChatProductImages.
     */
    data: XOR<ChatProductImageUpdateManyMutationInput, ChatProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ChatProductImages to update
     */
    where?: ChatProductImageWhereInput
    /**
     * Limit how many ChatProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatProductImage upsert
   */
  export type ChatProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatProductImage to update in case it exists.
     */
    where: ChatProductImageWhereUniqueInput
    /**
     * In case the ChatProductImage found by the `where` argument doesn't exist, create a new ChatProductImage with this data.
     */
    create: XOR<ChatProductImageCreateInput, ChatProductImageUncheckedCreateInput>
    /**
     * In case the ChatProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatProductImageUpdateInput, ChatProductImageUncheckedUpdateInput>
  }

  /**
   * ChatProductImage delete
   */
  export type ChatProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
    /**
     * Filter which ChatProductImage to delete.
     */
    where: ChatProductImageWhereUniqueInput
  }

  /**
   * ChatProductImage deleteMany
   */
  export type ChatProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatProductImages to delete
     */
    where?: ChatProductImageWhereInput
    /**
     * Limit how many ChatProductImages to delete.
     */
    limit?: number
  }

  /**
   * ChatProductImage without action
   */
  export type ChatProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProductImage
     */
    select?: ChatProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProductImage
     */
    omit?: ChatProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductImageInclude<ExtArgs> | null
  }


  /**
   * Model ChatStatus
   */

  export type AggregateChatStatus = {
    _count: ChatStatusCountAggregateOutputType | null
    _avg: ChatStatusAvgAggregateOutputType | null
    _sum: ChatStatusSumAggregateOutputType | null
    _min: ChatStatusMinAggregateOutputType | null
    _max: ChatStatusMaxAggregateOutputType | null
  }

  export type ChatStatusAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChatStatusSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChatStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    color: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChatStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    color: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChatStatusCountAggregateOutputType = {
    id: number
    name: number
    code: number
    color: number
    sortOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ChatStatusAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChatStatusSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChatStatusMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ChatStatusMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type ChatStatusCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ChatStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatStatus to aggregate.
     */
    where?: ChatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatStatuses to fetch.
     */
    orderBy?: ChatStatusOrderByWithRelationInput | ChatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatStatuses
    **/
    _count?: true | ChatStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatStatusMaxAggregateInputType
  }

  export type GetChatStatusAggregateType<T extends ChatStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateChatStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatStatus[P]>
      : GetScalarType<T[P], AggregateChatStatus[P]>
  }




  export type ChatStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatStatusWhereInput
    orderBy?: ChatStatusOrderByWithAggregationInput | ChatStatusOrderByWithAggregationInput[]
    by: ChatStatusScalarFieldEnum[] | ChatStatusScalarFieldEnum
    having?: ChatStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatStatusCountAggregateInputType | true
    _avg?: ChatStatusAvgAggregateInputType
    _sum?: ChatStatusSumAggregateInputType
    _min?: ChatStatusMinAggregateInputType
    _max?: ChatStatusMaxAggregateInputType
  }

  export type ChatStatusGroupByOutputType = {
    id: string
    name: string
    code: string
    color: string | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    _count: ChatStatusCountAggregateOutputType | null
    _avg: ChatStatusAvgAggregateOutputType | null
    _sum: ChatStatusSumAggregateOutputType | null
    _min: ChatStatusMinAggregateOutputType | null
    _max: ChatStatusMaxAggregateOutputType | null
  }

  type GetChatStatusGroupByPayload<T extends ChatStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatStatusGroupByOutputType[P]>
            : GetScalarType<T[P], ChatStatusGroupByOutputType[P]>
        }
      >
    >


  export type ChatStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    chats?: boolean | ChatStatus$chatsArgs<ExtArgs>
    _count?: boolean | ChatStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatStatus"]>

  export type ChatStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["chatStatus"]>

  export type ChatStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["chatStatus"]>

  export type ChatStatusSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ChatStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "color" | "sortOrder" | "isActive" | "createdAt", ExtArgs["result"]["chatStatus"]>
  export type ChatStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | ChatStatus$chatsArgs<ExtArgs>
    _count?: boolean | ChatStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChatStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChatStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatStatus"
    objects: {
      chats: Prisma.$ChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      color: string | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["chatStatus"]>
    composites: {}
  }

  type ChatStatusGetPayload<S extends boolean | null | undefined | ChatStatusDefaultArgs> = $Result.GetResult<Prisma.$ChatStatusPayload, S>

  type ChatStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatStatusCountAggregateInputType | true
    }

  export interface ChatStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatStatus'], meta: { name: 'ChatStatus' } }
    /**
     * Find zero or one ChatStatus that matches the filter.
     * @param {ChatStatusFindUniqueArgs} args - Arguments to find a ChatStatus
     * @example
     * // Get one ChatStatus
     * const chatStatus = await prisma.chatStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatStatusFindUniqueArgs>(args: SelectSubset<T, ChatStatusFindUniqueArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatStatusFindUniqueOrThrowArgs} args - Arguments to find a ChatStatus
     * @example
     * // Get one ChatStatus
     * const chatStatus = await prisma.chatStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusFindFirstArgs} args - Arguments to find a ChatStatus
     * @example
     * // Get one ChatStatus
     * const chatStatus = await prisma.chatStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatStatusFindFirstArgs>(args?: SelectSubset<T, ChatStatusFindFirstArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusFindFirstOrThrowArgs} args - Arguments to find a ChatStatus
     * @example
     * // Get one ChatStatus
     * const chatStatus = await prisma.chatStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatStatuses
     * const chatStatuses = await prisma.chatStatus.findMany()
     * 
     * // Get first 10 ChatStatuses
     * const chatStatuses = await prisma.chatStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatStatusWithIdOnly = await prisma.chatStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatStatusFindManyArgs>(args?: SelectSubset<T, ChatStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatStatus.
     * @param {ChatStatusCreateArgs} args - Arguments to create a ChatStatus.
     * @example
     * // Create one ChatStatus
     * const ChatStatus = await prisma.chatStatus.create({
     *   data: {
     *     // ... data to create a ChatStatus
     *   }
     * })
     * 
     */
    create<T extends ChatStatusCreateArgs>(args: SelectSubset<T, ChatStatusCreateArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatStatuses.
     * @param {ChatStatusCreateManyArgs} args - Arguments to create many ChatStatuses.
     * @example
     * // Create many ChatStatuses
     * const chatStatus = await prisma.chatStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatStatusCreateManyArgs>(args?: SelectSubset<T, ChatStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatStatuses and returns the data saved in the database.
     * @param {ChatStatusCreateManyAndReturnArgs} args - Arguments to create many ChatStatuses.
     * @example
     * // Create many ChatStatuses
     * const chatStatus = await prisma.chatStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatStatuses and only return the `id`
     * const chatStatusWithIdOnly = await prisma.chatStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatStatus.
     * @param {ChatStatusDeleteArgs} args - Arguments to delete one ChatStatus.
     * @example
     * // Delete one ChatStatus
     * const ChatStatus = await prisma.chatStatus.delete({
     *   where: {
     *     // ... filter to delete one ChatStatus
     *   }
     * })
     * 
     */
    delete<T extends ChatStatusDeleteArgs>(args: SelectSubset<T, ChatStatusDeleteArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatStatus.
     * @param {ChatStatusUpdateArgs} args - Arguments to update one ChatStatus.
     * @example
     * // Update one ChatStatus
     * const chatStatus = await prisma.chatStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatStatusUpdateArgs>(args: SelectSubset<T, ChatStatusUpdateArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatStatuses.
     * @param {ChatStatusDeleteManyArgs} args - Arguments to filter ChatStatuses to delete.
     * @example
     * // Delete a few ChatStatuses
     * const { count } = await prisma.chatStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatStatusDeleteManyArgs>(args?: SelectSubset<T, ChatStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatStatuses
     * const chatStatus = await prisma.chatStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatStatusUpdateManyArgs>(args: SelectSubset<T, ChatStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatStatuses and returns the data updated in the database.
     * @param {ChatStatusUpdateManyAndReturnArgs} args - Arguments to update many ChatStatuses.
     * @example
     * // Update many ChatStatuses
     * const chatStatus = await prisma.chatStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatStatuses and only return the `id`
     * const chatStatusWithIdOnly = await prisma.chatStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatStatus.
     * @param {ChatStatusUpsertArgs} args - Arguments to update or create a ChatStatus.
     * @example
     * // Update or create a ChatStatus
     * const chatStatus = await prisma.chatStatus.upsert({
     *   create: {
     *     // ... data to create a ChatStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatStatus we want to update
     *   }
     * })
     */
    upsert<T extends ChatStatusUpsertArgs>(args: SelectSubset<T, ChatStatusUpsertArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusCountArgs} args - Arguments to filter ChatStatuses to count.
     * @example
     * // Count the number of ChatStatuses
     * const count = await prisma.chatStatus.count({
     *   where: {
     *     // ... the filter for the ChatStatuses we want to count
     *   }
     * })
    **/
    count<T extends ChatStatusCountArgs>(
      args?: Subset<T, ChatStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatStatusAggregateArgs>(args: Subset<T, ChatStatusAggregateArgs>): Prisma.PrismaPromise<GetChatStatusAggregateType<T>>

    /**
     * Group by ChatStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatStatusGroupByArgs['orderBy'] }
        : { orderBy?: ChatStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatStatus model
   */
  readonly fields: ChatStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends ChatStatus$chatsArgs<ExtArgs> = {}>(args?: Subset<T, ChatStatus$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatStatus model
   */
  interface ChatStatusFieldRefs {
    readonly id: FieldRef<"ChatStatus", 'String'>
    readonly name: FieldRef<"ChatStatus", 'String'>
    readonly code: FieldRef<"ChatStatus", 'String'>
    readonly color: FieldRef<"ChatStatus", 'String'>
    readonly sortOrder: FieldRef<"ChatStatus", 'Int'>
    readonly isActive: FieldRef<"ChatStatus", 'Boolean'>
    readonly createdAt: FieldRef<"ChatStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatStatus findUnique
   */
  export type ChatStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatStatus to fetch.
     */
    where: ChatStatusWhereUniqueInput
  }

  /**
   * ChatStatus findUniqueOrThrow
   */
  export type ChatStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatStatus to fetch.
     */
    where: ChatStatusWhereUniqueInput
  }

  /**
   * ChatStatus findFirst
   */
  export type ChatStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatStatus to fetch.
     */
    where?: ChatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatStatuses to fetch.
     */
    orderBy?: ChatStatusOrderByWithRelationInput | ChatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatStatuses.
     */
    cursor?: ChatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatStatuses.
     */
    distinct?: ChatStatusScalarFieldEnum | ChatStatusScalarFieldEnum[]
  }

  /**
   * ChatStatus findFirstOrThrow
   */
  export type ChatStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatStatus to fetch.
     */
    where?: ChatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatStatuses to fetch.
     */
    orderBy?: ChatStatusOrderByWithRelationInput | ChatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatStatuses.
     */
    cursor?: ChatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatStatuses.
     */
    distinct?: ChatStatusScalarFieldEnum | ChatStatusScalarFieldEnum[]
  }

  /**
   * ChatStatus findMany
   */
  export type ChatStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter, which ChatStatuses to fetch.
     */
    where?: ChatStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatStatuses to fetch.
     */
    orderBy?: ChatStatusOrderByWithRelationInput | ChatStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatStatuses.
     */
    cursor?: ChatStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatStatuses.
     */
    skip?: number
    distinct?: ChatStatusScalarFieldEnum | ChatStatusScalarFieldEnum[]
  }

  /**
   * ChatStatus create
   */
  export type ChatStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatStatus.
     */
    data: XOR<ChatStatusCreateInput, ChatStatusUncheckedCreateInput>
  }

  /**
   * ChatStatus createMany
   */
  export type ChatStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatStatuses.
     */
    data: ChatStatusCreateManyInput | ChatStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatStatus createManyAndReturn
   */
  export type ChatStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * The data used to create many ChatStatuses.
     */
    data: ChatStatusCreateManyInput | ChatStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatStatus update
   */
  export type ChatStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatStatus.
     */
    data: XOR<ChatStatusUpdateInput, ChatStatusUncheckedUpdateInput>
    /**
     * Choose, which ChatStatus to update.
     */
    where: ChatStatusWhereUniqueInput
  }

  /**
   * ChatStatus updateMany
   */
  export type ChatStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatStatuses.
     */
    data: XOR<ChatStatusUpdateManyMutationInput, ChatStatusUncheckedUpdateManyInput>
    /**
     * Filter which ChatStatuses to update
     */
    where?: ChatStatusWhereInput
    /**
     * Limit how many ChatStatuses to update.
     */
    limit?: number
  }

  /**
   * ChatStatus updateManyAndReturn
   */
  export type ChatStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * The data used to update ChatStatuses.
     */
    data: XOR<ChatStatusUpdateManyMutationInput, ChatStatusUncheckedUpdateManyInput>
    /**
     * Filter which ChatStatuses to update
     */
    where?: ChatStatusWhereInput
    /**
     * Limit how many ChatStatuses to update.
     */
    limit?: number
  }

  /**
   * ChatStatus upsert
   */
  export type ChatStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatStatus to update in case it exists.
     */
    where: ChatStatusWhereUniqueInput
    /**
     * In case the ChatStatus found by the `where` argument doesn't exist, create a new ChatStatus with this data.
     */
    create: XOR<ChatStatusCreateInput, ChatStatusUncheckedCreateInput>
    /**
     * In case the ChatStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatStatusUpdateInput, ChatStatusUncheckedUpdateInput>
  }

  /**
   * ChatStatus delete
   */
  export type ChatStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
    /**
     * Filter which ChatStatus to delete.
     */
    where: ChatStatusWhereUniqueInput
  }

  /**
   * ChatStatus deleteMany
   */
  export type ChatStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatStatuses to delete
     */
    where?: ChatStatusWhereInput
    /**
     * Limit how many ChatStatuses to delete.
     */
    limit?: number
  }

  /**
   * ChatStatus.chats
   */
  export type ChatStatus$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * ChatStatus without action
   */
  export type ChatStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatStatus
     */
    select?: ChatStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatStatus
     */
    omit?: ChatStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatStatusInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    managerId: string | null
    statusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    managerId: string | null
    statusId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    userId: number
    anonymousId: number
    managerId: number
    statusId: number
    createdAt: number
    updatedAt: number
    closedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    managerId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    managerId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    managerId?: true
    statusId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    userId: string | null
    anonymousId: string | null
    managerId: string | null
    statusId: string
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    managerId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    managerId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    managerId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    managerId?: boolean
    statusId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonymousId" | "managerId" | "statusId" | "createdAt" | "updatedAt" | "closedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chat$userArgs<ExtArgs>
    anonymousUser?: boolean | Chat$anonymousUserArgs<ExtArgs>
    manager?: boolean | Chat$managerArgs<ExtArgs>
    status?: boolean | ChatStatusDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      anonymousUser: Prisma.$AnonymousUserPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
      status: Prisma.$ChatStatusPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonymousId: string | null
      managerId: string | null
      statusId: string
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Chat$userArgs<ExtArgs> = {}>(args?: Subset<T, Chat$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    anonymousUser<T extends Chat$anonymousUserArgs<ExtArgs> = {}>(args?: Subset<T, Chat$anonymousUserArgs<ExtArgs>>): Prisma__AnonymousUserClient<$Result.GetResult<Prisma.$AnonymousUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends Chat$managerArgs<ExtArgs> = {}>(args?: Subset<T, Chat$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    status<T extends ChatStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatStatusDefaultArgs<ExtArgs>>): Prisma__ChatStatusClient<$Result.GetResult<Prisma.$ChatStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly userId: FieldRef<"Chat", 'String'>
    readonly anonymousId: FieldRef<"Chat", 'String'>
    readonly managerId: FieldRef<"Chat", 'String'>
    readonly statusId: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
    readonly closedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.user
   */
  export type Chat$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Chat.anonymousUser
   */
  export type Chat$anonymousUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnonymousUser
     */
    select?: AnonymousUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnonymousUser
     */
    omit?: AnonymousUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnonymousUserInclude<ExtArgs> | null
    where?: AnonymousUserWhereInput
  }

  /**
   * Chat.manager
   */
  export type Chat$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    messageType: $Enums.MessageType | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    senderId: string | null
    senderType: $Enums.SenderType | null
    messageType: $Enums.MessageType | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    chatId: number
    senderId: number
    senderType: number
    messageType: number
    content: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    messageType?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    messageType?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    chatId?: true
    senderId?: true
    senderType?: true
    messageType?: true
    content?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    chatId: string
    senderId: string | null
    senderType: $Enums.SenderType
    messageType: $Enums.MessageType
    content: string
    metadata: JsonValue | null
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    messageType?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    chatProducts?: boolean | Message$chatProductsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    messageType?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    messageType?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    senderId?: boolean
    senderType?: boolean
    messageType?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "senderId" | "senderType" | "messageType" | "content" | "metadata" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    chatProducts?: boolean | Message$chatProductsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      chatProducts: Prisma.$ChatProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      senderId: string | null
      senderType: $Enums.SenderType
      messageType: $Enums.MessageType
      content: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chatProducts<T extends Message$chatProductsArgs<ExtArgs> = {}>(args?: Subset<T, Message$chatProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderType: FieldRef<"Message", 'SenderType'>
    readonly messageType: FieldRef<"Message", 'MessageType'>
    readonly content: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.chatProducts
   */
  export type Message$chatProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    where?: ChatProductWhereInput
    orderBy?: ChatProductOrderByWithRelationInput | ChatProductOrderByWithRelationInput[]
    cursor?: ChatProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatProductScalarFieldEnum | ChatProductScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatus
   */

  export type AggregateOrderStatus = {
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  export type OrderStatusAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type OrderStatusSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type OrderStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    color: string | null
    description: string | null
    isInitial: boolean | null
    isFinalSuccess: boolean | null
    isFinalFailure: boolean | null
    canCancelOrder: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OrderStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    color: string | null
    description: string | null
    isInitial: boolean | null
    isFinalSuccess: boolean | null
    isFinalFailure: boolean | null
    canCancelOrder: boolean | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type OrderStatusCountAggregateOutputType = {
    id: number
    name: number
    code: number
    color: number
    description: number
    isInitial: number
    isFinalSuccess: number
    isFinalFailure: number
    canCancelOrder: number
    sortOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type OrderStatusAvgAggregateInputType = {
    sortOrder?: true
  }

  export type OrderStatusSumAggregateInputType = {
    sortOrder?: true
  }

  export type OrderStatusMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    description?: true
    isInitial?: true
    isFinalSuccess?: true
    isFinalFailure?: true
    canCancelOrder?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type OrderStatusMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    description?: true
    isInitial?: true
    isFinalSuccess?: true
    isFinalFailure?: true
    canCancelOrder?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type OrderStatusCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    color?: true
    description?: true
    isInitial?: true
    isFinalSuccess?: true
    isFinalFailure?: true
    canCancelOrder?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type OrderStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatus to aggregate.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatuses
    **/
    _count?: true | OrderStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusMaxAggregateInputType
  }

  export type GetOrderStatusAggregateType<T extends OrderStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatus[P]>
      : GetScalarType<T[P], AggregateOrderStatus[P]>
  }




  export type OrderStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusWhereInput
    orderBy?: OrderStatusOrderByWithAggregationInput | OrderStatusOrderByWithAggregationInput[]
    by: OrderStatusScalarFieldEnum[] | OrderStatusScalarFieldEnum
    having?: OrderStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusCountAggregateInputType | true
    _avg?: OrderStatusAvgAggregateInputType
    _sum?: OrderStatusSumAggregateInputType
    _min?: OrderStatusMinAggregateInputType
    _max?: OrderStatusMaxAggregateInputType
  }

  export type OrderStatusGroupByOutputType = {
    id: string
    name: string
    code: string
    color: string | null
    description: string | null
    isInitial: boolean
    isFinalSuccess: boolean
    isFinalFailure: boolean
    canCancelOrder: boolean
    sortOrder: number
    isActive: boolean
    createdAt: Date
    _count: OrderStatusCountAggregateOutputType | null
    _avg: OrderStatusAvgAggregateOutputType | null
    _sum: OrderStatusSumAggregateOutputType | null
    _min: OrderStatusMinAggregateOutputType | null
    _max: OrderStatusMaxAggregateOutputType | null
  }

  type GetOrderStatusGroupByPayload<T extends OrderStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    description?: boolean
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    orderLogs?: boolean | OrderStatus$orderLogsArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatus"]>

  export type OrderStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    description?: boolean
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["orderStatus"]>

  export type OrderStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    description?: boolean
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["orderStatus"]>

  export type OrderStatusSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    color?: boolean
    description?: boolean
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type OrderStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "color" | "description" | "isInitial" | "isFinalSuccess" | "isFinalFailure" | "canCancelOrder" | "sortOrder" | "isActive" | "createdAt", ExtArgs["result"]["orderStatus"]>
  export type OrderStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderStatus$ordersArgs<ExtArgs>
    orderLogs?: boolean | OrderStatus$orderLogsArgs<ExtArgs>
    _count?: boolean | OrderStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrderStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatus"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      orderLogs: Prisma.$OrderStatusLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      color: string | null
      description: string | null
      isInitial: boolean
      isFinalSuccess: boolean
      isFinalFailure: boolean
      canCancelOrder: boolean
      sortOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["orderStatus"]>
    composites: {}
  }

  type OrderStatusGetPayload<S extends boolean | null | undefined | OrderStatusDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusPayload, S>

  type OrderStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStatusCountAggregateInputType | true
    }

  export interface OrderStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatus'], meta: { name: 'OrderStatus' } }
    /**
     * Find zero or one OrderStatus that matches the filter.
     * @param {OrderStatusFindUniqueArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusFindUniqueArgs>(args: SelectSubset<T, OrderStatusFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStatusFindUniqueOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusFindFirstArgs>(args?: SelectSubset<T, OrderStatusFindFirstArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindFirstOrThrowArgs} args - Arguments to find a OrderStatus
     * @example
     * // Get one OrderStatus
     * const orderStatus = await prisma.orderStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany()
     * 
     * // Get first 10 OrderStatuses
     * const orderStatuses = await prisma.orderStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStatusFindManyArgs>(args?: SelectSubset<T, OrderStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStatus.
     * @param {OrderStatusCreateArgs} args - Arguments to create a OrderStatus.
     * @example
     * // Create one OrderStatus
     * const OrderStatus = await prisma.orderStatus.create({
     *   data: {
     *     // ... data to create a OrderStatus
     *   }
     * })
     * 
     */
    create<T extends OrderStatusCreateArgs>(args: SelectSubset<T, OrderStatusCreateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderStatuses.
     * @param {OrderStatusCreateManyArgs} args - Arguments to create many OrderStatuses.
     * @example
     * // Create many OrderStatuses
     * const orderStatus = await prisma.orderStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusCreateManyArgs>(args?: SelectSubset<T, OrderStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderStatuses and returns the data saved in the database.
     * @param {OrderStatusCreateManyAndReturnArgs} args - Arguments to create many OrderStatuses.
     * @example
     * // Create many OrderStatuses
     * const orderStatus = await prisma.orderStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderStatuses and only return the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderStatus.
     * @param {OrderStatusDeleteArgs} args - Arguments to delete one OrderStatus.
     * @example
     * // Delete one OrderStatus
     * const OrderStatus = await prisma.orderStatus.delete({
     *   where: {
     *     // ... filter to delete one OrderStatus
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusDeleteArgs>(args: SelectSubset<T, OrderStatusDeleteArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStatus.
     * @param {OrderStatusUpdateArgs} args - Arguments to update one OrderStatus.
     * @example
     * // Update one OrderStatus
     * const orderStatus = await prisma.orderStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusUpdateArgs>(args: SelectSubset<T, OrderStatusUpdateArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderStatuses.
     * @param {OrderStatusDeleteManyArgs} args - Arguments to filter OrderStatuses to delete.
     * @example
     * // Delete a few OrderStatuses
     * const { count } = await prisma.orderStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusDeleteManyArgs>(args?: SelectSubset<T, OrderStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusUpdateManyArgs>(args: SelectSubset<T, OrderStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatuses and returns the data updated in the database.
     * @param {OrderStatusUpdateManyAndReturnArgs} args - Arguments to update many OrderStatuses.
     * @example
     * // Update many OrderStatuses
     * const orderStatus = await prisma.orderStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderStatuses and only return the `id`
     * const orderStatusWithIdOnly = await prisma.orderStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderStatus.
     * @param {OrderStatusUpsertArgs} args - Arguments to update or create a OrderStatus.
     * @example
     * // Update or create a OrderStatus
     * const orderStatus = await prisma.orderStatus.upsert({
     *   create: {
     *     // ... data to create a OrderStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatus we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusUpsertArgs>(args: SelectSubset<T, OrderStatusUpsertArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusCountArgs} args - Arguments to filter OrderStatuses to count.
     * @example
     * // Count the number of OrderStatuses
     * const count = await prisma.orderStatus.count({
     *   where: {
     *     // ... the filter for the OrderStatuses we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusCountArgs>(
      args?: Subset<T, OrderStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusAggregateArgs>(args: Subset<T, OrderStatusAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusAggregateType<T>>

    /**
     * Group by OrderStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatus model
   */
  readonly fields: OrderStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends OrderStatus$ordersArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatus$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderLogs<T extends OrderStatus$orderLogsArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatus$orderLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatus model
   */
  interface OrderStatusFieldRefs {
    readonly id: FieldRef<"OrderStatus", 'String'>
    readonly name: FieldRef<"OrderStatus", 'String'>
    readonly code: FieldRef<"OrderStatus", 'String'>
    readonly color: FieldRef<"OrderStatus", 'String'>
    readonly description: FieldRef<"OrderStatus", 'String'>
    readonly isInitial: FieldRef<"OrderStatus", 'Boolean'>
    readonly isFinalSuccess: FieldRef<"OrderStatus", 'Boolean'>
    readonly isFinalFailure: FieldRef<"OrderStatus", 'Boolean'>
    readonly canCancelOrder: FieldRef<"OrderStatus", 'Boolean'>
    readonly sortOrder: FieldRef<"OrderStatus", 'Int'>
    readonly isActive: FieldRef<"OrderStatus", 'Boolean'>
    readonly createdAt: FieldRef<"OrderStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatus findUnique
   */
  export type OrderStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findUniqueOrThrow
   */
  export type OrderStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus findFirst
   */
  export type OrderStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findFirstOrThrow
   */
  export type OrderStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatus to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatuses.
     */
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus findMany
   */
  export type OrderStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatuses to fetch.
     */
    where?: OrderStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatuses to fetch.
     */
    orderBy?: OrderStatusOrderByWithRelationInput | OrderStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatuses.
     */
    cursor?: OrderStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatuses.
     */
    skip?: number
    distinct?: OrderStatusScalarFieldEnum | OrderStatusScalarFieldEnum[]
  }

  /**
   * OrderStatus create
   */
  export type OrderStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatus.
     */
    data: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
  }

  /**
   * OrderStatus createMany
   */
  export type OrderStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatuses.
     */
    data: OrderStatusCreateManyInput | OrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatus createManyAndReturn
   */
  export type OrderStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * The data used to create many OrderStatuses.
     */
    data: OrderStatusCreateManyInput | OrderStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatus update
   */
  export type OrderStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatus.
     */
    data: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
    /**
     * Choose, which OrderStatus to update.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus updateMany
   */
  export type OrderStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatuses.
     */
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderStatus updateManyAndReturn
   */
  export type OrderStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * The data used to update OrderStatuses.
     */
    data: XOR<OrderStatusUpdateManyMutationInput, OrderStatusUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatuses to update
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to update.
     */
    limit?: number
  }

  /**
   * OrderStatus upsert
   */
  export type OrderStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatus to update in case it exists.
     */
    where: OrderStatusWhereUniqueInput
    /**
     * In case the OrderStatus found by the `where` argument doesn't exist, create a new OrderStatus with this data.
     */
    create: XOR<OrderStatusCreateInput, OrderStatusUncheckedCreateInput>
    /**
     * In case the OrderStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusUpdateInput, OrderStatusUncheckedUpdateInput>
  }

  /**
   * OrderStatus delete
   */
  export type OrderStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
    /**
     * Filter which OrderStatus to delete.
     */
    where: OrderStatusWhereUniqueInput
  }

  /**
   * OrderStatus deleteMany
   */
  export type OrderStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatuses to delete
     */
    where?: OrderStatusWhereInput
    /**
     * Limit how many OrderStatuses to delete.
     */
    limit?: number
  }

  /**
   * OrderStatus.orders
   */
  export type OrderStatus$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderStatus.orderLogs
   */
  export type OrderStatus$orderLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    where?: OrderStatusLogWhereInput
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    cursor?: OrderStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * OrderStatus without action
   */
  export type OrderStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatus
     */
    select?: OrderStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatus
     */
    omit?: OrderStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryMethod
   */

  export type AggregateDeliveryMethod = {
    _count: DeliveryMethodCountAggregateOutputType | null
    _avg: DeliveryMethodAvgAggregateOutputType | null
    _sum: DeliveryMethodSumAggregateOutputType | null
    _min: DeliveryMethodMinAggregateOutputType | null
    _max: DeliveryMethodMaxAggregateOutputType | null
  }

  export type DeliveryMethodAvgAggregateOutputType = {
    price: Decimal | null
    minAmount: Decimal | null
    sortOrder: number | null
  }

  export type DeliveryMethodSumAggregateOutputType = {
    price: Decimal | null
    minAmount: Decimal | null
    sortOrder: number | null
  }

  export type DeliveryMethodMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    price: Decimal | null
    minAmount: Decimal | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type DeliveryMethodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    price: Decimal | null
    minAmount: Decimal | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type DeliveryMethodCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    price: number
    minAmount: number
    isActive: number
    sortOrder: number
    settings: number
    createdAt: number
    _all: number
  }


  export type DeliveryMethodAvgAggregateInputType = {
    price?: true
    minAmount?: true
    sortOrder?: true
  }

  export type DeliveryMethodSumAggregateInputType = {
    price?: true
    minAmount?: true
    sortOrder?: true
  }

  export type DeliveryMethodMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    price?: true
    minAmount?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type DeliveryMethodMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    price?: true
    minAmount?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
  }

  export type DeliveryMethodCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    price?: true
    minAmount?: true
    isActive?: true
    sortOrder?: true
    settings?: true
    createdAt?: true
    _all?: true
  }

  export type DeliveryMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryMethod to aggregate.
     */
    where?: DeliveryMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryMethods to fetch.
     */
    orderBy?: DeliveryMethodOrderByWithRelationInput | DeliveryMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryMethods
    **/
    _count?: true | DeliveryMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMethodMaxAggregateInputType
  }

  export type GetDeliveryMethodAggregateType<T extends DeliveryMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryMethod[P]>
      : GetScalarType<T[P], AggregateDeliveryMethod[P]>
  }




  export type DeliveryMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryMethodWhereInput
    orderBy?: DeliveryMethodOrderByWithAggregationInput | DeliveryMethodOrderByWithAggregationInput[]
    by: DeliveryMethodScalarFieldEnum[] | DeliveryMethodScalarFieldEnum
    having?: DeliveryMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryMethodCountAggregateInputType | true
    _avg?: DeliveryMethodAvgAggregateInputType
    _sum?: DeliveryMethodSumAggregateInputType
    _min?: DeliveryMethodMinAggregateInputType
    _max?: DeliveryMethodMaxAggregateInputType
  }

  export type DeliveryMethodGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    price: Decimal
    minAmount: Decimal | null
    isActive: boolean
    sortOrder: number
    settings: JsonValue | null
    createdAt: Date
    _count: DeliveryMethodCountAggregateOutputType | null
    _avg: DeliveryMethodAvgAggregateOutputType | null
    _sum: DeliveryMethodSumAggregateOutputType | null
    _min: DeliveryMethodMinAggregateOutputType | null
    _max: DeliveryMethodMaxAggregateOutputType | null
  }

  type GetDeliveryMethodGroupByPayload<T extends DeliveryMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryMethodGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryMethodGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    minAmount?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    createdAt?: boolean
    orders?: boolean | DeliveryMethod$ordersArgs<ExtArgs>
    _count?: boolean | DeliveryMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryMethod"]>

  export type DeliveryMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    minAmount?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["deliveryMethod"]>

  export type DeliveryMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    minAmount?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["deliveryMethod"]>

  export type DeliveryMethodSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    price?: boolean
    minAmount?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    createdAt?: boolean
  }

  export type DeliveryMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "price" | "minAmount" | "isActive" | "sortOrder" | "settings" | "createdAt", ExtArgs["result"]["deliveryMethod"]>
  export type DeliveryMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | DeliveryMethod$ordersArgs<ExtArgs>
    _count?: boolean | DeliveryMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeliveryMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryMethod"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      price: Prisma.Decimal
      minAmount: Prisma.Decimal | null
      isActive: boolean
      sortOrder: number
      settings: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["deliveryMethod"]>
    composites: {}
  }

  type DeliveryMethodGetPayload<S extends boolean | null | undefined | DeliveryMethodDefaultArgs> = $Result.GetResult<Prisma.$DeliveryMethodPayload, S>

  type DeliveryMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryMethodCountAggregateInputType | true
    }

  export interface DeliveryMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryMethod'], meta: { name: 'DeliveryMethod' } }
    /**
     * Find zero or one DeliveryMethod that matches the filter.
     * @param {DeliveryMethodFindUniqueArgs} args - Arguments to find a DeliveryMethod
     * @example
     * // Get one DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryMethodFindUniqueArgs>(args: SelectSubset<T, DeliveryMethodFindUniqueArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryMethodFindUniqueOrThrowArgs} args - Arguments to find a DeliveryMethod
     * @example
     * // Get one DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodFindFirstArgs} args - Arguments to find a DeliveryMethod
     * @example
     * // Get one DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryMethodFindFirstArgs>(args?: SelectSubset<T, DeliveryMethodFindFirstArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodFindFirstOrThrowArgs} args - Arguments to find a DeliveryMethod
     * @example
     * // Get one DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryMethods
     * const deliveryMethods = await prisma.deliveryMethod.findMany()
     * 
     * // Get first 10 DeliveryMethods
     * const deliveryMethods = await prisma.deliveryMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryMethodWithIdOnly = await prisma.deliveryMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryMethodFindManyArgs>(args?: SelectSubset<T, DeliveryMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryMethod.
     * @param {DeliveryMethodCreateArgs} args - Arguments to create a DeliveryMethod.
     * @example
     * // Create one DeliveryMethod
     * const DeliveryMethod = await prisma.deliveryMethod.create({
     *   data: {
     *     // ... data to create a DeliveryMethod
     *   }
     * })
     * 
     */
    create<T extends DeliveryMethodCreateArgs>(args: SelectSubset<T, DeliveryMethodCreateArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryMethods.
     * @param {DeliveryMethodCreateManyArgs} args - Arguments to create many DeliveryMethods.
     * @example
     * // Create many DeliveryMethods
     * const deliveryMethod = await prisma.deliveryMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryMethodCreateManyArgs>(args?: SelectSubset<T, DeliveryMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryMethods and returns the data saved in the database.
     * @param {DeliveryMethodCreateManyAndReturnArgs} args - Arguments to create many DeliveryMethods.
     * @example
     * // Create many DeliveryMethods
     * const deliveryMethod = await prisma.deliveryMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryMethods and only return the `id`
     * const deliveryMethodWithIdOnly = await prisma.deliveryMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryMethod.
     * @param {DeliveryMethodDeleteArgs} args - Arguments to delete one DeliveryMethod.
     * @example
     * // Delete one DeliveryMethod
     * const DeliveryMethod = await prisma.deliveryMethod.delete({
     *   where: {
     *     // ... filter to delete one DeliveryMethod
     *   }
     * })
     * 
     */
    delete<T extends DeliveryMethodDeleteArgs>(args: SelectSubset<T, DeliveryMethodDeleteArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryMethod.
     * @param {DeliveryMethodUpdateArgs} args - Arguments to update one DeliveryMethod.
     * @example
     * // Update one DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryMethodUpdateArgs>(args: SelectSubset<T, DeliveryMethodUpdateArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryMethods.
     * @param {DeliveryMethodDeleteManyArgs} args - Arguments to filter DeliveryMethods to delete.
     * @example
     * // Delete a few DeliveryMethods
     * const { count } = await prisma.deliveryMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryMethodDeleteManyArgs>(args?: SelectSubset<T, DeliveryMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryMethods
     * const deliveryMethod = await prisma.deliveryMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryMethodUpdateManyArgs>(args: SelectSubset<T, DeliveryMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryMethods and returns the data updated in the database.
     * @param {DeliveryMethodUpdateManyAndReturnArgs} args - Arguments to update many DeliveryMethods.
     * @example
     * // Update many DeliveryMethods
     * const deliveryMethod = await prisma.deliveryMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryMethods and only return the `id`
     * const deliveryMethodWithIdOnly = await prisma.deliveryMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryMethod.
     * @param {DeliveryMethodUpsertArgs} args - Arguments to update or create a DeliveryMethod.
     * @example
     * // Update or create a DeliveryMethod
     * const deliveryMethod = await prisma.deliveryMethod.upsert({
     *   create: {
     *     // ... data to create a DeliveryMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryMethod we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryMethodUpsertArgs>(args: SelectSubset<T, DeliveryMethodUpsertArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodCountArgs} args - Arguments to filter DeliveryMethods to count.
     * @example
     * // Count the number of DeliveryMethods
     * const count = await prisma.deliveryMethod.count({
     *   where: {
     *     // ... the filter for the DeliveryMethods we want to count
     *   }
     * })
    **/
    count<T extends DeliveryMethodCountArgs>(
      args?: Subset<T, DeliveryMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryMethodAggregateArgs>(args: Subset<T, DeliveryMethodAggregateArgs>): Prisma.PrismaPromise<GetDeliveryMethodAggregateType<T>>

    /**
     * Group by DeliveryMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryMethodGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryMethod model
   */
  readonly fields: DeliveryMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends DeliveryMethod$ordersArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryMethod$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryMethod model
   */
  interface DeliveryMethodFieldRefs {
    readonly id: FieldRef<"DeliveryMethod", 'String'>
    readonly name: FieldRef<"DeliveryMethod", 'String'>
    readonly code: FieldRef<"DeliveryMethod", 'String'>
    readonly description: FieldRef<"DeliveryMethod", 'String'>
    readonly price: FieldRef<"DeliveryMethod", 'Decimal'>
    readonly minAmount: FieldRef<"DeliveryMethod", 'Decimal'>
    readonly isActive: FieldRef<"DeliveryMethod", 'Boolean'>
    readonly sortOrder: FieldRef<"DeliveryMethod", 'Int'>
    readonly settings: FieldRef<"DeliveryMethod", 'Json'>
    readonly createdAt: FieldRef<"DeliveryMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryMethod findUnique
   */
  export type DeliveryMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMethod to fetch.
     */
    where: DeliveryMethodWhereUniqueInput
  }

  /**
   * DeliveryMethod findUniqueOrThrow
   */
  export type DeliveryMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMethod to fetch.
     */
    where: DeliveryMethodWhereUniqueInput
  }

  /**
   * DeliveryMethod findFirst
   */
  export type DeliveryMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMethod to fetch.
     */
    where?: DeliveryMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryMethods to fetch.
     */
    orderBy?: DeliveryMethodOrderByWithRelationInput | DeliveryMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryMethods.
     */
    cursor?: DeliveryMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryMethods.
     */
    distinct?: DeliveryMethodScalarFieldEnum | DeliveryMethodScalarFieldEnum[]
  }

  /**
   * DeliveryMethod findFirstOrThrow
   */
  export type DeliveryMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMethod to fetch.
     */
    where?: DeliveryMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryMethods to fetch.
     */
    orderBy?: DeliveryMethodOrderByWithRelationInput | DeliveryMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryMethods.
     */
    cursor?: DeliveryMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryMethods.
     */
    distinct?: DeliveryMethodScalarFieldEnum | DeliveryMethodScalarFieldEnum[]
  }

  /**
   * DeliveryMethod findMany
   */
  export type DeliveryMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryMethods to fetch.
     */
    where?: DeliveryMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryMethods to fetch.
     */
    orderBy?: DeliveryMethodOrderByWithRelationInput | DeliveryMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryMethods.
     */
    cursor?: DeliveryMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryMethods.
     */
    skip?: number
    distinct?: DeliveryMethodScalarFieldEnum | DeliveryMethodScalarFieldEnum[]
  }

  /**
   * DeliveryMethod create
   */
  export type DeliveryMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryMethod.
     */
    data: XOR<DeliveryMethodCreateInput, DeliveryMethodUncheckedCreateInput>
  }

  /**
   * DeliveryMethod createMany
   */
  export type DeliveryMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryMethods.
     */
    data: DeliveryMethodCreateManyInput | DeliveryMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryMethod createManyAndReturn
   */
  export type DeliveryMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryMethods.
     */
    data: DeliveryMethodCreateManyInput | DeliveryMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryMethod update
   */
  export type DeliveryMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryMethod.
     */
    data: XOR<DeliveryMethodUpdateInput, DeliveryMethodUncheckedUpdateInput>
    /**
     * Choose, which DeliveryMethod to update.
     */
    where: DeliveryMethodWhereUniqueInput
  }

  /**
   * DeliveryMethod updateMany
   */
  export type DeliveryMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryMethods.
     */
    data: XOR<DeliveryMethodUpdateManyMutationInput, DeliveryMethodUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryMethods to update
     */
    where?: DeliveryMethodWhereInput
    /**
     * Limit how many DeliveryMethods to update.
     */
    limit?: number
  }

  /**
   * DeliveryMethod updateManyAndReturn
   */
  export type DeliveryMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryMethods.
     */
    data: XOR<DeliveryMethodUpdateManyMutationInput, DeliveryMethodUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryMethods to update
     */
    where?: DeliveryMethodWhereInput
    /**
     * Limit how many DeliveryMethods to update.
     */
    limit?: number
  }

  /**
   * DeliveryMethod upsert
   */
  export type DeliveryMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryMethod to update in case it exists.
     */
    where: DeliveryMethodWhereUniqueInput
    /**
     * In case the DeliveryMethod found by the `where` argument doesn't exist, create a new DeliveryMethod with this data.
     */
    create: XOR<DeliveryMethodCreateInput, DeliveryMethodUncheckedCreateInput>
    /**
     * In case the DeliveryMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryMethodUpdateInput, DeliveryMethodUncheckedUpdateInput>
  }

  /**
   * DeliveryMethod delete
   */
  export type DeliveryMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
    /**
     * Filter which DeliveryMethod to delete.
     */
    where: DeliveryMethodWhereUniqueInput
  }

  /**
   * DeliveryMethod deleteMany
   */
  export type DeliveryMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryMethods to delete
     */
    where?: DeliveryMethodWhereInput
    /**
     * Limit how many DeliveryMethods to delete.
     */
    limit?: number
  }

  /**
   * DeliveryMethod.orders
   */
  export type DeliveryMethod$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * DeliveryMethod without action
   */
  export type DeliveryMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryMethod
     */
    select?: DeliveryMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryMethod
     */
    omit?: DeliveryMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryMethodInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodAvgAggregateOutputType = {
    sortOrder: number | null
    commission: Decimal | null
  }

  export type PaymentMethodSumAggregateOutputType = {
    sortOrder: number | null
    commission: Decimal | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    icon: string | null
    isOnline: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    commission: Decimal | null
    createdAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    icon: string | null
    isOnline: boolean | null
    isActive: boolean | null
    sortOrder: number | null
    commission: Decimal | null
    createdAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    icon: number
    isOnline: number
    isActive: number
    sortOrder: number
    settings: number
    commission: number
    createdAt: number
    _all: number
  }


  export type PaymentMethodAvgAggregateInputType = {
    sortOrder?: true
    commission?: true
  }

  export type PaymentMethodSumAggregateInputType = {
    sortOrder?: true
    commission?: true
  }

  export type PaymentMethodMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    icon?: true
    isOnline?: true
    isActive?: true
    sortOrder?: true
    commission?: true
    createdAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    icon?: true
    isOnline?: true
    isActive?: true
    sortOrder?: true
    commission?: true
    createdAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    icon?: true
    isOnline?: true
    isActive?: true
    sortOrder?: true
    settings?: true
    commission?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _avg?: PaymentMethodAvgAggregateInputType
    _sum?: PaymentMethodSumAggregateInputType
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    icon: string | null
    isOnline: boolean
    isActive: boolean
    sortOrder: number
    settings: JsonValue | null
    commission: Decimal
    createdAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _avg: PaymentMethodAvgAggregateOutputType | null
    _sum: PaymentMethodSumAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    icon?: boolean
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    commission?: boolean
    createdAt?: boolean
    orders?: boolean | PaymentMethod$ordersArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    icon?: boolean
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    commission?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    icon?: boolean
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    commission?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    icon?: boolean
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: boolean
    settings?: boolean
    commission?: boolean
    createdAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "description" | "icon" | "isOnline" | "isActive" | "sortOrder" | "settings" | "commission" | "createdAt", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | PaymentMethod$ordersArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PaymentMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      icon: string | null
      isOnline: boolean
      isActive: boolean
      sortOrder: number
      settings: Prisma.JsonValue | null
      commission: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods and returns the data updated in the database.
     * @param {PaymentMethodUpdateManyAndReturnArgs} args - Arguments to update many PaymentMethods.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends PaymentMethod$ordersArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly name: FieldRef<"PaymentMethod", 'String'>
    readonly code: FieldRef<"PaymentMethod", 'String'>
    readonly description: FieldRef<"PaymentMethod", 'String'>
    readonly icon: FieldRef<"PaymentMethod", 'String'>
    readonly isOnline: FieldRef<"PaymentMethod", 'Boolean'>
    readonly isActive: FieldRef<"PaymentMethod", 'Boolean'>
    readonly sortOrder: FieldRef<"PaymentMethod", 'Int'>
    readonly settings: FieldRef<"PaymentMethod", 'Json'>
    readonly commission: FieldRef<"PaymentMethod", 'Decimal'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod updateManyAndReturn
   */
  export type PaymentMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod.orders
   */
  export type PaymentMethod$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotal: Decimal | null
    discountAmount: Decimal | null
    shippingAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type OrderSumAggregateOutputType = {
    subtotal: Decimal | null
    discountAmount: Decimal | null
    shippingAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    userId: string | null
    statusId: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    shippingAmount: Decimal | null
    totalAmount: Decimal | null
    deliveryMethodId: string | null
    paymentMethodId: string | null
    comment: string | null
    promoCodeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    orderNumber: string | null
    userId: string | null
    statusId: string | null
    subtotal: Decimal | null
    discountAmount: Decimal | null
    shippingAmount: Decimal | null
    totalAmount: Decimal | null
    deliveryMethodId: string | null
    paymentMethodId: string | null
    comment: string | null
    promoCodeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    userId: number
    statusId: number
    subtotal: number
    discountAmount: number
    shippingAmount: number
    totalAmount: number
    deliveryMethodId: number
    paymentMethodId: number
    shippingAddress: number
    comment: number
    promoCodeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotal?: true
    discountAmount?: true
    shippingAmount?: true
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    subtotal?: true
    discountAmount?: true
    shippingAmount?: true
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    statusId?: true
    subtotal?: true
    discountAmount?: true
    shippingAmount?: true
    totalAmount?: true
    deliveryMethodId?: true
    paymentMethodId?: true
    comment?: true
    promoCodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    statusId?: true
    subtotal?: true
    discountAmount?: true
    shippingAmount?: true
    totalAmount?: true
    deliveryMethodId?: true
    paymentMethodId?: true
    comment?: true
    promoCodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    userId?: true
    statusId?: true
    subtotal?: true
    discountAmount?: true
    shippingAmount?: true
    totalAmount?: true
    deliveryMethodId?: true
    paymentMethodId?: true
    shippingAddress?: true
    comment?: true
    promoCodeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal
    discountAmount: Decimal
    shippingAmount: Decimal
    totalAmount: Decimal
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress: JsonValue | null
    comment: string | null
    promoCodeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    statusId?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    shippingAmount?: boolean
    totalAmount?: boolean
    deliveryMethodId?: boolean
    paymentMethodId?: boolean
    shippingAddress?: boolean
    comment?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    statusLogs?: boolean | Order$statusLogsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    promoCodeUsage?: boolean | Order$promoCodeUsageArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    statusId?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    shippingAmount?: boolean
    totalAmount?: boolean
    deliveryMethodId?: boolean
    paymentMethodId?: boolean
    shippingAddress?: boolean
    comment?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    statusId?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    shippingAmount?: boolean
    totalAmount?: boolean
    deliveryMethodId?: boolean
    paymentMethodId?: boolean
    shippingAddress?: boolean
    comment?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    userId?: boolean
    statusId?: boolean
    subtotal?: boolean
    discountAmount?: boolean
    shippingAmount?: boolean
    totalAmount?: boolean
    deliveryMethodId?: boolean
    paymentMethodId?: boolean
    shippingAddress?: boolean
    comment?: boolean
    promoCodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderNumber" | "userId" | "statusId" | "subtotal" | "discountAmount" | "shippingAmount" | "totalAmount" | "deliveryMethodId" | "paymentMethodId" | "shippingAddress" | "comment" | "promoCodeId" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    statusLogs?: boolean | Order$statusLogsArgs<ExtArgs>
    payments?: boolean | Order$paymentsArgs<ExtArgs>
    promoCodeUsage?: boolean | Order$promoCodeUsageArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    deliveryMethod?: boolean | DeliveryMethodDefaultArgs<ExtArgs>
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    promoCode?: boolean | Order$promoCodeArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      status: Prisma.$OrderStatusPayload<ExtArgs>
      deliveryMethod: Prisma.$DeliveryMethodPayload<ExtArgs>
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
      promoCode: Prisma.$PromoCodePayload<ExtArgs> | null
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      statusLogs: Prisma.$OrderStatusLogPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      promoCodeUsage: Prisma.$PromoCodeUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderNumber: string
      userId: string
      statusId: string
      subtotal: Prisma.Decimal
      discountAmount: Prisma.Decimal
      shippingAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      deliveryMethodId: string
      paymentMethodId: string
      shippingAddress: Prisma.JsonValue | null
      comment: string | null
      promoCodeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends OrderStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatusDefaultArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveryMethod<T extends DeliveryMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryMethodDefaultArgs<ExtArgs>>): Prisma__DeliveryMethodClient<$Result.GetResult<Prisma.$DeliveryMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    promoCode<T extends Order$promoCodeArgs<ExtArgs> = {}>(args?: Subset<T, Order$promoCodeArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusLogs<T extends Order$statusLogsArgs<ExtArgs> = {}>(args?: Subset<T, Order$statusLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Order$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    promoCodeUsage<T extends Order$promoCodeUsageArgs<ExtArgs> = {}>(args?: Subset<T, Order$promoCodeUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly statusId: FieldRef<"Order", 'String'>
    readonly subtotal: FieldRef<"Order", 'Decimal'>
    readonly discountAmount: FieldRef<"Order", 'Decimal'>
    readonly shippingAmount: FieldRef<"Order", 'Decimal'>
    readonly totalAmount: FieldRef<"Order", 'Decimal'>
    readonly deliveryMethodId: FieldRef<"Order", 'String'>
    readonly paymentMethodId: FieldRef<"Order", 'String'>
    readonly shippingAddress: FieldRef<"Order", 'Json'>
    readonly comment: FieldRef<"Order", 'String'>
    readonly promoCodeId: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.promoCode
   */
  export type Order$promoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.statusLogs
   */
  export type Order$statusLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    where?: OrderStatusLogWhereInput
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    cursor?: OrderStatusLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * Order.payments
   */
  export type Order$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Order.promoCodeUsage
   */
  export type Order$promoCodeUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    cursor?: PromoCodeUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    chatProductId: string | null
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    chatProductId: string | null
    quantity: number | null
    price: Decimal | null
    total: Decimal | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    chatProductId: number
    quantity: number
    price: number
    total: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    price?: true
    total?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    price?: true
    total?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    total?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    total?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    chatProductId?: true
    quantity?: true
    price?: true
    total?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    productId: string | null
    chatProductId: string | null
    quantity: number
    price: Decimal
    total: Decimal
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    chatProductId?: boolean
    quantity?: boolean
    price?: boolean
    total?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "chatProductId" | "quantity" | "price" | "total", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | OrderItem$productArgs<ExtArgs>
    chatProduct?: boolean | OrderItem$chatProductArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      chatProduct: Prisma.$ChatProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string | null
      chatProductId: string | null
      quantity: number
      price: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends OrderItem$productArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chatProduct<T extends OrderItem$chatProductArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$chatProductArgs<ExtArgs>>): Prisma__ChatProductClient<$Result.GetResult<Prisma.$ChatProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly chatProductId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Decimal'>
    readonly total: FieldRef<"OrderItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.product
   */
  export type OrderItem$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * OrderItem.chatProduct
   */
  export type OrderItem$chatProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatProduct
     */
    select?: ChatProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatProduct
     */
    omit?: ChatProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatProductInclude<ExtArgs> | null
    where?: ChatProductWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatusLog
   */

  export type AggregateOrderStatusLog = {
    _count: OrderStatusLogCountAggregateOutputType | null
    _min: OrderStatusLogMinAggregateOutputType | null
    _max: OrderStatusLogMaxAggregateOutputType | null
  }

  export type OrderStatusLogMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    statusId: string | null
    comment: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type OrderStatusLogMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    statusId: string | null
    comment: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type OrderStatusLogCountAggregateOutputType = {
    id: number
    orderId: number
    statusId: number
    comment: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type OrderStatusLogMinAggregateInputType = {
    id?: true
    orderId?: true
    statusId?: true
    comment?: true
    createdById?: true
    createdAt?: true
  }

  export type OrderStatusLogMaxAggregateInputType = {
    id?: true
    orderId?: true
    statusId?: true
    comment?: true
    createdById?: true
    createdAt?: true
  }

  export type OrderStatusLogCountAggregateInputType = {
    id?: true
    orderId?: true
    statusId?: true
    comment?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type OrderStatusLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatusLog to aggregate.
     */
    where?: OrderStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusLogs to fetch.
     */
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatusLogs
    **/
    _count?: true | OrderStatusLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusLogMaxAggregateInputType
  }

  export type GetOrderStatusLogAggregateType<T extends OrderStatusLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatusLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatusLog[P]>
      : GetScalarType<T[P], AggregateOrderStatusLog[P]>
  }




  export type OrderStatusLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusLogWhereInput
    orderBy?: OrderStatusLogOrderByWithAggregationInput | OrderStatusLogOrderByWithAggregationInput[]
    by: OrderStatusLogScalarFieldEnum[] | OrderStatusLogScalarFieldEnum
    having?: OrderStatusLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusLogCountAggregateInputType | true
    _min?: OrderStatusLogMinAggregateInputType
    _max?: OrderStatusLogMaxAggregateInputType
  }

  export type OrderStatusLogGroupByOutputType = {
    id: string
    orderId: string
    statusId: string
    comment: string | null
    createdById: string
    createdAt: Date
    _count: OrderStatusLogCountAggregateOutputType | null
    _min: OrderStatusLogMinAggregateOutputType | null
    _max: OrderStatusLogMaxAggregateOutputType | null
  }

  type GetOrderStatusLogGroupByPayload<T extends OrderStatusLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusLogGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusLogGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    statusId?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatusLog"]>

  export type OrderStatusLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    statusId?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatusLog"]>

  export type OrderStatusLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    statusId?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatusLog"]>

  export type OrderStatusLogSelectScalar = {
    id?: boolean
    orderId?: boolean
    statusId?: boolean
    comment?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type OrderStatusLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "statusId" | "comment" | "createdById" | "createdAt", ExtArgs["result"]["orderStatusLog"]>
  export type OrderStatusLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderStatusLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderStatusLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    status?: boolean | OrderStatusDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderStatusLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatusLog"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      status: Prisma.$OrderStatusPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      statusId: string
      comment: string | null
      createdById: string
      createdAt: Date
    }, ExtArgs["result"]["orderStatusLog"]>
    composites: {}
  }

  type OrderStatusLogGetPayload<S extends boolean | null | undefined | OrderStatusLogDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusLogPayload, S>

  type OrderStatusLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderStatusLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderStatusLogCountAggregateInputType | true
    }

  export interface OrderStatusLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatusLog'], meta: { name: 'OrderStatusLog' } }
    /**
     * Find zero or one OrderStatusLog that matches the filter.
     * @param {OrderStatusLogFindUniqueArgs} args - Arguments to find a OrderStatusLog
     * @example
     * // Get one OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusLogFindUniqueArgs>(args: SelectSubset<T, OrderStatusLogFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderStatusLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderStatusLogFindUniqueOrThrowArgs} args - Arguments to find a OrderStatusLog
     * @example
     * // Get one OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatusLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogFindFirstArgs} args - Arguments to find a OrderStatusLog
     * @example
     * // Get one OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusLogFindFirstArgs>(args?: SelectSubset<T, OrderStatusLogFindFirstArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderStatusLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogFindFirstOrThrowArgs} args - Arguments to find a OrderStatusLog
     * @example
     * // Get one OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderStatusLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatusLogs
     * const orderStatusLogs = await prisma.orderStatusLog.findMany()
     * 
     * // Get first 10 OrderStatusLogs
     * const orderStatusLogs = await prisma.orderStatusLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusLogWithIdOnly = await prisma.orderStatusLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStatusLogFindManyArgs>(args?: SelectSubset<T, OrderStatusLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderStatusLog.
     * @param {OrderStatusLogCreateArgs} args - Arguments to create a OrderStatusLog.
     * @example
     * // Create one OrderStatusLog
     * const OrderStatusLog = await prisma.orderStatusLog.create({
     *   data: {
     *     // ... data to create a OrderStatusLog
     *   }
     * })
     * 
     */
    create<T extends OrderStatusLogCreateArgs>(args: SelectSubset<T, OrderStatusLogCreateArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderStatusLogs.
     * @param {OrderStatusLogCreateManyArgs} args - Arguments to create many OrderStatusLogs.
     * @example
     * // Create many OrderStatusLogs
     * const orderStatusLog = await prisma.orderStatusLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusLogCreateManyArgs>(args?: SelectSubset<T, OrderStatusLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderStatusLogs and returns the data saved in the database.
     * @param {OrderStatusLogCreateManyAndReturnArgs} args - Arguments to create many OrderStatusLogs.
     * @example
     * // Create many OrderStatusLogs
     * const orderStatusLog = await prisma.orderStatusLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderStatusLogs and only return the `id`
     * const orderStatusLogWithIdOnly = await prisma.orderStatusLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderStatusLogCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderStatusLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderStatusLog.
     * @param {OrderStatusLogDeleteArgs} args - Arguments to delete one OrderStatusLog.
     * @example
     * // Delete one OrderStatusLog
     * const OrderStatusLog = await prisma.orderStatusLog.delete({
     *   where: {
     *     // ... filter to delete one OrderStatusLog
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusLogDeleteArgs>(args: SelectSubset<T, OrderStatusLogDeleteArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderStatusLog.
     * @param {OrderStatusLogUpdateArgs} args - Arguments to update one OrderStatusLog.
     * @example
     * // Update one OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusLogUpdateArgs>(args: SelectSubset<T, OrderStatusLogUpdateArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderStatusLogs.
     * @param {OrderStatusLogDeleteManyArgs} args - Arguments to filter OrderStatusLogs to delete.
     * @example
     * // Delete a few OrderStatusLogs
     * const { count } = await prisma.orderStatusLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusLogDeleteManyArgs>(args?: SelectSubset<T, OrderStatusLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatusLogs
     * const orderStatusLog = await prisma.orderStatusLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusLogUpdateManyArgs>(args: SelectSubset<T, OrderStatusLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatusLogs and returns the data updated in the database.
     * @param {OrderStatusLogUpdateManyAndReturnArgs} args - Arguments to update many OrderStatusLogs.
     * @example
     * // Update many OrderStatusLogs
     * const orderStatusLog = await prisma.orderStatusLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderStatusLogs and only return the `id`
     * const orderStatusLogWithIdOnly = await prisma.orderStatusLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderStatusLogUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderStatusLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderStatusLog.
     * @param {OrderStatusLogUpsertArgs} args - Arguments to update or create a OrderStatusLog.
     * @example
     * // Update or create a OrderStatusLog
     * const orderStatusLog = await prisma.orderStatusLog.upsert({
     *   create: {
     *     // ... data to create a OrderStatusLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatusLog we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusLogUpsertArgs>(args: SelectSubset<T, OrderStatusLogUpsertArgs<ExtArgs>>): Prisma__OrderStatusLogClient<$Result.GetResult<Prisma.$OrderStatusLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderStatusLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogCountArgs} args - Arguments to filter OrderStatusLogs to count.
     * @example
     * // Count the number of OrderStatusLogs
     * const count = await prisma.orderStatusLog.count({
     *   where: {
     *     // ... the filter for the OrderStatusLogs we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusLogCountArgs>(
      args?: Subset<T, OrderStatusLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusLogAggregateArgs>(args: Subset<T, OrderStatusLogAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusLogAggregateType<T>>

    /**
     * Group by OrderStatusLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusLogGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatusLog model
   */
  readonly fields: OrderStatusLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatusLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    status<T extends OrderStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatusDefaultArgs<ExtArgs>>): Prisma__OrderStatusClient<$Result.GetResult<Prisma.$OrderStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatusLog model
   */
  interface OrderStatusLogFieldRefs {
    readonly id: FieldRef<"OrderStatusLog", 'String'>
    readonly orderId: FieldRef<"OrderStatusLog", 'String'>
    readonly statusId: FieldRef<"OrderStatusLog", 'String'>
    readonly comment: FieldRef<"OrderStatusLog", 'String'>
    readonly createdById: FieldRef<"OrderStatusLog", 'String'>
    readonly createdAt: FieldRef<"OrderStatusLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatusLog findUnique
   */
  export type OrderStatusLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusLog to fetch.
     */
    where: OrderStatusLogWhereUniqueInput
  }

  /**
   * OrderStatusLog findUniqueOrThrow
   */
  export type OrderStatusLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusLog to fetch.
     */
    where: OrderStatusLogWhereUniqueInput
  }

  /**
   * OrderStatusLog findFirst
   */
  export type OrderStatusLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusLog to fetch.
     */
    where?: OrderStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusLogs to fetch.
     */
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatusLogs.
     */
    cursor?: OrderStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatusLogs.
     */
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * OrderStatusLog findFirstOrThrow
   */
  export type OrderStatusLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusLog to fetch.
     */
    where?: OrderStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusLogs to fetch.
     */
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatusLogs.
     */
    cursor?: OrderStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatusLogs.
     */
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * OrderStatusLog findMany
   */
  export type OrderStatusLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusLogs to fetch.
     */
    where?: OrderStatusLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusLogs to fetch.
     */
    orderBy?: OrderStatusLogOrderByWithRelationInput | OrderStatusLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatusLogs.
     */
    cursor?: OrderStatusLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusLogs.
     */
    skip?: number
    distinct?: OrderStatusLogScalarFieldEnum | OrderStatusLogScalarFieldEnum[]
  }

  /**
   * OrderStatusLog create
   */
  export type OrderStatusLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatusLog.
     */
    data: XOR<OrderStatusLogCreateInput, OrderStatusLogUncheckedCreateInput>
  }

  /**
   * OrderStatusLog createMany
   */
  export type OrderStatusLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatusLogs.
     */
    data: OrderStatusLogCreateManyInput | OrderStatusLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatusLog createManyAndReturn
   */
  export type OrderStatusLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * The data used to create many OrderStatusLogs.
     */
    data: OrderStatusLogCreateManyInput | OrderStatusLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderStatusLog update
   */
  export type OrderStatusLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatusLog.
     */
    data: XOR<OrderStatusLogUpdateInput, OrderStatusLogUncheckedUpdateInput>
    /**
     * Choose, which OrderStatusLog to update.
     */
    where: OrderStatusLogWhereUniqueInput
  }

  /**
   * OrderStatusLog updateMany
   */
  export type OrderStatusLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatusLogs.
     */
    data: XOR<OrderStatusLogUpdateManyMutationInput, OrderStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatusLogs to update
     */
    where?: OrderStatusLogWhereInput
    /**
     * Limit how many OrderStatusLogs to update.
     */
    limit?: number
  }

  /**
   * OrderStatusLog updateManyAndReturn
   */
  export type OrderStatusLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * The data used to update OrderStatusLogs.
     */
    data: XOR<OrderStatusLogUpdateManyMutationInput, OrderStatusLogUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatusLogs to update
     */
    where?: OrderStatusLogWhereInput
    /**
     * Limit how many OrderStatusLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderStatusLog upsert
   */
  export type OrderStatusLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatusLog to update in case it exists.
     */
    where: OrderStatusLogWhereUniqueInput
    /**
     * In case the OrderStatusLog found by the `where` argument doesn't exist, create a new OrderStatusLog with this data.
     */
    create: XOR<OrderStatusLogCreateInput, OrderStatusLogUncheckedCreateInput>
    /**
     * In case the OrderStatusLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusLogUpdateInput, OrderStatusLogUncheckedUpdateInput>
  }

  /**
   * OrderStatusLog delete
   */
  export type OrderStatusLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
    /**
     * Filter which OrderStatusLog to delete.
     */
    where: OrderStatusLogWhereUniqueInput
  }

  /**
   * OrderStatusLog deleteMany
   */
  export type OrderStatusLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatusLogs to delete
     */
    where?: OrderStatusLogWhereInput
    /**
     * Limit how many OrderStatusLogs to delete.
     */
    limit?: number
  }

  /**
   * OrderStatusLog without action
   */
  export type OrderStatusLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusLog
     */
    select?: OrderStatusLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderStatusLog
     */
    omit?: OrderStatusLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusLogInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: Decimal | null
    status: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    amount: Decimal | null
    status: string | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    amount: number
    status: number
    transactionId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    status?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    status?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    status?: true
    transactionId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    amount: Decimal
    status: string
    transactionId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    amount?: boolean
    status?: boolean
    transactionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "amount" | "status" | "transactionId" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      amount: Prisma.Decimal
      status: string
      transactionId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model CustomerGroup
   */

  export type AggregateCustomerGroup = {
    _count: CustomerGroupCountAggregateOutputType | null
    _avg: CustomerGroupAvgAggregateOutputType | null
    _sum: CustomerGroupSumAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  export type CustomerGroupAvgAggregateOutputType = {
    discountPercent: Decimal | null
    minOrderAmount: Decimal | null
  }

  export type CustomerGroupSumAggregateOutputType = {
    discountPercent: Decimal | null
    minOrderAmount: Decimal | null
  }

  export type CustomerGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    discountPercent: Decimal | null
    minOrderAmount: Decimal | null
  }

  export type CustomerGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    discountPercent: Decimal | null
    minOrderAmount: Decimal | null
  }

  export type CustomerGroupCountAggregateOutputType = {
    id: number
    name: number
    discountPercent: number
    minOrderAmount: number
    benefits: number
    _all: number
  }


  export type CustomerGroupAvgAggregateInputType = {
    discountPercent?: true
    minOrderAmount?: true
  }

  export type CustomerGroupSumAggregateInputType = {
    discountPercent?: true
    minOrderAmount?: true
  }

  export type CustomerGroupMinAggregateInputType = {
    id?: true
    name?: true
    discountPercent?: true
    minOrderAmount?: true
  }

  export type CustomerGroupMaxAggregateInputType = {
    id?: true
    name?: true
    discountPercent?: true
    minOrderAmount?: true
  }

  export type CustomerGroupCountAggregateInputType = {
    id?: true
    name?: true
    discountPercent?: true
    minOrderAmount?: true
    benefits?: true
    _all?: true
  }

  export type CustomerGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroup to aggregate.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerGroups
    **/
    _count?: true | CustomerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type GetCustomerGroupAggregateType<T extends CustomerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerGroup[P]>
      : GetScalarType<T[P], AggregateCustomerGroup[P]>
  }




  export type CustomerGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupWhereInput
    orderBy?: CustomerGroupOrderByWithAggregationInput | CustomerGroupOrderByWithAggregationInput[]
    by: CustomerGroupScalarFieldEnum[] | CustomerGroupScalarFieldEnum
    having?: CustomerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerGroupCountAggregateInputType | true
    _avg?: CustomerGroupAvgAggregateInputType
    _sum?: CustomerGroupSumAggregateInputType
    _min?: CustomerGroupMinAggregateInputType
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type CustomerGroupGroupByOutputType = {
    id: string
    name: string
    discountPercent: Decimal
    minOrderAmount: Decimal | null
    benefits: JsonValue | null
    _count: CustomerGroupCountAggregateOutputType | null
    _avg: CustomerGroupAvgAggregateOutputType | null
    _sum: CustomerGroupSumAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  type GetCustomerGroupGroupByPayload<T extends CustomerGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
        }
      >
    >


  export type CustomerGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountPercent?: boolean
    minOrderAmount?: boolean
    benefits?: boolean
    users?: boolean | CustomerGroup$usersArgs<ExtArgs>
    discountRules?: boolean | CustomerGroup$discountRulesArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountPercent?: boolean
    minOrderAmount?: boolean
    benefits?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountPercent?: boolean
    minOrderAmount?: boolean
    benefits?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectScalar = {
    id?: boolean
    name?: boolean
    discountPercent?: boolean
    minOrderAmount?: boolean
    benefits?: boolean
  }

  export type CustomerGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "discountPercent" | "minOrderAmount" | "benefits", ExtArgs["result"]["customerGroup"]>
  export type CustomerGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | CustomerGroup$usersArgs<ExtArgs>
    discountRules?: boolean | CustomerGroup$discountRulesArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerGroup"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      discountRules: Prisma.$DiscountRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      discountPercent: Prisma.Decimal
      minOrderAmount: Prisma.Decimal | null
      benefits: Prisma.JsonValue | null
    }, ExtArgs["result"]["customerGroup"]>
    composites: {}
  }

  type CustomerGroupGetPayload<S extends boolean | null | undefined | CustomerGroupDefaultArgs> = $Result.GetResult<Prisma.$CustomerGroupPayload, S>

  type CustomerGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerGroupCountAggregateInputType | true
    }

  export interface CustomerGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerGroup'], meta: { name: 'CustomerGroup' } }
    /**
     * Find zero or one CustomerGroup that matches the filter.
     * @param {CustomerGroupFindUniqueArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerGroupFindUniqueArgs>(args: SelectSubset<T, CustomerGroupFindUniqueArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerGroupFindUniqueOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerGroupFindFirstArgs>(args?: SelectSubset<T, CustomerGroupFindFirstArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany()
     * 
     * // Get first 10 CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerGroupFindManyArgs>(args?: SelectSubset<T, CustomerGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerGroup.
     * @param {CustomerGroupCreateArgs} args - Arguments to create a CustomerGroup.
     * @example
     * // Create one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.create({
     *   data: {
     *     // ... data to create a CustomerGroup
     *   }
     * })
     * 
     */
    create<T extends CustomerGroupCreateArgs>(args: SelectSubset<T, CustomerGroupCreateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerGroups.
     * @param {CustomerGroupCreateManyArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerGroupCreateManyArgs>(args?: SelectSubset<T, CustomerGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerGroups and returns the data saved in the database.
     * @param {CustomerGroupCreateManyAndReturnArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerGroup.
     * @param {CustomerGroupDeleteArgs} args - Arguments to delete one CustomerGroup.
     * @example
     * // Delete one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.delete({
     *   where: {
     *     // ... filter to delete one CustomerGroup
     *   }
     * })
     * 
     */
    delete<T extends CustomerGroupDeleteArgs>(args: SelectSubset<T, CustomerGroupDeleteArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerGroup.
     * @param {CustomerGroupUpdateArgs} args - Arguments to update one CustomerGroup.
     * @example
     * // Update one CustomerGroup
     * const customerGroup = await prisma.customerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerGroupUpdateArgs>(args: SelectSubset<T, CustomerGroupUpdateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerGroups.
     * @param {CustomerGroupDeleteManyArgs} args - Arguments to filter CustomerGroups to delete.
     * @example
     * // Delete a few CustomerGroups
     * const { count } = await prisma.customerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerGroupDeleteManyArgs>(args?: SelectSubset<T, CustomerGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerGroupUpdateManyArgs>(args: SelectSubset<T, CustomerGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups and returns the data updated in the database.
     * @param {CustomerGroupUpdateManyAndReturnArgs} args - Arguments to update many CustomerGroups.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerGroup.
     * @param {CustomerGroupUpsertArgs} args - Arguments to update or create a CustomerGroup.
     * @example
     * // Update or create a CustomerGroup
     * const customerGroup = await prisma.customerGroup.upsert({
     *   create: {
     *     // ... data to create a CustomerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerGroup we want to update
     *   }
     * })
     */
    upsert<T extends CustomerGroupUpsertArgs>(args: SelectSubset<T, CustomerGroupUpsertArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupCountArgs} args - Arguments to filter CustomerGroups to count.
     * @example
     * // Count the number of CustomerGroups
     * const count = await prisma.customerGroup.count({
     *   where: {
     *     // ... the filter for the CustomerGroups we want to count
     *   }
     * })
    **/
    count<T extends CustomerGroupCountArgs>(
      args?: Subset<T, CustomerGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerGroupAggregateArgs>(args: Subset<T, CustomerGroupAggregateArgs>): Prisma.PrismaPromise<GetCustomerGroupAggregateType<T>>

    /**
     * Group by CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerGroup model
   */
  readonly fields: CustomerGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends CustomerGroup$usersArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroup$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discountRules<T extends CustomerGroup$discountRulesArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroup$discountRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerGroup model
   */
  interface CustomerGroupFieldRefs {
    readonly id: FieldRef<"CustomerGroup", 'String'>
    readonly name: FieldRef<"CustomerGroup", 'String'>
    readonly discountPercent: FieldRef<"CustomerGroup", 'Decimal'>
    readonly minOrderAmount: FieldRef<"CustomerGroup", 'Decimal'>
    readonly benefits: FieldRef<"CustomerGroup", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CustomerGroup findUnique
   */
  export type CustomerGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findUniqueOrThrow
   */
  export type CustomerGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findFirst
   */
  export type CustomerGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findFirstOrThrow
   */
  export type CustomerGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findMany
   */
  export type CustomerGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup create
   */
  export type CustomerGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerGroup.
     */
    data: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
  }

  /**
   * CustomerGroup createMany
   */
  export type CustomerGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroup createManyAndReturn
   */
  export type CustomerGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerGroup update
   */
  export type CustomerGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerGroup.
     */
    data: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
    /**
     * Choose, which CustomerGroup to update.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup updateMany
   */
  export type CustomerGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup updateManyAndReturn
   */
  export type CustomerGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup upsert
   */
  export type CustomerGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerGroup to update in case it exists.
     */
    where: CustomerGroupWhereUniqueInput
    /**
     * In case the CustomerGroup found by the `where` argument doesn't exist, create a new CustomerGroup with this data.
     */
    create: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
    /**
     * In case the CustomerGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
  }

  /**
   * CustomerGroup delete
   */
  export type CustomerGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter which CustomerGroup to delete.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup deleteMany
   */
  export type CustomerGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroups to delete
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to delete.
     */
    limit?: number
  }

  /**
   * CustomerGroup.users
   */
  export type CustomerGroup$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * CustomerGroup.discountRules
   */
  export type CustomerGroup$discountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    cursor?: DiscountRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * CustomerGroup without action
   */
  export type CustomerGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
  }


  /**
   * Model DiscountRule
   */

  export type AggregateDiscountRule = {
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  export type DiscountRuleAvgAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    usageLimit: number | null
  }

  export type DiscountRuleSumAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    usageLimit: number | null
  }

  export type DiscountRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    usageLimit: number | null
    customerGroupId: string | null
    isActive: boolean | null
  }

  export type DiscountRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.DiscountType | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    usageLimit: number | null
    customerGroupId: string | null
    isActive: boolean | null
  }

  export type DiscountRuleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    value: number
    minAmount: number
    maxDiscount: number
    startDate: number
    endDate: number
    usageLimit: number
    customerGroupId: number
    categories: number
    brands: number
    isActive: number
    _all: number
  }


  export type DiscountRuleAvgAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    usageLimit?: true
  }

  export type DiscountRuleSumAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    usageLimit?: true
  }

  export type DiscountRuleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    customerGroupId?: true
    isActive?: true
  }

  export type DiscountRuleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    customerGroupId?: true
    isActive?: true
  }

  export type DiscountRuleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    startDate?: true
    endDate?: true
    usageLimit?: true
    customerGroupId?: true
    categories?: true
    brands?: true
    isActive?: true
    _all?: true
  }

  export type DiscountRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRule to aggregate.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountRules
    **/
    _count?: true | DiscountRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type GetDiscountRuleAggregateType<T extends DiscountRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountRule[P]>
      : GetScalarType<T[P], AggregateDiscountRule[P]>
  }




  export type DiscountRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountRuleWhereInput
    orderBy?: DiscountRuleOrderByWithAggregationInput | DiscountRuleOrderByWithAggregationInput[]
    by: DiscountRuleScalarFieldEnum[] | DiscountRuleScalarFieldEnum
    having?: DiscountRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountRuleCountAggregateInputType | true
    _avg?: DiscountRuleAvgAggregateInputType
    _sum?: DiscountRuleSumAggregateInputType
    _min?: DiscountRuleMinAggregateInputType
    _max?: DiscountRuleMaxAggregateInputType
  }

  export type DiscountRuleGroupByOutputType = {
    id: string
    name: string
    type: $Enums.DiscountType
    value: Decimal
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    usageLimit: number | null
    customerGroupId: string | null
    categories: JsonValue | null
    brands: JsonValue | null
    isActive: boolean
    _count: DiscountRuleCountAggregateOutputType | null
    _avg: DiscountRuleAvgAggregateOutputType | null
    _sum: DiscountRuleSumAggregateOutputType | null
    _min: DiscountRuleMinAggregateOutputType | null
    _max: DiscountRuleMaxAggregateOutputType | null
  }

  type GetDiscountRuleGroupByPayload<T extends DiscountRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountRuleGroupByOutputType[P]>
        }
      >
    >


  export type DiscountRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    customerGroupId?: boolean
    categories?: boolean
    brands?: boolean
    isActive?: boolean
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
    promoCodes?: boolean | DiscountRule$promoCodesArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    customerGroupId?: boolean
    categories?: boolean
    brands?: boolean
    isActive?: boolean
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    customerGroupId?: boolean
    categories?: boolean
    brands?: boolean
    isActive?: boolean
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
  }, ExtArgs["result"]["discountRule"]>

  export type DiscountRuleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    startDate?: boolean
    endDate?: boolean
    usageLimit?: boolean
    customerGroupId?: boolean
    categories?: boolean
    brands?: boolean
    isActive?: boolean
  }

  export type DiscountRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "value" | "minAmount" | "maxDiscount" | "startDate" | "endDate" | "usageLimit" | "customerGroupId" | "categories" | "brands" | "isActive", ExtArgs["result"]["discountRule"]>
  export type DiscountRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
    promoCodes?: boolean | DiscountRule$promoCodesArgs<ExtArgs>
    _count?: boolean | DiscountRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
  }
  export type DiscountRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerGroup?: boolean | DiscountRule$customerGroupArgs<ExtArgs>
  }

  export type $DiscountRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscountRule"
    objects: {
      customerGroup: Prisma.$CustomerGroupPayload<ExtArgs> | null
      promoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.DiscountType
      value: Prisma.Decimal
      minAmount: Prisma.Decimal | null
      maxDiscount: Prisma.Decimal | null
      startDate: Date | null
      endDate: Date | null
      usageLimit: number | null
      customerGroupId: string | null
      categories: Prisma.JsonValue | null
      brands: Prisma.JsonValue | null
      isActive: boolean
    }, ExtArgs["result"]["discountRule"]>
    composites: {}
  }

  type DiscountRuleGetPayload<S extends boolean | null | undefined | DiscountRuleDefaultArgs> = $Result.GetResult<Prisma.$DiscountRulePayload, S>

  type DiscountRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountRuleCountAggregateInputType | true
    }

  export interface DiscountRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscountRule'], meta: { name: 'DiscountRule' } }
    /**
     * Find zero or one DiscountRule that matches the filter.
     * @param {DiscountRuleFindUniqueArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountRuleFindUniqueArgs>(args: SelectSubset<T, DiscountRuleFindUniqueArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscountRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountRuleFindUniqueOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountRuleFindFirstArgs>(args?: SelectSubset<T, DiscountRuleFindFirstArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindFirstOrThrowArgs} args - Arguments to find a DiscountRule
     * @example
     * // Get one DiscountRule
     * const discountRule = await prisma.discountRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscountRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountRules
     * const discountRules = await prisma.discountRule.findMany()
     * 
     * // Get first 10 DiscountRules
     * const discountRules = await prisma.discountRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountRuleFindManyArgs>(args?: SelectSubset<T, DiscountRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscountRule.
     * @param {DiscountRuleCreateArgs} args - Arguments to create a DiscountRule.
     * @example
     * // Create one DiscountRule
     * const DiscountRule = await prisma.discountRule.create({
     *   data: {
     *     // ... data to create a DiscountRule
     *   }
     * })
     * 
     */
    create<T extends DiscountRuleCreateArgs>(args: SelectSubset<T, DiscountRuleCreateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscountRules.
     * @param {DiscountRuleCreateManyArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountRuleCreateManyArgs>(args?: SelectSubset<T, DiscountRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscountRules and returns the data saved in the database.
     * @param {DiscountRuleCreateManyAndReturnArgs} args - Arguments to create many DiscountRules.
     * @example
     * // Create many DiscountRules
     * const discountRule = await prisma.discountRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscountRule.
     * @param {DiscountRuleDeleteArgs} args - Arguments to delete one DiscountRule.
     * @example
     * // Delete one DiscountRule
     * const DiscountRule = await prisma.discountRule.delete({
     *   where: {
     *     // ... filter to delete one DiscountRule
     *   }
     * })
     * 
     */
    delete<T extends DiscountRuleDeleteArgs>(args: SelectSubset<T, DiscountRuleDeleteArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscountRule.
     * @param {DiscountRuleUpdateArgs} args - Arguments to update one DiscountRule.
     * @example
     * // Update one DiscountRule
     * const discountRule = await prisma.discountRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountRuleUpdateArgs>(args: SelectSubset<T, DiscountRuleUpdateArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscountRules.
     * @param {DiscountRuleDeleteManyArgs} args - Arguments to filter DiscountRules to delete.
     * @example
     * // Delete a few DiscountRules
     * const { count } = await prisma.discountRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountRuleDeleteManyArgs>(args?: SelectSubset<T, DiscountRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountRuleUpdateManyArgs>(args: SelectSubset<T, DiscountRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountRules and returns the data updated in the database.
     * @param {DiscountRuleUpdateManyAndReturnArgs} args - Arguments to update many DiscountRules.
     * @example
     * // Update many DiscountRules
     * const discountRule = await prisma.discountRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscountRules and only return the `id`
     * const discountRuleWithIdOnly = await prisma.discountRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscountRule.
     * @param {DiscountRuleUpsertArgs} args - Arguments to update or create a DiscountRule.
     * @example
     * // Update or create a DiscountRule
     * const discountRule = await prisma.discountRule.upsert({
     *   create: {
     *     // ... data to create a DiscountRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountRule we want to update
     *   }
     * })
     */
    upsert<T extends DiscountRuleUpsertArgs>(args: SelectSubset<T, DiscountRuleUpsertArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscountRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleCountArgs} args - Arguments to filter DiscountRules to count.
     * @example
     * // Count the number of DiscountRules
     * const count = await prisma.discountRule.count({
     *   where: {
     *     // ... the filter for the DiscountRules we want to count
     *   }
     * })
    **/
    count<T extends DiscountRuleCountArgs>(
      args?: Subset<T, DiscountRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountRuleAggregateArgs>(args: Subset<T, DiscountRuleAggregateArgs>): Prisma.PrismaPromise<GetDiscountRuleAggregateType<T>>

    /**
     * Group by DiscountRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountRuleGroupByArgs['orderBy'] }
        : { orderBy?: DiscountRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscountRule model
   */
  readonly fields: DiscountRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerGroup<T extends DiscountRule$customerGroupArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$customerGroupArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    promoCodes<T extends DiscountRule$promoCodesArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRule$promoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscountRule model
   */
  interface DiscountRuleFieldRefs {
    readonly id: FieldRef<"DiscountRule", 'String'>
    readonly name: FieldRef<"DiscountRule", 'String'>
    readonly type: FieldRef<"DiscountRule", 'DiscountType'>
    readonly value: FieldRef<"DiscountRule", 'Decimal'>
    readonly minAmount: FieldRef<"DiscountRule", 'Decimal'>
    readonly maxDiscount: FieldRef<"DiscountRule", 'Decimal'>
    readonly startDate: FieldRef<"DiscountRule", 'DateTime'>
    readonly endDate: FieldRef<"DiscountRule", 'DateTime'>
    readonly usageLimit: FieldRef<"DiscountRule", 'Int'>
    readonly customerGroupId: FieldRef<"DiscountRule", 'String'>
    readonly categories: FieldRef<"DiscountRule", 'Json'>
    readonly brands: FieldRef<"DiscountRule", 'Json'>
    readonly isActive: FieldRef<"DiscountRule", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DiscountRule findUnique
   */
  export type DiscountRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findUniqueOrThrow
   */
  export type DiscountRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule findFirst
   */
  export type DiscountRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findFirstOrThrow
   */
  export type DiscountRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRule to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountRules.
     */
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule findMany
   */
  export type DiscountRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter, which DiscountRules to fetch.
     */
    where?: DiscountRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountRules to fetch.
     */
    orderBy?: DiscountRuleOrderByWithRelationInput | DiscountRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountRules.
     */
    cursor?: DiscountRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountRules.
     */
    skip?: number
    distinct?: DiscountRuleScalarFieldEnum | DiscountRuleScalarFieldEnum[]
  }

  /**
   * DiscountRule create
   */
  export type DiscountRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscountRule.
     */
    data: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
  }

  /**
   * DiscountRule createMany
   */
  export type DiscountRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountRule createManyAndReturn
   */
  export type DiscountRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to create many DiscountRules.
     */
    data: DiscountRuleCreateManyInput | DiscountRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscountRule update
   */
  export type DiscountRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscountRule.
     */
    data: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
    /**
     * Choose, which DiscountRule to update.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule updateMany
   */
  export type DiscountRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
  }

  /**
   * DiscountRule updateManyAndReturn
   */
  export type DiscountRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * The data used to update DiscountRules.
     */
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyInput>
    /**
     * Filter which DiscountRules to update
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscountRule upsert
   */
  export type DiscountRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscountRule to update in case it exists.
     */
    where: DiscountRuleWhereUniqueInput
    /**
     * In case the DiscountRule found by the `where` argument doesn't exist, create a new DiscountRule with this data.
     */
    create: XOR<DiscountRuleCreateInput, DiscountRuleUncheckedCreateInput>
    /**
     * In case the DiscountRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountRuleUpdateInput, DiscountRuleUncheckedUpdateInput>
  }

  /**
   * DiscountRule delete
   */
  export type DiscountRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
    /**
     * Filter which DiscountRule to delete.
     */
    where: DiscountRuleWhereUniqueInput
  }

  /**
   * DiscountRule deleteMany
   */
  export type DiscountRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountRules to delete
     */
    where?: DiscountRuleWhereInput
    /**
     * Limit how many DiscountRules to delete.
     */
    limit?: number
  }

  /**
   * DiscountRule.customerGroup
   */
  export type DiscountRule$customerGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    where?: CustomerGroupWhereInput
  }

  /**
   * DiscountRule.promoCodes
   */
  export type DiscountRule$promoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * DiscountRule without action
   */
  export type DiscountRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountRule
     */
    select?: DiscountRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountRule
     */
    omit?: DiscountRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountRuleInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeAvgAggregateOutputType = {
    usageCount: number | null
    usageLimit: number | null
  }

  export type PromoCodeSumAggregateOutputType = {
    usageCount: number | null
    usageLimit: number | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    discountRuleId: string | null
    usageCount: number | null
    usageLimit: number | null
    personalUserId: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    discountRuleId: string | null
    usageCount: number | null
    usageLimit: number | null
    personalUserId: string | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    discountRuleId: number
    usageCount: number
    usageLimit: number
    personalUserId: number
    expiresAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PromoCodeAvgAggregateInputType = {
    usageCount?: true
    usageLimit?: true
  }

  export type PromoCodeSumAggregateInputType = {
    usageCount?: true
    usageLimit?: true
  }

  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    discountRuleId?: true
    usageCount?: true
    usageLimit?: true
    personalUserId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    discountRuleId?: true
    usageCount?: true
    usageLimit?: true
    personalUserId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    discountRuleId?: true
    usageCount?: true
    usageLimit?: true
    personalUserId?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromoCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromoCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _avg?: PromoCodeAvgAggregateInputType
    _sum?: PromoCodeSumAggregateInputType
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    discountRuleId: string
    usageCount: number
    usageLimit: number | null
    personalUserId: string | null
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _avg: PromoCodeAvgAggregateOutputType | null
    _sum: PromoCodeSumAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountRuleId?: boolean
    usageCount?: boolean
    usageLimit?: boolean
    personalUserId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
    orders?: boolean | PromoCode$ordersArgs<ExtArgs>
    usage?: boolean | PromoCode$usageArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountRuleId?: boolean
    usageCount?: boolean
    usageLimit?: boolean
    personalUserId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    discountRuleId?: boolean
    usageCount?: boolean
    usageLimit?: boolean
    personalUserId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    discountRuleId?: boolean
    usageCount?: boolean
    usageLimit?: boolean
    personalUserId?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PromoCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "discountRuleId" | "usageCount" | "usageLimit" | "personalUserId" | "expiresAt" | "isActive" | "createdAt", ExtArgs["result"]["promoCode"]>
  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
    orders?: boolean | PromoCode$ordersArgs<ExtArgs>
    usage?: boolean | PromoCode$usageArgs<ExtArgs>
    _count?: boolean | PromoCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
  }
  export type PromoCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountRule?: boolean | DiscountRuleDefaultArgs<ExtArgs>
    personalUser?: boolean | PromoCode$personalUserArgs<ExtArgs>
  }

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      discountRule: Prisma.$DiscountRulePayload<ExtArgs>
      personalUser: Prisma.$UserPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      usage: Prisma.$PromoCodeUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      discountRuleId: string
      usageCount: number
      usageLimit: number | null
      personalUserId: string | null
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes and returns the data updated in the database.
     * @param {PromoCodeUpdateManyAndReturnArgs} args - Arguments to update many PromoCodes.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discountRule<T extends DiscountRuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountRuleDefaultArgs<ExtArgs>>): Prisma__DiscountRuleClient<$Result.GetResult<Prisma.$DiscountRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personalUser<T extends PromoCode$personalUserArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$personalUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends PromoCode$ordersArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usage<T extends PromoCode$usageArgs<ExtArgs> = {}>(args?: Subset<T, PromoCode$usageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly discountRuleId: FieldRef<"PromoCode", 'String'>
    readonly usageCount: FieldRef<"PromoCode", 'Int'>
    readonly usageLimit: FieldRef<"PromoCode", 'Int'>
    readonly personalUserId: FieldRef<"PromoCode", 'String'>
    readonly expiresAt: FieldRef<"PromoCode", 'DateTime'>
    readonly isActive: FieldRef<"PromoCode", 'Boolean'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
  }

  /**
   * PromoCode updateManyAndReturn
   */
  export type PromoCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
    /**
     * Limit how many PromoCodes to delete.
     */
    limit?: number
  }

  /**
   * PromoCode.personalUser
   */
  export type PromoCode$personalUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PromoCode.orders
   */
  export type PromoCode$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * PromoCode.usage
   */
  export type PromoCode$usageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    cursor?: PromoCodeUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCode
     */
    omit?: PromoCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model PromoCodeUsage
   */

  export type AggregatePromoCodeUsage = {
    _count: PromoCodeUsageCountAggregateOutputType | null
    _min: PromoCodeUsageMinAggregateOutputType | null
    _max: PromoCodeUsageMaxAggregateOutputType | null
  }

  export type PromoCodeUsageMinAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    userId: string | null
    orderId: string | null
    createdAt: Date | null
  }

  export type PromoCodeUsageMaxAggregateOutputType = {
    id: string | null
    promoCodeId: string | null
    userId: string | null
    orderId: string | null
    createdAt: Date | null
  }

  export type PromoCodeUsageCountAggregateOutputType = {
    id: number
    promoCodeId: number
    userId: number
    orderId: number
    createdAt: number
    _all: number
  }


  export type PromoCodeUsageMinAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    orderId?: true
    createdAt?: true
  }

  export type PromoCodeUsageMaxAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    orderId?: true
    createdAt?: true
  }

  export type PromoCodeUsageCountAggregateInputType = {
    id?: true
    promoCodeId?: true
    userId?: true
    orderId?: true
    createdAt?: true
    _all?: true
  }

  export type PromoCodeUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodeUsage to aggregate.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodeUsages
    **/
    _count?: true | PromoCodeUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeUsageMaxAggregateInputType
  }

  export type GetPromoCodeUsageAggregateType<T extends PromoCodeUsageAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCodeUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCodeUsage[P]>
      : GetScalarType<T[P], AggregatePromoCodeUsage[P]>
  }




  export type PromoCodeUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeUsageWhereInput
    orderBy?: PromoCodeUsageOrderByWithAggregationInput | PromoCodeUsageOrderByWithAggregationInput[]
    by: PromoCodeUsageScalarFieldEnum[] | PromoCodeUsageScalarFieldEnum
    having?: PromoCodeUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeUsageCountAggregateInputType | true
    _min?: PromoCodeUsageMinAggregateInputType
    _max?: PromoCodeUsageMaxAggregateInputType
  }

  export type PromoCodeUsageGroupByOutputType = {
    id: string
    promoCodeId: string
    userId: string
    orderId: string | null
    createdAt: Date
    _count: PromoCodeUsageCountAggregateOutputType | null
    _min: PromoCodeUsageMinAggregateOutputType | null
    _max: PromoCodeUsageMaxAggregateOutputType | null
  }

  type GetPromoCodeUsageGroupByPayload<T extends PromoCodeUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeUsageGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeUsageGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    orderId?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    orderId?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    orderId?: boolean
    createdAt?: boolean
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }, ExtArgs["result"]["promoCodeUsage"]>

  export type PromoCodeUsageSelectScalar = {
    id?: boolean
    promoCodeId?: boolean
    userId?: boolean
    orderId?: boolean
    createdAt?: boolean
  }

  export type PromoCodeUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promoCodeId" | "userId" | "orderId" | "createdAt", ExtArgs["result"]["promoCodeUsage"]>
  export type PromoCodeUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }
  export type PromoCodeUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }
  export type PromoCodeUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoCode?: boolean | PromoCodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | PromoCodeUsage$orderArgs<ExtArgs>
  }

  export type $PromoCodeUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCodeUsage"
    objects: {
      promoCode: Prisma.$PromoCodePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promoCodeId: string
      userId: string
      orderId: string | null
      createdAt: Date
    }, ExtArgs["result"]["promoCodeUsage"]>
    composites: {}
  }

  type PromoCodeUsageGetPayload<S extends boolean | null | undefined | PromoCodeUsageDefaultArgs> = $Result.GetResult<Prisma.$PromoCodeUsagePayload, S>

  type PromoCodeUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromoCodeUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromoCodeUsageCountAggregateInputType | true
    }

  export interface PromoCodeUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCodeUsage'], meta: { name: 'PromoCodeUsage' } }
    /**
     * Find zero or one PromoCodeUsage that matches the filter.
     * @param {PromoCodeUsageFindUniqueArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeUsageFindUniqueArgs>(args: SelectSubset<T, PromoCodeUsageFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromoCodeUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromoCodeUsageFindUniqueOrThrowArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCodeUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindFirstArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeUsageFindFirstArgs>(args?: SelectSubset<T, PromoCodeUsageFindFirstArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromoCodeUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindFirstOrThrowArgs} args - Arguments to find a PromoCodeUsage
     * @example
     * // Get one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromoCodeUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodeUsages
     * const promoCodeUsages = await prisma.promoCodeUsage.findMany()
     * 
     * // Get first 10 PromoCodeUsages
     * const promoCodeUsages = await prisma.promoCodeUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeUsageFindManyArgs>(args?: SelectSubset<T, PromoCodeUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromoCodeUsage.
     * @param {PromoCodeUsageCreateArgs} args - Arguments to create a PromoCodeUsage.
     * @example
     * // Create one PromoCodeUsage
     * const PromoCodeUsage = await prisma.promoCodeUsage.create({
     *   data: {
     *     // ... data to create a PromoCodeUsage
     *   }
     * })
     * 
     */
    create<T extends PromoCodeUsageCreateArgs>(args: SelectSubset<T, PromoCodeUsageCreateArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromoCodeUsages.
     * @param {PromoCodeUsageCreateManyArgs} args - Arguments to create many PromoCodeUsages.
     * @example
     * // Create many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeUsageCreateManyArgs>(args?: SelectSubset<T, PromoCodeUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodeUsages and returns the data saved in the database.
     * @param {PromoCodeUsageCreateManyAndReturnArgs} args - Arguments to create many PromoCodeUsages.
     * @example
     * // Create many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodeUsages and only return the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromoCodeUsage.
     * @param {PromoCodeUsageDeleteArgs} args - Arguments to delete one PromoCodeUsage.
     * @example
     * // Delete one PromoCodeUsage
     * const PromoCodeUsage = await prisma.promoCodeUsage.delete({
     *   where: {
     *     // ... filter to delete one PromoCodeUsage
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeUsageDeleteArgs>(args: SelectSubset<T, PromoCodeUsageDeleteArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromoCodeUsage.
     * @param {PromoCodeUsageUpdateArgs} args - Arguments to update one PromoCodeUsage.
     * @example
     * // Update one PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUsageUpdateArgs>(args: SelectSubset<T, PromoCodeUsageUpdateArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromoCodeUsages.
     * @param {PromoCodeUsageDeleteManyArgs} args - Arguments to filter PromoCodeUsages to delete.
     * @example
     * // Delete a few PromoCodeUsages
     * const { count } = await prisma.promoCodeUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeUsageDeleteManyArgs>(args?: SelectSubset<T, PromoCodeUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodeUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUsageUpdateManyArgs>(args: SelectSubset<T, PromoCodeUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodeUsages and returns the data updated in the database.
     * @param {PromoCodeUsageUpdateManyAndReturnArgs} args - Arguments to update many PromoCodeUsages.
     * @example
     * // Update many PromoCodeUsages
     * const promoCodeUsage = await prisma.promoCodeUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromoCodeUsages and only return the `id`
     * const promoCodeUsageWithIdOnly = await prisma.promoCodeUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromoCodeUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromoCodeUsage.
     * @param {PromoCodeUsageUpsertArgs} args - Arguments to update or create a PromoCodeUsage.
     * @example
     * // Update or create a PromoCodeUsage
     * const promoCodeUsage = await prisma.promoCodeUsage.upsert({
     *   create: {
     *     // ... data to create a PromoCodeUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCodeUsage we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUsageUpsertArgs>(args: SelectSubset<T, PromoCodeUsageUpsertArgs<ExtArgs>>): Prisma__PromoCodeUsageClient<$Result.GetResult<Prisma.$PromoCodeUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromoCodeUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageCountArgs} args - Arguments to filter PromoCodeUsages to count.
     * @example
     * // Count the number of PromoCodeUsages
     * const count = await prisma.promoCodeUsage.count({
     *   where: {
     *     // ... the filter for the PromoCodeUsages we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeUsageCountArgs>(
      args?: Subset<T, PromoCodeUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCodeUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeUsageAggregateArgs>(args: Subset<T, PromoCodeUsageAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeUsageAggregateType<T>>

    /**
     * Group by PromoCodeUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeUsageGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCodeUsage model
   */
  readonly fields: PromoCodeUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCodeUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    promoCode<T extends PromoCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromoCodeDefaultArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends PromoCodeUsage$orderArgs<ExtArgs> = {}>(args?: Subset<T, PromoCodeUsage$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCodeUsage model
   */
  interface PromoCodeUsageFieldRefs {
    readonly id: FieldRef<"PromoCodeUsage", 'String'>
    readonly promoCodeId: FieldRef<"PromoCodeUsage", 'String'>
    readonly userId: FieldRef<"PromoCodeUsage", 'String'>
    readonly orderId: FieldRef<"PromoCodeUsage", 'String'>
    readonly createdAt: FieldRef<"PromoCodeUsage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCodeUsage findUnique
   */
  export type PromoCodeUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage findUniqueOrThrow
   */
  export type PromoCodeUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage findFirst
   */
  export type PromoCodeUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodeUsages.
     */
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage findFirstOrThrow
   */
  export type PromoCodeUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsage to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodeUsages.
     */
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage findMany
   */
  export type PromoCodeUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodeUsages to fetch.
     */
    where?: PromoCodeUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodeUsages to fetch.
     */
    orderBy?: PromoCodeUsageOrderByWithRelationInput | PromoCodeUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodeUsages.
     */
    cursor?: PromoCodeUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodeUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodeUsages.
     */
    skip?: number
    distinct?: PromoCodeUsageScalarFieldEnum | PromoCodeUsageScalarFieldEnum[]
  }

  /**
   * PromoCodeUsage create
   */
  export type PromoCodeUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCodeUsage.
     */
    data: XOR<PromoCodeUsageCreateInput, PromoCodeUsageUncheckedCreateInput>
  }

  /**
   * PromoCodeUsage createMany
   */
  export type PromoCodeUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodeUsages.
     */
    data: PromoCodeUsageCreateManyInput | PromoCodeUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCodeUsage createManyAndReturn
   */
  export type PromoCodeUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * The data used to create many PromoCodeUsages.
     */
    data: PromoCodeUsageCreateManyInput | PromoCodeUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCodeUsage update
   */
  export type PromoCodeUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCodeUsage.
     */
    data: XOR<PromoCodeUsageUpdateInput, PromoCodeUsageUncheckedUpdateInput>
    /**
     * Choose, which PromoCodeUsage to update.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage updateMany
   */
  export type PromoCodeUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodeUsages.
     */
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodeUsages to update
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to update.
     */
    limit?: number
  }

  /**
   * PromoCodeUsage updateManyAndReturn
   */
  export type PromoCodeUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * The data used to update PromoCodeUsages.
     */
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodeUsages to update
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCodeUsage upsert
   */
  export type PromoCodeUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCodeUsage to update in case it exists.
     */
    where: PromoCodeUsageWhereUniqueInput
    /**
     * In case the PromoCodeUsage found by the `where` argument doesn't exist, create a new PromoCodeUsage with this data.
     */
    create: XOR<PromoCodeUsageCreateInput, PromoCodeUsageUncheckedCreateInput>
    /**
     * In case the PromoCodeUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUsageUpdateInput, PromoCodeUsageUncheckedUpdateInput>
  }

  /**
   * PromoCodeUsage delete
   */
  export type PromoCodeUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
    /**
     * Filter which PromoCodeUsage to delete.
     */
    where: PromoCodeUsageWhereUniqueInput
  }

  /**
   * PromoCodeUsage deleteMany
   */
  export type PromoCodeUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodeUsages to delete
     */
    where?: PromoCodeUsageWhereInput
    /**
     * Limit how many PromoCodeUsages to delete.
     */
    limit?: number
  }

  /**
   * PromoCodeUsage.order
   */
  export type PromoCodeUsage$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * PromoCodeUsage without action
   */
  export type PromoCodeUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCodeUsage
     */
    select?: PromoCodeUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromoCodeUsage
     */
    omit?: PromoCodeUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeUsageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    customerGroupId: 'customerGroupId',
    personalDiscount: 'personalDiscount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AnonymousUserScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    lastActivity: 'lastActivity'
  };

  export type AnonymousUserScalarFieldEnum = (typeof AnonymousUserScalarFieldEnum)[keyof typeof AnonymousUserScalarFieldEnum]


  export const PushSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    endpoint: 'endpoint',
    p256dh: 'p256dh',
    auth: 'auth',
    userAgent: 'userAgent',
    deviceName: 'deviceName',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastUsedAt: 'lastUsedAt'
  };

  export type PushSubscriptionScalarFieldEnum = (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    newChat: 'newChat',
    newMessage: 'newMessage',
    chatAssigned: 'chatAssigned',
    chatStatusChanged: 'chatStatusChanged',
    orderStatusChanged: 'orderStatusChanged',
    enableSchedule: 'enableSchedule',
    scheduleStart: 'scheduleStart',
    scheduleEnd: 'scheduleEnd',
    scheduleTimezone: 'scheduleTimezone',
    scheduleDays: 'scheduleDays',
    soundEnabled: 'soundEnabled',
    vibrationEnabled: 'vibrationEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    data: 'data',
    subscriptionId: 'subscriptionId',
    status: 'status',
    errorMessage: 'errorMessage',
    sentAt: 'sentAt',
    clickedAt: 'clickedAt'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    parentId: 'parentId',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    shortDescription: 'shortDescription',
    sku: 'sku',
    price: 'price',
    comparePrice: 'comparePrice',
    stock: 'stock',
    deliveryDays: 'deliveryDays',
    brandId: 'brandId',
    isOriginal: 'isOriginal',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    categoryId: 'categoryId',
    isPrimary: 'isPrimary'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    url: 'url',
    alt: 'alt',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    description: 'description',
    country: 'country',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const CharacteristicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    type: 'type',
    unit: 'unit',
    isRequired: 'isRequired',
    isFilterable: 'isFilterable',
    filterType: 'filterType',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type CharacteristicScalarFieldEnum = (typeof CharacteristicScalarFieldEnum)[keyof typeof CharacteristicScalarFieldEnum]


  export const CharacteristicCategoryScalarFieldEnum: {
    id: 'id',
    characteristicId: 'characteristicId',
    categoryId: 'categoryId'
  };

  export type CharacteristicCategoryScalarFieldEnum = (typeof CharacteristicCategoryScalarFieldEnum)[keyof typeof CharacteristicCategoryScalarFieldEnum]


  export const CharacteristicValueScalarFieldEnum: {
    id: 'id',
    characteristicId: 'characteristicId',
    value: 'value',
    sortOrder: 'sortOrder'
  };

  export type CharacteristicValueScalarFieldEnum = (typeof CharacteristicValueScalarFieldEnum)[keyof typeof CharacteristicValueScalarFieldEnum]


  export const ProductCharacteristicScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    characteristicId: 'characteristicId',
    value: 'value',
    characteristicValueId: 'characteristicValueId'
  };

  export type ProductCharacteristicScalarFieldEnum = (typeof ProductCharacteristicScalarFieldEnum)[keyof typeof ProductCharacteristicScalarFieldEnum]


  export const VehicleMakeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    country: 'country',
    logoUrl: 'logoUrl',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords'
  };

  export type VehicleMakeScalarFieldEnum = (typeof VehicleMakeScalarFieldEnum)[keyof typeof VehicleMakeScalarFieldEnum]


  export const VehicleModelScalarFieldEnum: {
    id: 'id',
    makeId: 'makeId',
    name: 'name',
    slug: 'slug',
    modelCode: 'modelCode',
    startYear: 'startYear',
    endYear: 'endYear',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords'
  };

  export type VehicleModelScalarFieldEnum = (typeof VehicleModelScalarFieldEnum)[keyof typeof VehicleModelScalarFieldEnum]


  export const VehicleGenerationScalarFieldEnum: {
    id: 'id',
    modelId: 'modelId',
    name: 'name',
    slug: 'slug',
    startYear: 'startYear',
    endYear: 'endYear',
    bodyType: 'bodyType',
    description: 'description',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords'
  };

  export type VehicleGenerationScalarFieldEnum = (typeof VehicleGenerationScalarFieldEnum)[keyof typeof VehicleGenerationScalarFieldEnum]


  export const VehicleModificationScalarFieldEnum: {
    id: 'id',
    generationId: 'generationId',
    name: 'name',
    engineCode: 'engineCode',
    fuelType: 'fuelType',
    powerHp: 'powerHp',
    transmission: 'transmission'
  };

  export type VehicleModificationScalarFieldEnum = (typeof VehicleModificationScalarFieldEnum)[keyof typeof VehicleModificationScalarFieldEnum]


  export const VehicleApplicationScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    modificationId: 'modificationId',
    kTypeId: 'kTypeId',
    notes: 'notes',
    isVerified: 'isVerified'
  };

  export type VehicleApplicationScalarFieldEnum = (typeof VehicleApplicationScalarFieldEnum)[keyof typeof VehicleApplicationScalarFieldEnum]


  export const CrossReferenceScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    crossPartNumber: 'crossPartNumber',
    crossBrandId: 'crossBrandId',
    crossType: 'crossType',
    confidenceScore: 'confidenceScore',
    verifiedByExpert: 'verifiedByExpert'
  };

  export type CrossReferenceScalarFieldEnum = (typeof CrossReferenceScalarFieldEnum)[keyof typeof CrossReferenceScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const ViewHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonymousId: 'anonymousId',
    productId: 'productId',
    categoryId: 'categoryId',
    viewedAt: 'viewedAt'
  };

  export type ViewHistoryScalarFieldEnum = (typeof ViewHistoryScalarFieldEnum)[keyof typeof ViewHistoryScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonymousId: 'anonymousId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const CartItemScalarFieldEnum: {
    id: 'id',
    cartId: 'cartId',
    productId: 'productId',
    chatProductId: 'chatProductId',
    quantity: 'quantity',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type CartItemScalarFieldEnum = (typeof CartItemScalarFieldEnum)[keyof typeof CartItemScalarFieldEnum]


  export const ChatProductScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    name: 'name',
    brand: 'brand',
    sku: 'sku',
    price: 'price',
    comparePrice: 'comparePrice',
    isOriginal: 'isOriginal',
    deliveryDays: 'deliveryDays',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type ChatProductScalarFieldEnum = (typeof ChatProductScalarFieldEnum)[keyof typeof ChatProductScalarFieldEnum]


  export const ChatProductImageScalarFieldEnum: {
    id: 'id',
    chatProductId: 'chatProductId',
    url: 'url',
    alt: 'alt',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type ChatProductImageScalarFieldEnum = (typeof ChatProductImageScalarFieldEnum)[keyof typeof ChatProductImageScalarFieldEnum]


  export const ChatStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    color: 'color',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ChatStatusScalarFieldEnum = (typeof ChatStatusScalarFieldEnum)[keyof typeof ChatStatusScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonymousId: 'anonymousId',
    managerId: 'managerId',
    statusId: 'statusId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    senderId: 'senderId',
    senderType: 'senderType',
    messageType: 'messageType',
    content: 'content',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const OrderStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    color: 'color',
    description: 'description',
    isInitial: 'isInitial',
    isFinalSuccess: 'isFinalSuccess',
    isFinalFailure: 'isFinalFailure',
    canCancelOrder: 'canCancelOrder',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type OrderStatusScalarFieldEnum = (typeof OrderStatusScalarFieldEnum)[keyof typeof OrderStatusScalarFieldEnum]


  export const DeliveryMethodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    price: 'price',
    minAmount: 'minAmount',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    settings: 'settings',
    createdAt: 'createdAt'
  };

  export type DeliveryMethodScalarFieldEnum = (typeof DeliveryMethodScalarFieldEnum)[keyof typeof DeliveryMethodScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    icon: 'icon',
    isOnline: 'isOnline',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    settings: 'settings',
    commission: 'commission',
    createdAt: 'createdAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    userId: 'userId',
    statusId: 'statusId',
    subtotal: 'subtotal',
    discountAmount: 'discountAmount',
    shippingAmount: 'shippingAmount',
    totalAmount: 'totalAmount',
    deliveryMethodId: 'deliveryMethodId',
    paymentMethodId: 'paymentMethodId',
    shippingAddress: 'shippingAddress',
    comment: 'comment',
    promoCodeId: 'promoCodeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    chatProductId: 'chatProductId',
    quantity: 'quantity',
    price: 'price',
    total: 'total'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderStatusLogScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    statusId: 'statusId',
    comment: 'comment',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type OrderStatusLogScalarFieldEnum = (typeof OrderStatusLogScalarFieldEnum)[keyof typeof OrderStatusLogScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    amount: 'amount',
    status: 'status',
    transactionId: 'transactionId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CustomerGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    discountPercent: 'discountPercent',
    minOrderAmount: 'minOrderAmount',
    benefits: 'benefits'
  };

  export type CustomerGroupScalarFieldEnum = (typeof CustomerGroupScalarFieldEnum)[keyof typeof CustomerGroupScalarFieldEnum]


  export const DiscountRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    value: 'value',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    startDate: 'startDate',
    endDate: 'endDate',
    usageLimit: 'usageLimit',
    customerGroupId: 'customerGroupId',
    categories: 'categories',
    brands: 'brands',
    isActive: 'isActive'
  };

  export type DiscountRuleScalarFieldEnum = (typeof DiscountRuleScalarFieldEnum)[keyof typeof DiscountRuleScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    discountRuleId: 'discountRuleId',
    usageCount: 'usageCount',
    usageLimit: 'usageLimit',
    personalUserId: 'personalUserId',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const PromoCodeUsageScalarFieldEnum: {
    id: 'id',
    promoCodeId: 'promoCodeId',
    userId: 'userId',
    orderId: 'orderId',
    createdAt: 'createdAt'
  };

  export type PromoCodeUsageScalarFieldEnum = (typeof PromoCodeUsageScalarFieldEnum)[keyof typeof PromoCodeUsageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CrossType'
   */
  export type EnumCrossTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrossType'>
    


  /**
   * Reference to a field of type 'CrossType[]'
   */
  export type ListEnumCrossTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrossType[]'>
    


  /**
   * Reference to a field of type 'SenderType'
   */
  export type EnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType'>
    


  /**
   * Reference to a field of type 'SenderType[]'
   */
  export type ListEnumSenderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SenderType[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    customerGroupId?: StringNullableFilter<"User"> | string | null
    personalDiscount?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    customerGroup?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    carts?: CartListRelationFilter
    orders?: OrderListRelationFilter
    chats?: ChatListRelationFilter
    managedChats?: ChatListRelationFilter
    favorites?: FavoriteListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
    personalPromoCodes?: PromoCodeListRelationFilter
    promoCodeUsage?: PromoCodeUsageListRelationFilter
    orderStatusLogs?: OrderStatusLogListRelationFilter
    PushSubscription?: PushSubscriptionListRelationFilter
    NotificationSettings?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    NotificationLog?: NotificationLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    customerGroupId?: SortOrderInput | SortOrder
    personalDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    customerGroup?: CustomerGroupOrderByWithRelationInput
    carts?: CartOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    managedChats?: ChatOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    viewHistory?: ViewHistoryOrderByRelationAggregateInput
    personalPromoCodes?: PromoCodeOrderByRelationAggregateInput
    promoCodeUsage?: PromoCodeUsageOrderByRelationAggregateInput
    orderStatusLogs?: OrderStatusLogOrderByRelationAggregateInput
    PushSubscription?: PushSubscriptionOrderByRelationAggregateInput
    NotificationSettings?: NotificationSettingsOrderByWithRelationInput
    NotificationLog?: NotificationLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    customerGroupId?: StringNullableFilter<"User"> | string | null
    personalDiscount?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    customerGroup?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    carts?: CartListRelationFilter
    orders?: OrderListRelationFilter
    chats?: ChatListRelationFilter
    managedChats?: ChatListRelationFilter
    favorites?: FavoriteListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
    personalPromoCodes?: PromoCodeListRelationFilter
    promoCodeUsage?: PromoCodeUsageListRelationFilter
    orderStatusLogs?: OrderStatusLogListRelationFilter
    PushSubscription?: PushSubscriptionListRelationFilter
    NotificationSettings?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    NotificationLog?: NotificationLogListRelationFilter
  }, "id" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    customerGroupId?: SortOrderInput | SortOrder
    personalDiscount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    customerGroupId?: StringNullableWithAggregatesFilter<"User"> | string | null
    personalDiscount?: DecimalNullableWithAggregatesFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AnonymousUserWhereInput = {
    AND?: AnonymousUserWhereInput | AnonymousUserWhereInput[]
    OR?: AnonymousUserWhereInput[]
    NOT?: AnonymousUserWhereInput | AnonymousUserWhereInput[]
    id?: StringFilter<"AnonymousUser"> | string
    sessionId?: StringFilter<"AnonymousUser"> | string
    ipAddress?: StringNullableFilter<"AnonymousUser"> | string | null
    userAgent?: StringNullableFilter<"AnonymousUser"> | string | null
    createdAt?: DateTimeFilter<"AnonymousUser"> | Date | string
    lastActivity?: DateTimeFilter<"AnonymousUser"> | Date | string
    carts?: CartListRelationFilter
    chats?: ChatListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }

  export type AnonymousUserOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    carts?: CartOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    viewHistory?: ViewHistoryOrderByRelationAggregateInput
  }

  export type AnonymousUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: AnonymousUserWhereInput | AnonymousUserWhereInput[]
    OR?: AnonymousUserWhereInput[]
    NOT?: AnonymousUserWhereInput | AnonymousUserWhereInput[]
    ipAddress?: StringNullableFilter<"AnonymousUser"> | string | null
    userAgent?: StringNullableFilter<"AnonymousUser"> | string | null
    createdAt?: DateTimeFilter<"AnonymousUser"> | Date | string
    lastActivity?: DateTimeFilter<"AnonymousUser"> | Date | string
    carts?: CartListRelationFilter
    chats?: ChatListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }, "id" | "sessionId">

  export type AnonymousUserOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
    _count?: AnonymousUserCountOrderByAggregateInput
    _max?: AnonymousUserMaxOrderByAggregateInput
    _min?: AnonymousUserMinOrderByAggregateInput
  }

  export type AnonymousUserScalarWhereWithAggregatesInput = {
    AND?: AnonymousUserScalarWhereWithAggregatesInput | AnonymousUserScalarWhereWithAggregatesInput[]
    OR?: AnonymousUserScalarWhereWithAggregatesInput[]
    NOT?: AnonymousUserScalarWhereWithAggregatesInput | AnonymousUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnonymousUser"> | string
    sessionId?: StringWithAggregatesFilter<"AnonymousUser"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"AnonymousUser"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AnonymousUser"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnonymousUser"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"AnonymousUser"> | Date | string
  }

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    lastUsedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    endpoint?: string
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    OR?: PushSubscriptionWhereInput[]
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[]
    userId?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    lastUsedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "endpoint">

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    deviceName?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
    _count?: PushSubscriptionCountOrderByAggregateInput
    _max?: PushSubscriptionMaxOrderByAggregateInput
    _min?: PushSubscriptionMinOrderByAggregateInput
  }

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: PushSubscriptionScalarWhereWithAggregatesInput | PushSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PushSubscription"> | string
    userId?: StringWithAggregatesFilter<"PushSubscription"> | string
    endpoint?: StringWithAggregatesFilter<"PushSubscription"> | string
    p256dh?: StringWithAggregatesFilter<"PushSubscription"> | string
    auth?: StringWithAggregatesFilter<"PushSubscription"> | string
    userAgent?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableWithAggregatesFilter<"PushSubscription"> | string | null
    isActive?: BoolWithAggregatesFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
    lastUsedAt?: DateTimeWithAggregatesFilter<"PushSubscription"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    newChat?: BoolFilter<"NotificationSettings"> | boolean
    newMessage?: BoolFilter<"NotificationSettings"> | boolean
    chatAssigned?: BoolFilter<"NotificationSettings"> | boolean
    chatStatusChanged?: BoolFilter<"NotificationSettings"> | boolean
    orderStatusChanged?: BoolFilter<"NotificationSettings"> | boolean
    enableSchedule?: BoolFilter<"NotificationSettings"> | boolean
    scheduleStart?: StringNullableFilter<"NotificationSettings"> | string | null
    scheduleEnd?: StringNullableFilter<"NotificationSettings"> | string | null
    scheduleTimezone?: StringFilter<"NotificationSettings"> | string
    scheduleDays?: JsonNullableFilter<"NotificationSettings">
    soundEnabled?: BoolFilter<"NotificationSettings"> | boolean
    vibrationEnabled?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    newChat?: SortOrder
    newMessage?: SortOrder
    chatAssigned?: SortOrder
    chatStatusChanged?: SortOrder
    orderStatusChanged?: SortOrder
    enableSchedule?: SortOrder
    scheduleStart?: SortOrderInput | SortOrder
    scheduleEnd?: SortOrderInput | SortOrder
    scheduleTimezone?: SortOrder
    scheduleDays?: SortOrderInput | SortOrder
    soundEnabled?: SortOrder
    vibrationEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    newChat?: BoolFilter<"NotificationSettings"> | boolean
    newMessage?: BoolFilter<"NotificationSettings"> | boolean
    chatAssigned?: BoolFilter<"NotificationSettings"> | boolean
    chatStatusChanged?: BoolFilter<"NotificationSettings"> | boolean
    orderStatusChanged?: BoolFilter<"NotificationSettings"> | boolean
    enableSchedule?: BoolFilter<"NotificationSettings"> | boolean
    scheduleStart?: StringNullableFilter<"NotificationSettings"> | string | null
    scheduleEnd?: StringNullableFilter<"NotificationSettings"> | string | null
    scheduleTimezone?: StringFilter<"NotificationSettings"> | string
    scheduleDays?: JsonNullableFilter<"NotificationSettings">
    soundEnabled?: BoolFilter<"NotificationSettings"> | boolean
    vibrationEnabled?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    newChat?: SortOrder
    newMessage?: SortOrder
    chatAssigned?: SortOrder
    chatStatusChanged?: SortOrder
    orderStatusChanged?: SortOrder
    enableSchedule?: SortOrder
    scheduleStart?: SortOrderInput | SortOrder
    scheduleEnd?: SortOrderInput | SortOrder
    scheduleTimezone?: SortOrder
    scheduleDays?: SortOrderInput | SortOrder
    soundEnabled?: SortOrder
    vibrationEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    userId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    newChat?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    newMessage?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    chatAssigned?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    chatStatusChanged?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    orderStatusChanged?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    enableSchedule?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    scheduleStart?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    scheduleEnd?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
    scheduleTimezone?: StringWithAggregatesFilter<"NotificationSettings"> | string
    scheduleDays?: JsonNullableWithAggregatesFilter<"NotificationSettings">
    soundEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    vibrationEnabled?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    body?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    status?: StringFilter<"NotificationLog"> | string
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    clickedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    clickedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    body?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    status?: StringFilter<"NotificationLog"> | string
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    clickedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sentAt?: SortOrder
    clickedAt?: SortOrderInput | SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    userId?: StringWithAggregatesFilter<"NotificationLog"> | string
    type?: StringWithAggregatesFilter<"NotificationLog"> | string
    title?: StringWithAggregatesFilter<"NotificationLog"> | string
    body?: StringWithAggregatesFilter<"NotificationLog"> | string
    data?: JsonNullableWithAggregatesFilter<"NotificationLog">
    subscriptionId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    status?: StringWithAggregatesFilter<"NotificationLog"> | string
    errorMessage?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    clickedAt?: DateTimeNullableWithAggregatesFilter<"NotificationLog"> | Date | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductCategoryListRelationFilter
    characteristics?: CharacteristicCategoryListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    products?: ProductCategoryOrderByRelationAggregateInput
    characteristics?: CharacteristicCategoryOrderByRelationAggregateInput
    viewHistory?: ViewHistoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductCategoryListRelationFilter
    characteristics?: CharacteristicCategoryListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Category"> | number
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Category"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    deliveryDays?: IntNullableFilter<"Product"> | number | null
    brandId?: StringFilter<"Product"> | string
    isOriginal?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    categories?: ProductCategoryListRelationFilter
    images?: ProductImageListRelationFilter
    characteristics?: ProductCharacteristicListRelationFilter
    vehicleApplications?: VehicleApplicationListRelationFilter
    crossReferences?: CrossReferenceListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
    favorites?: FavoriteListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    brandId?: SortOrder
    isOriginal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    brand?: BrandOrderByWithRelationInput
    categories?: ProductCategoryOrderByRelationAggregateInput
    images?: ProductImageOrderByRelationAggregateInput
    characteristics?: ProductCharacteristicOrderByRelationAggregateInput
    vehicleApplications?: VehicleApplicationOrderByRelationAggregateInput
    crossReferences?: CrossReferenceOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    viewHistory?: ViewHistoryOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    sku?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    deliveryDays?: IntNullableFilter<"Product"> | number | null
    brandId?: StringFilter<"Product"> | string
    isOriginal?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    categories?: ProductCategoryListRelationFilter
    images?: ProductImageListRelationFilter
    characteristics?: ProductCharacteristicListRelationFilter
    vehicleApplications?: VehicleApplicationListRelationFilter
    crossReferences?: CrossReferenceListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
    favorites?: FavoriteListRelationFilter
    viewHistory?: ViewHistoryListRelationFilter
  }, "id" | "slug" | "sku">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    shortDescription?: SortOrderInput | SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    brandId?: SortOrder
    isOriginal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    shortDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
    sku?: StringWithAggregatesFilter<"Product"> | string
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    deliveryDays?: IntNullableWithAggregatesFilter<"Product"> | number | null
    brandId?: StringWithAggregatesFilter<"Product"> | string
    isOriginal?: BoolWithAggregatesFilter<"Product"> | boolean
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    isPrimary?: BoolFilter<"ProductCategory"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_categoryId?: ProductCategoryProductIdCategoryIdCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    isPrimary?: BoolFilter<"ProductCategory"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "productId_categoryId">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    productId?: StringWithAggregatesFilter<"ProductCategory"> | string
    categoryId?: StringWithAggregatesFilter<"ProductCategory"> | string
    isPrimary?: BoolWithAggregatesFilter<"ProductCategory"> | boolean
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    alt?: StringNullableFilter<"ProductImage"> | string | null
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    alt?: StringNullableFilter<"ProductImage"> | string | null
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductImage"> | string
    productId?: StringWithAggregatesFilter<"ProductImage"> | string
    url?: StringWithAggregatesFilter<"ProductImage"> | string
    alt?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ProductImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    slug?: StringFilter<"Brand"> | string
    logo?: StringNullableFilter<"Brand"> | string | null
    description?: StringNullableFilter<"Brand"> | string | null
    country?: StringNullableFilter<"Brand"> | string | null
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    products?: ProductListRelationFilter
    crossReferences?: CrossReferenceListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    crossReferences?: CrossReferenceOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    logo?: StringNullableFilter<"Brand"> | string | null
    description?: StringNullableFilter<"Brand"> | string | null
    country?: StringNullableFilter<"Brand"> | string | null
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    products?: ProductListRelationFilter
    crossReferences?: CrossReferenceListRelationFilter
  }, "id" | "name" | "slug">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    slug?: StringWithAggregatesFilter<"Brand"> | string
    logo?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    country?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    isActive?: BoolWithAggregatesFilter<"Brand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type CharacteristicWhereInput = {
    AND?: CharacteristicWhereInput | CharacteristicWhereInput[]
    OR?: CharacteristicWhereInput[]
    NOT?: CharacteristicWhereInput | CharacteristicWhereInput[]
    id?: StringFilter<"Characteristic"> | string
    name?: StringFilter<"Characteristic"> | string
    code?: StringFilter<"Characteristic"> | string
    type?: StringFilter<"Characteristic"> | string
    unit?: StringNullableFilter<"Characteristic"> | string | null
    isRequired?: BoolFilter<"Characteristic"> | boolean
    isFilterable?: BoolFilter<"Characteristic"> | boolean
    filterType?: StringNullableFilter<"Characteristic"> | string | null
    sortOrder?: IntFilter<"Characteristic"> | number
    createdAt?: DateTimeFilter<"Characteristic"> | Date | string
    values?: CharacteristicValueListRelationFilter
    productValues?: ProductCharacteristicListRelationFilter
    categories?: CharacteristicCategoryListRelationFilter
  }

  export type CharacteristicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    unit?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    filterType?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    values?: CharacteristicValueOrderByRelationAggregateInput
    productValues?: ProductCharacteristicOrderByRelationAggregateInput
    categories?: CharacteristicCategoryOrderByRelationAggregateInput
  }

  export type CharacteristicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CharacteristicWhereInput | CharacteristicWhereInput[]
    OR?: CharacteristicWhereInput[]
    NOT?: CharacteristicWhereInput | CharacteristicWhereInput[]
    name?: StringFilter<"Characteristic"> | string
    type?: StringFilter<"Characteristic"> | string
    unit?: StringNullableFilter<"Characteristic"> | string | null
    isRequired?: BoolFilter<"Characteristic"> | boolean
    isFilterable?: BoolFilter<"Characteristic"> | boolean
    filterType?: StringNullableFilter<"Characteristic"> | string | null
    sortOrder?: IntFilter<"Characteristic"> | number
    createdAt?: DateTimeFilter<"Characteristic"> | Date | string
    values?: CharacteristicValueListRelationFilter
    productValues?: ProductCharacteristicListRelationFilter
    categories?: CharacteristicCategoryListRelationFilter
  }, "id" | "code">

  export type CharacteristicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    unit?: SortOrderInput | SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    filterType?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: CharacteristicCountOrderByAggregateInput
    _avg?: CharacteristicAvgOrderByAggregateInput
    _max?: CharacteristicMaxOrderByAggregateInput
    _min?: CharacteristicMinOrderByAggregateInput
    _sum?: CharacteristicSumOrderByAggregateInput
  }

  export type CharacteristicScalarWhereWithAggregatesInput = {
    AND?: CharacteristicScalarWhereWithAggregatesInput | CharacteristicScalarWhereWithAggregatesInput[]
    OR?: CharacteristicScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicScalarWhereWithAggregatesInput | CharacteristicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Characteristic"> | string
    name?: StringWithAggregatesFilter<"Characteristic"> | string
    code?: StringWithAggregatesFilter<"Characteristic"> | string
    type?: StringWithAggregatesFilter<"Characteristic"> | string
    unit?: StringNullableWithAggregatesFilter<"Characteristic"> | string | null
    isRequired?: BoolWithAggregatesFilter<"Characteristic"> | boolean
    isFilterable?: BoolWithAggregatesFilter<"Characteristic"> | boolean
    filterType?: StringNullableWithAggregatesFilter<"Characteristic"> | string | null
    sortOrder?: IntWithAggregatesFilter<"Characteristic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Characteristic"> | Date | string
  }

  export type CharacteristicCategoryWhereInput = {
    AND?: CharacteristicCategoryWhereInput | CharacteristicCategoryWhereInput[]
    OR?: CharacteristicCategoryWhereInput[]
    NOT?: CharacteristicCategoryWhereInput | CharacteristicCategoryWhereInput[]
    id?: StringFilter<"CharacteristicCategory"> | string
    characteristicId?: StringFilter<"CharacteristicCategory"> | string
    categoryId?: StringFilter<"CharacteristicCategory"> | string
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type CharacteristicCategoryOrderByWithRelationInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    categoryId?: SortOrder
    characteristic?: CharacteristicOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type CharacteristicCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characteristicId_categoryId?: CharacteristicCategoryCharacteristicIdCategoryIdCompoundUniqueInput
    AND?: CharacteristicCategoryWhereInput | CharacteristicCategoryWhereInput[]
    OR?: CharacteristicCategoryWhereInput[]
    NOT?: CharacteristicCategoryWhereInput | CharacteristicCategoryWhereInput[]
    characteristicId?: StringFilter<"CharacteristicCategory"> | string
    categoryId?: StringFilter<"CharacteristicCategory"> | string
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "characteristicId_categoryId">

  export type CharacteristicCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    categoryId?: SortOrder
    _count?: CharacteristicCategoryCountOrderByAggregateInput
    _max?: CharacteristicCategoryMaxOrderByAggregateInput
    _min?: CharacteristicCategoryMinOrderByAggregateInput
  }

  export type CharacteristicCategoryScalarWhereWithAggregatesInput = {
    AND?: CharacteristicCategoryScalarWhereWithAggregatesInput | CharacteristicCategoryScalarWhereWithAggregatesInput[]
    OR?: CharacteristicCategoryScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicCategoryScalarWhereWithAggregatesInput | CharacteristicCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacteristicCategory"> | string
    characteristicId?: StringWithAggregatesFilter<"CharacteristicCategory"> | string
    categoryId?: StringWithAggregatesFilter<"CharacteristicCategory"> | string
  }

  export type CharacteristicValueWhereInput = {
    AND?: CharacteristicValueWhereInput | CharacteristicValueWhereInput[]
    OR?: CharacteristicValueWhereInput[]
    NOT?: CharacteristicValueWhereInput | CharacteristicValueWhereInput[]
    id?: StringFilter<"CharacteristicValue"> | string
    characteristicId?: StringFilter<"CharacteristicValue"> | string
    value?: StringFilter<"CharacteristicValue"> | string
    sortOrder?: IntFilter<"CharacteristicValue"> | number
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    productValues?: ProductCharacteristicListRelationFilter
  }

  export type CharacteristicValueOrderByWithRelationInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
    characteristic?: CharacteristicOrderByWithRelationInput
    productValues?: ProductCharacteristicOrderByRelationAggregateInput
  }

  export type CharacteristicValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacteristicValueWhereInput | CharacteristicValueWhereInput[]
    OR?: CharacteristicValueWhereInput[]
    NOT?: CharacteristicValueWhereInput | CharacteristicValueWhereInput[]
    characteristicId?: StringFilter<"CharacteristicValue"> | string
    value?: StringFilter<"CharacteristicValue"> | string
    sortOrder?: IntFilter<"CharacteristicValue"> | number
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    productValues?: ProductCharacteristicListRelationFilter
  }, "id">

  export type CharacteristicValueOrderByWithAggregationInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
    _count?: CharacteristicValueCountOrderByAggregateInput
    _avg?: CharacteristicValueAvgOrderByAggregateInput
    _max?: CharacteristicValueMaxOrderByAggregateInput
    _min?: CharacteristicValueMinOrderByAggregateInput
    _sum?: CharacteristicValueSumOrderByAggregateInput
  }

  export type CharacteristicValueScalarWhereWithAggregatesInput = {
    AND?: CharacteristicValueScalarWhereWithAggregatesInput | CharacteristicValueScalarWhereWithAggregatesInput[]
    OR?: CharacteristicValueScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicValueScalarWhereWithAggregatesInput | CharacteristicValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacteristicValue"> | string
    characteristicId?: StringWithAggregatesFilter<"CharacteristicValue"> | string
    value?: StringWithAggregatesFilter<"CharacteristicValue"> | string
    sortOrder?: IntWithAggregatesFilter<"CharacteristicValue"> | number
  }

  export type ProductCharacteristicWhereInput = {
    AND?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    OR?: ProductCharacteristicWhereInput[]
    NOT?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    id?: StringFilter<"ProductCharacteristic"> | string
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    value?: StringNullableFilter<"ProductCharacteristic"> | string | null
    characteristicValueId?: StringNullableFilter<"ProductCharacteristic"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    characteristicValue?: XOR<CharacteristicValueNullableScalarRelationFilter, CharacteristicValueWhereInput> | null
  }

  export type ProductCharacteristicOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrderInput | SortOrder
    characteristicValueId?: SortOrderInput | SortOrder
    product?: ProductOrderByWithRelationInput
    characteristic?: CharacteristicOrderByWithRelationInput
    characteristicValue?: CharacteristicValueOrderByWithRelationInput
  }

  export type ProductCharacteristicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_characteristicId?: ProductCharacteristicProductIdCharacteristicIdCompoundUniqueInput
    AND?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    OR?: ProductCharacteristicWhereInput[]
    NOT?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    value?: StringNullableFilter<"ProductCharacteristic"> | string | null
    characteristicValueId?: StringNullableFilter<"ProductCharacteristic"> | string | null
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    characteristic?: XOR<CharacteristicScalarRelationFilter, CharacteristicWhereInput>
    characteristicValue?: XOR<CharacteristicValueNullableScalarRelationFilter, CharacteristicValueWhereInput> | null
  }, "id" | "productId_characteristicId">

  export type ProductCharacteristicOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrderInput | SortOrder
    characteristicValueId?: SortOrderInput | SortOrder
    _count?: ProductCharacteristicCountOrderByAggregateInput
    _max?: ProductCharacteristicMaxOrderByAggregateInput
    _min?: ProductCharacteristicMinOrderByAggregateInput
  }

  export type ProductCharacteristicScalarWhereWithAggregatesInput = {
    AND?: ProductCharacteristicScalarWhereWithAggregatesInput | ProductCharacteristicScalarWhereWithAggregatesInput[]
    OR?: ProductCharacteristicScalarWhereWithAggregatesInput[]
    NOT?: ProductCharacteristicScalarWhereWithAggregatesInput | ProductCharacteristicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    productId?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    characteristicId?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    value?: StringNullableWithAggregatesFilter<"ProductCharacteristic"> | string | null
    characteristicValueId?: StringNullableWithAggregatesFilter<"ProductCharacteristic"> | string | null
  }

  export type VehicleMakeWhereInput = {
    AND?: VehicleMakeWhereInput | VehicleMakeWhereInput[]
    OR?: VehicleMakeWhereInput[]
    NOT?: VehicleMakeWhereInput | VehicleMakeWhereInput[]
    id?: StringFilter<"VehicleMake"> | string
    name?: StringFilter<"VehicleMake"> | string
    slug?: StringFilter<"VehicleMake"> | string
    country?: StringNullableFilter<"VehicleMake"> | string | null
    logoUrl?: StringNullableFilter<"VehicleMake"> | string | null
    description?: StringNullableFilter<"VehicleMake"> | string | null
    metaTitle?: StringNullableFilter<"VehicleMake"> | string | null
    metaDescription?: StringNullableFilter<"VehicleMake"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleMake"> | string | null
    models?: VehicleModelListRelationFilter
  }

  export type VehicleMakeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    models?: VehicleModelOrderByRelationAggregateInput
  }

  export type VehicleMakeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VehicleMakeWhereInput | VehicleMakeWhereInput[]
    OR?: VehicleMakeWhereInput[]
    NOT?: VehicleMakeWhereInput | VehicleMakeWhereInput[]
    name?: StringFilter<"VehicleMake"> | string
    country?: StringNullableFilter<"VehicleMake"> | string | null
    logoUrl?: StringNullableFilter<"VehicleMake"> | string | null
    description?: StringNullableFilter<"VehicleMake"> | string | null
    metaTitle?: StringNullableFilter<"VehicleMake"> | string | null
    metaDescription?: StringNullableFilter<"VehicleMake"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleMake"> | string | null
    models?: VehicleModelListRelationFilter
  }, "id" | "slug">

  export type VehicleMakeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    _count?: VehicleMakeCountOrderByAggregateInput
    _max?: VehicleMakeMaxOrderByAggregateInput
    _min?: VehicleMakeMinOrderByAggregateInput
  }

  export type VehicleMakeScalarWhereWithAggregatesInput = {
    AND?: VehicleMakeScalarWhereWithAggregatesInput | VehicleMakeScalarWhereWithAggregatesInput[]
    OR?: VehicleMakeScalarWhereWithAggregatesInput[]
    NOT?: VehicleMakeScalarWhereWithAggregatesInput | VehicleMakeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleMake"> | string
    name?: StringWithAggregatesFilter<"VehicleMake"> | string
    slug?: StringWithAggregatesFilter<"VehicleMake"> | string
    country?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
    description?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"VehicleMake"> | string | null
  }

  export type VehicleModelWhereInput = {
    AND?: VehicleModelWhereInput | VehicleModelWhereInput[]
    OR?: VehicleModelWhereInput[]
    NOT?: VehicleModelWhereInput | VehicleModelWhereInput[]
    id?: StringFilter<"VehicleModel"> | string
    makeId?: StringFilter<"VehicleModel"> | string
    name?: StringFilter<"VehicleModel"> | string
    slug?: StringFilter<"VehicleModel"> | string
    modelCode?: StringNullableFilter<"VehicleModel"> | string | null
    startYear?: IntFilter<"VehicleModel"> | number
    endYear?: IntNullableFilter<"VehicleModel"> | number | null
    description?: StringNullableFilter<"VehicleModel"> | string | null
    metaTitle?: StringNullableFilter<"VehicleModel"> | string | null
    metaDescription?: StringNullableFilter<"VehicleModel"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleModel"> | string | null
    make?: XOR<VehicleMakeScalarRelationFilter, VehicleMakeWhereInput>
    generations?: VehicleGenerationListRelationFilter
  }

  export type VehicleModelOrderByWithRelationInput = {
    id?: SortOrder
    makeId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    modelCode?: SortOrderInput | SortOrder
    startYear?: SortOrder
    endYear?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    make?: VehicleMakeOrderByWithRelationInput
    generations?: VehicleGenerationOrderByRelationAggregateInput
  }

  export type VehicleModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VehicleModelWhereInput | VehicleModelWhereInput[]
    OR?: VehicleModelWhereInput[]
    NOT?: VehicleModelWhereInput | VehicleModelWhereInput[]
    makeId?: StringFilter<"VehicleModel"> | string
    name?: StringFilter<"VehicleModel"> | string
    modelCode?: StringNullableFilter<"VehicleModel"> | string | null
    startYear?: IntFilter<"VehicleModel"> | number
    endYear?: IntNullableFilter<"VehicleModel"> | number | null
    description?: StringNullableFilter<"VehicleModel"> | string | null
    metaTitle?: StringNullableFilter<"VehicleModel"> | string | null
    metaDescription?: StringNullableFilter<"VehicleModel"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleModel"> | string | null
    make?: XOR<VehicleMakeScalarRelationFilter, VehicleMakeWhereInput>
    generations?: VehicleGenerationListRelationFilter
  }, "id" | "slug">

  export type VehicleModelOrderByWithAggregationInput = {
    id?: SortOrder
    makeId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    modelCode?: SortOrderInput | SortOrder
    startYear?: SortOrder
    endYear?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    _count?: VehicleModelCountOrderByAggregateInput
    _avg?: VehicleModelAvgOrderByAggregateInput
    _max?: VehicleModelMaxOrderByAggregateInput
    _min?: VehicleModelMinOrderByAggregateInput
    _sum?: VehicleModelSumOrderByAggregateInput
  }

  export type VehicleModelScalarWhereWithAggregatesInput = {
    AND?: VehicleModelScalarWhereWithAggregatesInput | VehicleModelScalarWhereWithAggregatesInput[]
    OR?: VehicleModelScalarWhereWithAggregatesInput[]
    NOT?: VehicleModelScalarWhereWithAggregatesInput | VehicleModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleModel"> | string
    makeId?: StringWithAggregatesFilter<"VehicleModel"> | string
    name?: StringWithAggregatesFilter<"VehicleModel"> | string
    slug?: StringWithAggregatesFilter<"VehicleModel"> | string
    modelCode?: StringNullableWithAggregatesFilter<"VehicleModel"> | string | null
    startYear?: IntWithAggregatesFilter<"VehicleModel"> | number
    endYear?: IntNullableWithAggregatesFilter<"VehicleModel"> | number | null
    description?: StringNullableWithAggregatesFilter<"VehicleModel"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"VehicleModel"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"VehicleModel"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"VehicleModel"> | string | null
  }

  export type VehicleGenerationWhereInput = {
    AND?: VehicleGenerationWhereInput | VehicleGenerationWhereInput[]
    OR?: VehicleGenerationWhereInput[]
    NOT?: VehicleGenerationWhereInput | VehicleGenerationWhereInput[]
    id?: StringFilter<"VehicleGeneration"> | string
    modelId?: StringFilter<"VehicleGeneration"> | string
    name?: StringFilter<"VehicleGeneration"> | string
    slug?: StringFilter<"VehicleGeneration"> | string
    startYear?: IntFilter<"VehicleGeneration"> | number
    endYear?: IntNullableFilter<"VehicleGeneration"> | number | null
    bodyType?: StringNullableFilter<"VehicleGeneration"> | string | null
    description?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaTitle?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaDescription?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleGeneration"> | string | null
    model?: XOR<VehicleModelScalarRelationFilter, VehicleModelWhereInput>
    modifications?: VehicleModificationListRelationFilter
  }

  export type VehicleGenerationOrderByWithRelationInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrderInput | SortOrder
    bodyType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    model?: VehicleModelOrderByWithRelationInput
    modifications?: VehicleModificationOrderByRelationAggregateInput
  }

  export type VehicleGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VehicleGenerationWhereInput | VehicleGenerationWhereInput[]
    OR?: VehicleGenerationWhereInput[]
    NOT?: VehicleGenerationWhereInput | VehicleGenerationWhereInput[]
    modelId?: StringFilter<"VehicleGeneration"> | string
    name?: StringFilter<"VehicleGeneration"> | string
    startYear?: IntFilter<"VehicleGeneration"> | number
    endYear?: IntNullableFilter<"VehicleGeneration"> | number | null
    bodyType?: StringNullableFilter<"VehicleGeneration"> | string | null
    description?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaTitle?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaDescription?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleGeneration"> | string | null
    model?: XOR<VehicleModelScalarRelationFilter, VehicleModelWhereInput>
    modifications?: VehicleModificationListRelationFilter
  }, "id" | "slug">

  export type VehicleGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrderInput | SortOrder
    bodyType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    _count?: VehicleGenerationCountOrderByAggregateInput
    _avg?: VehicleGenerationAvgOrderByAggregateInput
    _max?: VehicleGenerationMaxOrderByAggregateInput
    _min?: VehicleGenerationMinOrderByAggregateInput
    _sum?: VehicleGenerationSumOrderByAggregateInput
  }

  export type VehicleGenerationScalarWhereWithAggregatesInput = {
    AND?: VehicleGenerationScalarWhereWithAggregatesInput | VehicleGenerationScalarWhereWithAggregatesInput[]
    OR?: VehicleGenerationScalarWhereWithAggregatesInput[]
    NOT?: VehicleGenerationScalarWhereWithAggregatesInput | VehicleGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleGeneration"> | string
    modelId?: StringWithAggregatesFilter<"VehicleGeneration"> | string
    name?: StringWithAggregatesFilter<"VehicleGeneration"> | string
    slug?: StringWithAggregatesFilter<"VehicleGeneration"> | string
    startYear?: IntWithAggregatesFilter<"VehicleGeneration"> | number
    endYear?: IntNullableWithAggregatesFilter<"VehicleGeneration"> | number | null
    bodyType?: StringNullableWithAggregatesFilter<"VehicleGeneration"> | string | null
    description?: StringNullableWithAggregatesFilter<"VehicleGeneration"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"VehicleGeneration"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"VehicleGeneration"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"VehicleGeneration"> | string | null
  }

  export type VehicleModificationWhereInput = {
    AND?: VehicleModificationWhereInput | VehicleModificationWhereInput[]
    OR?: VehicleModificationWhereInput[]
    NOT?: VehicleModificationWhereInput | VehicleModificationWhereInput[]
    id?: StringFilter<"VehicleModification"> | string
    generationId?: StringFilter<"VehicleModification"> | string
    name?: StringFilter<"VehicleModification"> | string
    engineCode?: StringNullableFilter<"VehicleModification"> | string | null
    fuelType?: StringNullableFilter<"VehicleModification"> | string | null
    powerHp?: IntNullableFilter<"VehicleModification"> | number | null
    transmission?: StringNullableFilter<"VehicleModification"> | string | null
    generation?: XOR<VehicleGenerationScalarRelationFilter, VehicleGenerationWhereInput>
    applications?: VehicleApplicationListRelationFilter
  }

  export type VehicleModificationOrderByWithRelationInput = {
    id?: SortOrder
    generationId?: SortOrder
    name?: SortOrder
    engineCode?: SortOrderInput | SortOrder
    fuelType?: SortOrderInput | SortOrder
    powerHp?: SortOrderInput | SortOrder
    transmission?: SortOrderInput | SortOrder
    generation?: VehicleGenerationOrderByWithRelationInput
    applications?: VehicleApplicationOrderByRelationAggregateInput
  }

  export type VehicleModificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VehicleModificationWhereInput | VehicleModificationWhereInput[]
    OR?: VehicleModificationWhereInput[]
    NOT?: VehicleModificationWhereInput | VehicleModificationWhereInput[]
    generationId?: StringFilter<"VehicleModification"> | string
    name?: StringFilter<"VehicleModification"> | string
    engineCode?: StringNullableFilter<"VehicleModification"> | string | null
    fuelType?: StringNullableFilter<"VehicleModification"> | string | null
    powerHp?: IntNullableFilter<"VehicleModification"> | number | null
    transmission?: StringNullableFilter<"VehicleModification"> | string | null
    generation?: XOR<VehicleGenerationScalarRelationFilter, VehicleGenerationWhereInput>
    applications?: VehicleApplicationListRelationFilter
  }, "id">

  export type VehicleModificationOrderByWithAggregationInput = {
    id?: SortOrder
    generationId?: SortOrder
    name?: SortOrder
    engineCode?: SortOrderInput | SortOrder
    fuelType?: SortOrderInput | SortOrder
    powerHp?: SortOrderInput | SortOrder
    transmission?: SortOrderInput | SortOrder
    _count?: VehicleModificationCountOrderByAggregateInput
    _avg?: VehicleModificationAvgOrderByAggregateInput
    _max?: VehicleModificationMaxOrderByAggregateInput
    _min?: VehicleModificationMinOrderByAggregateInput
    _sum?: VehicleModificationSumOrderByAggregateInput
  }

  export type VehicleModificationScalarWhereWithAggregatesInput = {
    AND?: VehicleModificationScalarWhereWithAggregatesInput | VehicleModificationScalarWhereWithAggregatesInput[]
    OR?: VehicleModificationScalarWhereWithAggregatesInput[]
    NOT?: VehicleModificationScalarWhereWithAggregatesInput | VehicleModificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleModification"> | string
    generationId?: StringWithAggregatesFilter<"VehicleModification"> | string
    name?: StringWithAggregatesFilter<"VehicleModification"> | string
    engineCode?: StringNullableWithAggregatesFilter<"VehicleModification"> | string | null
    fuelType?: StringNullableWithAggregatesFilter<"VehicleModification"> | string | null
    powerHp?: IntNullableWithAggregatesFilter<"VehicleModification"> | number | null
    transmission?: StringNullableWithAggregatesFilter<"VehicleModification"> | string | null
  }

  export type VehicleApplicationWhereInput = {
    AND?: VehicleApplicationWhereInput | VehicleApplicationWhereInput[]
    OR?: VehicleApplicationWhereInput[]
    NOT?: VehicleApplicationWhereInput | VehicleApplicationWhereInput[]
    id?: StringFilter<"VehicleApplication"> | string
    productId?: StringFilter<"VehicleApplication"> | string
    modificationId?: StringFilter<"VehicleApplication"> | string
    kTypeId?: StringNullableFilter<"VehicleApplication"> | string | null
    notes?: StringNullableFilter<"VehicleApplication"> | string | null
    isVerified?: BoolFilter<"VehicleApplication"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    modification?: XOR<VehicleModificationScalarRelationFilter, VehicleModificationWhereInput>
  }

  export type VehicleApplicationOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    modificationId?: SortOrder
    kTypeId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    product?: ProductOrderByWithRelationInput
    modification?: VehicleModificationOrderByWithRelationInput
  }

  export type VehicleApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_modificationId?: VehicleApplicationProductIdModificationIdCompoundUniqueInput
    AND?: VehicleApplicationWhereInput | VehicleApplicationWhereInput[]
    OR?: VehicleApplicationWhereInput[]
    NOT?: VehicleApplicationWhereInput | VehicleApplicationWhereInput[]
    productId?: StringFilter<"VehicleApplication"> | string
    modificationId?: StringFilter<"VehicleApplication"> | string
    kTypeId?: StringNullableFilter<"VehicleApplication"> | string | null
    notes?: StringNullableFilter<"VehicleApplication"> | string | null
    isVerified?: BoolFilter<"VehicleApplication"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    modification?: XOR<VehicleModificationScalarRelationFilter, VehicleModificationWhereInput>
  }, "id" | "productId_modificationId">

  export type VehicleApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    modificationId?: SortOrder
    kTypeId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    _count?: VehicleApplicationCountOrderByAggregateInput
    _max?: VehicleApplicationMaxOrderByAggregateInput
    _min?: VehicleApplicationMinOrderByAggregateInput
  }

  export type VehicleApplicationScalarWhereWithAggregatesInput = {
    AND?: VehicleApplicationScalarWhereWithAggregatesInput | VehicleApplicationScalarWhereWithAggregatesInput[]
    OR?: VehicleApplicationScalarWhereWithAggregatesInput[]
    NOT?: VehicleApplicationScalarWhereWithAggregatesInput | VehicleApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VehicleApplication"> | string
    productId?: StringWithAggregatesFilter<"VehicleApplication"> | string
    modificationId?: StringWithAggregatesFilter<"VehicleApplication"> | string
    kTypeId?: StringNullableWithAggregatesFilter<"VehicleApplication"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VehicleApplication"> | string | null
    isVerified?: BoolWithAggregatesFilter<"VehicleApplication"> | boolean
  }

  export type CrossReferenceWhereInput = {
    AND?: CrossReferenceWhereInput | CrossReferenceWhereInput[]
    OR?: CrossReferenceWhereInput[]
    NOT?: CrossReferenceWhereInput | CrossReferenceWhereInput[]
    id?: StringFilter<"CrossReference"> | string
    productId?: StringFilter<"CrossReference"> | string
    crossPartNumber?: StringFilter<"CrossReference"> | string
    crossBrandId?: StringFilter<"CrossReference"> | string
    crossType?: EnumCrossTypeFilter<"CrossReference"> | $Enums.CrossType
    confidenceScore?: DecimalFilter<"CrossReference"> | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFilter<"CrossReference"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    crossBrand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
  }

  export type CrossReferenceOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    crossPartNumber?: SortOrder
    crossBrandId?: SortOrder
    crossType?: SortOrder
    confidenceScore?: SortOrder
    verifiedByExpert?: SortOrder
    product?: ProductOrderByWithRelationInput
    crossBrand?: BrandOrderByWithRelationInput
  }

  export type CrossReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrossReferenceWhereInput | CrossReferenceWhereInput[]
    OR?: CrossReferenceWhereInput[]
    NOT?: CrossReferenceWhereInput | CrossReferenceWhereInput[]
    productId?: StringFilter<"CrossReference"> | string
    crossPartNumber?: StringFilter<"CrossReference"> | string
    crossBrandId?: StringFilter<"CrossReference"> | string
    crossType?: EnumCrossTypeFilter<"CrossReference"> | $Enums.CrossType
    confidenceScore?: DecimalFilter<"CrossReference"> | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFilter<"CrossReference"> | boolean
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    crossBrand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
  }, "id">

  export type CrossReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    crossPartNumber?: SortOrder
    crossBrandId?: SortOrder
    crossType?: SortOrder
    confidenceScore?: SortOrder
    verifiedByExpert?: SortOrder
    _count?: CrossReferenceCountOrderByAggregateInput
    _avg?: CrossReferenceAvgOrderByAggregateInput
    _max?: CrossReferenceMaxOrderByAggregateInput
    _min?: CrossReferenceMinOrderByAggregateInput
    _sum?: CrossReferenceSumOrderByAggregateInput
  }

  export type CrossReferenceScalarWhereWithAggregatesInput = {
    AND?: CrossReferenceScalarWhereWithAggregatesInput | CrossReferenceScalarWhereWithAggregatesInput[]
    OR?: CrossReferenceScalarWhereWithAggregatesInput[]
    NOT?: CrossReferenceScalarWhereWithAggregatesInput | CrossReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CrossReference"> | string
    productId?: StringWithAggregatesFilter<"CrossReference"> | string
    crossPartNumber?: StringWithAggregatesFilter<"CrossReference"> | string
    crossBrandId?: StringWithAggregatesFilter<"CrossReference"> | string
    crossType?: EnumCrossTypeWithAggregatesFilter<"CrossReference"> | $Enums.CrossType
    confidenceScore?: DecimalWithAggregatesFilter<"CrossReference"> | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolWithAggregatesFilter<"CrossReference"> | boolean
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    productId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_productId?: FavoriteUserIdProductIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: StringFilter<"Favorite"> | string
    productId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "userId_productId">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: StringWithAggregatesFilter<"Favorite"> | string
    productId?: StringWithAggregatesFilter<"Favorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type ViewHistoryWhereInput = {
    AND?: ViewHistoryWhereInput | ViewHistoryWhereInput[]
    OR?: ViewHistoryWhereInput[]
    NOT?: ViewHistoryWhereInput | ViewHistoryWhereInput[]
    id?: StringFilter<"ViewHistory"> | string
    userId?: StringNullableFilter<"ViewHistory"> | string | null
    anonymousId?: StringNullableFilter<"ViewHistory"> | string | null
    productId?: StringNullableFilter<"ViewHistory"> | string | null
    categoryId?: StringNullableFilter<"ViewHistory"> | string | null
    viewedAt?: DateTimeFilter<"ViewHistory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }

  export type ViewHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    anonymousUser?: AnonymousUserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ViewHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ViewHistoryWhereInput | ViewHistoryWhereInput[]
    OR?: ViewHistoryWhereInput[]
    NOT?: ViewHistoryWhereInput | ViewHistoryWhereInput[]
    userId?: StringNullableFilter<"ViewHistory"> | string | null
    anonymousId?: StringNullableFilter<"ViewHistory"> | string | null
    productId?: StringNullableFilter<"ViewHistory"> | string | null
    categoryId?: StringNullableFilter<"ViewHistory"> | string | null
    viewedAt?: DateTimeFilter<"ViewHistory"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
  }, "id">

  export type ViewHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    viewedAt?: SortOrder
    _count?: ViewHistoryCountOrderByAggregateInput
    _max?: ViewHistoryMaxOrderByAggregateInput
    _min?: ViewHistoryMinOrderByAggregateInput
  }

  export type ViewHistoryScalarWhereWithAggregatesInput = {
    AND?: ViewHistoryScalarWhereWithAggregatesInput | ViewHistoryScalarWhereWithAggregatesInput[]
    OR?: ViewHistoryScalarWhereWithAggregatesInput[]
    NOT?: ViewHistoryScalarWhereWithAggregatesInput | ViewHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ViewHistory"> | string
    userId?: StringNullableWithAggregatesFilter<"ViewHistory"> | string | null
    anonymousId?: StringNullableWithAggregatesFilter<"ViewHistory"> | string | null
    productId?: StringNullableWithAggregatesFilter<"ViewHistory"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"ViewHistory"> | string | null
    viewedAt?: DateTimeWithAggregatesFilter<"ViewHistory"> | Date | string
  }

  export type CartWhereInput = {
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    anonymousId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    items?: CartItemListRelationFilter
  }

  export type CartOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    anonymousUser?: AnonymousUserOrderByWithRelationInput
    items?: CartItemOrderByRelationAggregateInput
  }

  export type CartWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CartWhereInput | CartWhereInput[]
    OR?: CartWhereInput[]
    NOT?: CartWhereInput | CartWhereInput[]
    userId?: StringNullableFilter<"Cart"> | string | null
    anonymousId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    items?: CartItemListRelationFilter
  }, "id">

  export type CartOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CartCountOrderByAggregateInput
    _max?: CartMaxOrderByAggregateInput
    _min?: CartMinOrderByAggregateInput
  }

  export type CartScalarWhereWithAggregatesInput = {
    AND?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    OR?: CartScalarWhereWithAggregatesInput[]
    NOT?: CartScalarWhereWithAggregatesInput | CartScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cart"> | string
    userId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    anonymousId?: StringNullableWithAggregatesFilter<"Cart"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cart"> | Date | string
  }

  export type CartItemWhereInput = {
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringNullableFilter<"CartItem"> | string | null
    chatProductId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    price?: DecimalFilter<"CartItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    chatProduct?: XOR<ChatProductNullableScalarRelationFilter, ChatProductWhereInput> | null
  }

  export type CartItemOrderByWithRelationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrderInput | SortOrder
    chatProductId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    cart?: CartOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    chatProduct?: ChatProductOrderByWithRelationInput
  }

  export type CartItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cartId_productId_chatProductId?: CartItemCartIdProductIdChatProductIdCompoundUniqueInput
    AND?: CartItemWhereInput | CartItemWhereInput[]
    OR?: CartItemWhereInput[]
    NOT?: CartItemWhereInput | CartItemWhereInput[]
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringNullableFilter<"CartItem"> | string | null
    chatProductId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    price?: DecimalFilter<"CartItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
    cart?: XOR<CartScalarRelationFilter, CartWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    chatProduct?: XOR<ChatProductNullableScalarRelationFilter, ChatProductWhereInput> | null
  }, "id" | "cartId_productId_chatProductId">

  export type CartItemOrderByWithAggregationInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrderInput | SortOrder
    chatProductId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: CartItemCountOrderByAggregateInput
    _avg?: CartItemAvgOrderByAggregateInput
    _max?: CartItemMaxOrderByAggregateInput
    _min?: CartItemMinOrderByAggregateInput
    _sum?: CartItemSumOrderByAggregateInput
  }

  export type CartItemScalarWhereWithAggregatesInput = {
    AND?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    OR?: CartItemScalarWhereWithAggregatesInput[]
    NOT?: CartItemScalarWhereWithAggregatesInput | CartItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CartItem"> | string
    cartId?: StringWithAggregatesFilter<"CartItem"> | string
    productId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    chatProductId?: StringNullableWithAggregatesFilter<"CartItem"> | string | null
    quantity?: IntWithAggregatesFilter<"CartItem"> | number
    price?: DecimalWithAggregatesFilter<"CartItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"CartItem"> | Date | string
  }

  export type ChatProductWhereInput = {
    AND?: ChatProductWhereInput | ChatProductWhereInput[]
    OR?: ChatProductWhereInput[]
    NOT?: ChatProductWhereInput | ChatProductWhereInput[]
    id?: StringFilter<"ChatProduct"> | string
    messageId?: StringFilter<"ChatProduct"> | string
    name?: StringFilter<"ChatProduct"> | string
    brand?: StringFilter<"ChatProduct"> | string
    sku?: StringFilter<"ChatProduct"> | string
    price?: DecimalFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFilter<"ChatProduct"> | boolean
    deliveryDays?: IntNullableFilter<"ChatProduct"> | number | null
    description?: StringNullableFilter<"ChatProduct"> | string | null
    createdAt?: DateTimeFilter<"ChatProduct"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    images?: ChatProductImageListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type ChatProductOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrderInput | SortOrder
    isOriginal?: SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    images?: ChatProductImageOrderByRelationAggregateInput
    cartItems?: CartItemOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type ChatProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatProductWhereInput | ChatProductWhereInput[]
    OR?: ChatProductWhereInput[]
    NOT?: ChatProductWhereInput | ChatProductWhereInput[]
    messageId?: StringFilter<"ChatProduct"> | string
    name?: StringFilter<"ChatProduct"> | string
    brand?: StringFilter<"ChatProduct"> | string
    sku?: StringFilter<"ChatProduct"> | string
    price?: DecimalFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFilter<"ChatProduct"> | boolean
    deliveryDays?: IntNullableFilter<"ChatProduct"> | number | null
    description?: StringNullableFilter<"ChatProduct"> | string | null
    createdAt?: DateTimeFilter<"ChatProduct"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    images?: ChatProductImageListRelationFilter
    cartItems?: CartItemListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type ChatProductOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrderInput | SortOrder
    isOriginal?: SortOrder
    deliveryDays?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatProductCountOrderByAggregateInput
    _avg?: ChatProductAvgOrderByAggregateInput
    _max?: ChatProductMaxOrderByAggregateInput
    _min?: ChatProductMinOrderByAggregateInput
    _sum?: ChatProductSumOrderByAggregateInput
  }

  export type ChatProductScalarWhereWithAggregatesInput = {
    AND?: ChatProductScalarWhereWithAggregatesInput | ChatProductScalarWhereWithAggregatesInput[]
    OR?: ChatProductScalarWhereWithAggregatesInput[]
    NOT?: ChatProductScalarWhereWithAggregatesInput | ChatProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatProduct"> | string
    messageId?: StringWithAggregatesFilter<"ChatProduct"> | string
    name?: StringWithAggregatesFilter<"ChatProduct"> | string
    brand?: StringWithAggregatesFilter<"ChatProduct"> | string
    sku?: StringWithAggregatesFilter<"ChatProduct"> | string
    price?: DecimalWithAggregatesFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableWithAggregatesFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolWithAggregatesFilter<"ChatProduct"> | boolean
    deliveryDays?: IntNullableWithAggregatesFilter<"ChatProduct"> | number | null
    description?: StringNullableWithAggregatesFilter<"ChatProduct"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatProduct"> | Date | string
  }

  export type ChatProductImageWhereInput = {
    AND?: ChatProductImageWhereInput | ChatProductImageWhereInput[]
    OR?: ChatProductImageWhereInput[]
    NOT?: ChatProductImageWhereInput | ChatProductImageWhereInput[]
    id?: StringFilter<"ChatProductImage"> | string
    chatProductId?: StringFilter<"ChatProductImage"> | string
    url?: StringFilter<"ChatProductImage"> | string
    alt?: StringNullableFilter<"ChatProductImage"> | string | null
    sortOrder?: IntFilter<"ChatProductImage"> | number
    createdAt?: DateTimeFilter<"ChatProductImage"> | Date | string
    chatProduct?: XOR<ChatProductScalarRelationFilter, ChatProductWhereInput>
  }

  export type ChatProductImageOrderByWithRelationInput = {
    id?: SortOrder
    chatProductId?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    chatProduct?: ChatProductOrderByWithRelationInput
  }

  export type ChatProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatProductImageWhereInput | ChatProductImageWhereInput[]
    OR?: ChatProductImageWhereInput[]
    NOT?: ChatProductImageWhereInput | ChatProductImageWhereInput[]
    chatProductId?: StringFilter<"ChatProductImage"> | string
    url?: StringFilter<"ChatProductImage"> | string
    alt?: StringNullableFilter<"ChatProductImage"> | string | null
    sortOrder?: IntFilter<"ChatProductImage"> | number
    createdAt?: DateTimeFilter<"ChatProductImage"> | Date | string
    chatProduct?: XOR<ChatProductScalarRelationFilter, ChatProductWhereInput>
  }, "id">

  export type ChatProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    chatProductId?: SortOrder
    url?: SortOrder
    alt?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: ChatProductImageCountOrderByAggregateInput
    _avg?: ChatProductImageAvgOrderByAggregateInput
    _max?: ChatProductImageMaxOrderByAggregateInput
    _min?: ChatProductImageMinOrderByAggregateInput
    _sum?: ChatProductImageSumOrderByAggregateInput
  }

  export type ChatProductImageScalarWhereWithAggregatesInput = {
    AND?: ChatProductImageScalarWhereWithAggregatesInput | ChatProductImageScalarWhereWithAggregatesInput[]
    OR?: ChatProductImageScalarWhereWithAggregatesInput[]
    NOT?: ChatProductImageScalarWhereWithAggregatesInput | ChatProductImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatProductImage"> | string
    chatProductId?: StringWithAggregatesFilter<"ChatProductImage"> | string
    url?: StringWithAggregatesFilter<"ChatProductImage"> | string
    alt?: StringNullableWithAggregatesFilter<"ChatProductImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ChatProductImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ChatProductImage"> | Date | string
  }

  export type ChatStatusWhereInput = {
    AND?: ChatStatusWhereInput | ChatStatusWhereInput[]
    OR?: ChatStatusWhereInput[]
    NOT?: ChatStatusWhereInput | ChatStatusWhereInput[]
    id?: StringFilter<"ChatStatus"> | string
    name?: StringFilter<"ChatStatus"> | string
    code?: StringFilter<"ChatStatus"> | string
    color?: StringNullableFilter<"ChatStatus"> | string | null
    sortOrder?: IntFilter<"ChatStatus"> | number
    isActive?: BoolFilter<"ChatStatus"> | boolean
    createdAt?: DateTimeFilter<"ChatStatus"> | Date | string
    chats?: ChatListRelationFilter
  }

  export type ChatStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    chats?: ChatOrderByRelationAggregateInput
  }

  export type ChatStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: ChatStatusWhereInput | ChatStatusWhereInput[]
    OR?: ChatStatusWhereInput[]
    NOT?: ChatStatusWhereInput | ChatStatusWhereInput[]
    color?: StringNullableFilter<"ChatStatus"> | string | null
    sortOrder?: IntFilter<"ChatStatus"> | number
    isActive?: BoolFilter<"ChatStatus"> | boolean
    createdAt?: DateTimeFilter<"ChatStatus"> | Date | string
    chats?: ChatListRelationFilter
  }, "id" | "name" | "code">

  export type ChatStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ChatStatusCountOrderByAggregateInput
    _avg?: ChatStatusAvgOrderByAggregateInput
    _max?: ChatStatusMaxOrderByAggregateInput
    _min?: ChatStatusMinOrderByAggregateInput
    _sum?: ChatStatusSumOrderByAggregateInput
  }

  export type ChatStatusScalarWhereWithAggregatesInput = {
    AND?: ChatStatusScalarWhereWithAggregatesInput | ChatStatusScalarWhereWithAggregatesInput[]
    OR?: ChatStatusScalarWhereWithAggregatesInput[]
    NOT?: ChatStatusScalarWhereWithAggregatesInput | ChatStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatStatus"> | string
    name?: StringWithAggregatesFilter<"ChatStatus"> | string
    code?: StringWithAggregatesFilter<"ChatStatus"> | string
    color?: StringNullableWithAggregatesFilter<"ChatStatus"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ChatStatus"> | number
    isActive?: BoolWithAggregatesFilter<"ChatStatus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChatStatus"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringNullableFilter<"Chat"> | string | null
    anonymousId?: StringNullableFilter<"Chat"> | string | null
    managerId?: StringNullableFilter<"Chat"> | string | null
    statusId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    status?: XOR<ChatStatusScalarRelationFilter, ChatStatusWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    anonymousUser?: AnonymousUserOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    status?: ChatStatusOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    userId?: StringNullableFilter<"Chat"> | string | null
    anonymousId?: StringNullableFilter<"Chat"> | string | null
    managerId?: StringNullableFilter<"Chat"> | string | null
    statusId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    anonymousUser?: XOR<AnonymousUserNullableScalarRelationFilter, AnonymousUserWhereInput> | null
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    status?: XOR<ChatStatusScalarRelationFilter, ChatStatusWhereInput>
    messages?: MessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    userId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    anonymousId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    statusId?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    chatProducts?: ChatProductListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    chatProducts?: ChatProductOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
    chatProducts?: ChatProductListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    senderType?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    senderType?: EnumSenderTypeWithAggregatesFilter<"Message"> | $Enums.SenderType
    messageType?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    content?: StringWithAggregatesFilter<"Message"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type OrderStatusWhereInput = {
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    id?: StringFilter<"OrderStatus"> | string
    name?: StringFilter<"OrderStatus"> | string
    code?: StringFilter<"OrderStatus"> | string
    color?: StringNullableFilter<"OrderStatus"> | string | null
    description?: StringNullableFilter<"OrderStatus"> | string | null
    isInitial?: BoolFilter<"OrderStatus"> | boolean
    isFinalSuccess?: BoolFilter<"OrderStatus"> | boolean
    isFinalFailure?: BoolFilter<"OrderStatus"> | boolean
    canCancelOrder?: BoolFilter<"OrderStatus"> | boolean
    sortOrder?: IntFilter<"OrderStatus"> | number
    isActive?: BoolFilter<"OrderStatus"> | boolean
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    orders?: OrderListRelationFilter
    orderLogs?: OrderStatusLogListRelationFilter
  }

  export type OrderStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isInitial?: SortOrder
    isFinalSuccess?: SortOrder
    isFinalFailure?: SortOrder
    canCancelOrder?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    orderLogs?: OrderStatusLogOrderByRelationAggregateInput
  }

  export type OrderStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: OrderStatusWhereInput | OrderStatusWhereInput[]
    OR?: OrderStatusWhereInput[]
    NOT?: OrderStatusWhereInput | OrderStatusWhereInput[]
    color?: StringNullableFilter<"OrderStatus"> | string | null
    description?: StringNullableFilter<"OrderStatus"> | string | null
    isInitial?: BoolFilter<"OrderStatus"> | boolean
    isFinalSuccess?: BoolFilter<"OrderStatus"> | boolean
    isFinalFailure?: BoolFilter<"OrderStatus"> | boolean
    canCancelOrder?: BoolFilter<"OrderStatus"> | boolean
    sortOrder?: IntFilter<"OrderStatus"> | number
    isActive?: BoolFilter<"OrderStatus"> | boolean
    createdAt?: DateTimeFilter<"OrderStatus"> | Date | string
    orders?: OrderListRelationFilter
    orderLogs?: OrderStatusLogListRelationFilter
  }, "id" | "name" | "code">

  export type OrderStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isInitial?: SortOrder
    isFinalSuccess?: SortOrder
    isFinalFailure?: SortOrder
    canCancelOrder?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: OrderStatusCountOrderByAggregateInput
    _avg?: OrderStatusAvgOrderByAggregateInput
    _max?: OrderStatusMaxOrderByAggregateInput
    _min?: OrderStatusMinOrderByAggregateInput
    _sum?: OrderStatusSumOrderByAggregateInput
  }

  export type OrderStatusScalarWhereWithAggregatesInput = {
    AND?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    OR?: OrderStatusScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusScalarWhereWithAggregatesInput | OrderStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderStatus"> | string
    name?: StringWithAggregatesFilter<"OrderStatus"> | string
    code?: StringWithAggregatesFilter<"OrderStatus"> | string
    color?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    description?: StringNullableWithAggregatesFilter<"OrderStatus"> | string | null
    isInitial?: BoolWithAggregatesFilter<"OrderStatus"> | boolean
    isFinalSuccess?: BoolWithAggregatesFilter<"OrderStatus"> | boolean
    isFinalFailure?: BoolWithAggregatesFilter<"OrderStatus"> | boolean
    canCancelOrder?: BoolWithAggregatesFilter<"OrderStatus"> | boolean
    sortOrder?: IntWithAggregatesFilter<"OrderStatus"> | number
    isActive?: BoolWithAggregatesFilter<"OrderStatus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OrderStatus"> | Date | string
  }

  export type DeliveryMethodWhereInput = {
    AND?: DeliveryMethodWhereInput | DeliveryMethodWhereInput[]
    OR?: DeliveryMethodWhereInput[]
    NOT?: DeliveryMethodWhereInput | DeliveryMethodWhereInput[]
    id?: StringFilter<"DeliveryMethod"> | string
    name?: StringFilter<"DeliveryMethod"> | string
    code?: StringFilter<"DeliveryMethod"> | string
    description?: StringNullableFilter<"DeliveryMethod"> | string | null
    price?: DecimalFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"DeliveryMethod"> | boolean
    sortOrder?: IntFilter<"DeliveryMethod"> | number
    settings?: JsonNullableFilter<"DeliveryMethod">
    createdAt?: DateTimeFilter<"DeliveryMethod"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type DeliveryMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type DeliveryMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: DeliveryMethodWhereInput | DeliveryMethodWhereInput[]
    OR?: DeliveryMethodWhereInput[]
    NOT?: DeliveryMethodWhereInput | DeliveryMethodWhereInput[]
    description?: StringNullableFilter<"DeliveryMethod"> | string | null
    price?: DecimalFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"DeliveryMethod"> | boolean
    sortOrder?: IntFilter<"DeliveryMethod"> | number
    settings?: JsonNullableFilter<"DeliveryMethod">
    createdAt?: DateTimeFilter<"DeliveryMethod"> | Date | string
    orders?: OrderListRelationFilter
  }, "id" | "name" | "code">

  export type DeliveryMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DeliveryMethodCountOrderByAggregateInput
    _avg?: DeliveryMethodAvgOrderByAggregateInput
    _max?: DeliveryMethodMaxOrderByAggregateInput
    _min?: DeliveryMethodMinOrderByAggregateInput
    _sum?: DeliveryMethodSumOrderByAggregateInput
  }

  export type DeliveryMethodScalarWhereWithAggregatesInput = {
    AND?: DeliveryMethodScalarWhereWithAggregatesInput | DeliveryMethodScalarWhereWithAggregatesInput[]
    OR?: DeliveryMethodScalarWhereWithAggregatesInput[]
    NOT?: DeliveryMethodScalarWhereWithAggregatesInput | DeliveryMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryMethod"> | string
    name?: StringWithAggregatesFilter<"DeliveryMethod"> | string
    code?: StringWithAggregatesFilter<"DeliveryMethod"> | string
    description?: StringNullableWithAggregatesFilter<"DeliveryMethod"> | string | null
    price?: DecimalWithAggregatesFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableWithAggregatesFilter<"DeliveryMethod"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"DeliveryMethod"> | boolean
    sortOrder?: IntWithAggregatesFilter<"DeliveryMethod"> | number
    settings?: JsonNullableWithAggregatesFilter<"DeliveryMethod">
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryMethod"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    name?: StringFilter<"PaymentMethod"> | string
    code?: StringFilter<"PaymentMethod"> | string
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    icon?: StringNullableFilter<"PaymentMethod"> | string | null
    isOnline?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    sortOrder?: IntFilter<"PaymentMethod"> | number
    settings?: JsonNullableFilter<"PaymentMethod">
    commission?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    orders?: OrderListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrderInput | SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    code?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    description?: StringNullableFilter<"PaymentMethod"> | string | null
    icon?: StringNullableFilter<"PaymentMethod"> | string | null
    isOnline?: BoolFilter<"PaymentMethod"> | boolean
    isActive?: BoolFilter<"PaymentMethod"> | boolean
    sortOrder?: IntFilter<"PaymentMethod"> | number
    settings?: JsonNullableFilter<"PaymentMethod">
    commission?: DecimalFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    orders?: OrderListRelationFilter
  }, "id" | "name" | "code">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrderInput | SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _avg?: PaymentMethodAvgOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
    _sum?: PaymentMethodSumOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    name?: StringWithAggregatesFilter<"PaymentMethod"> | string
    code?: StringWithAggregatesFilter<"PaymentMethod"> | string
    description?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    icon?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    isOnline?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    isActive?: BoolWithAggregatesFilter<"PaymentMethod"> | boolean
    sortOrder?: IntWithAggregatesFilter<"PaymentMethod"> | number
    settings?: JsonNullableWithAggregatesFilter<"PaymentMethod">
    commission?: DecimalWithAggregatesFilter<"PaymentMethod"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    statusId?: StringFilter<"Order"> | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFilter<"Order"> | string
    paymentMethodId?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    comment?: StringNullableFilter<"Order"> | string | null
    promoCodeId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    deliveryMethod?: XOR<DeliveryMethodScalarRelationFilter, DeliveryMethodWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
    items?: OrderItemListRelationFilter
    statusLogs?: OrderStatusLogListRelationFilter
    payments?: PaymentListRelationFilter
    promoCodeUsage?: PromoCodeUsageListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
    deliveryMethodId?: SortOrder
    paymentMethodId?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    status?: OrderStatusOrderByWithRelationInput
    deliveryMethod?: DeliveryMethodOrderByWithRelationInput
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    promoCode?: PromoCodeOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    statusLogs?: OrderStatusLogOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    promoCodeUsage?: PromoCodeUsageOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    statusId?: StringFilter<"Order"> | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFilter<"Order"> | string
    paymentMethodId?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    comment?: StringNullableFilter<"Order"> | string | null
    promoCodeId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    deliveryMethod?: XOR<DeliveryMethodScalarRelationFilter, DeliveryMethodWhereInput>
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    promoCode?: XOR<PromoCodeNullableScalarRelationFilter, PromoCodeWhereInput> | null
    items?: OrderItemListRelationFilter
    statusLogs?: OrderStatusLogListRelationFilter
    payments?: PaymentListRelationFilter
    promoCodeUsage?: PromoCodeUsageListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
    deliveryMethodId?: SortOrder
    paymentMethodId?: SortOrder
    shippingAddress?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    promoCodeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    statusId?: StringWithAggregatesFilter<"Order"> | string
    subtotal?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringWithAggregatesFilter<"Order"> | string
    paymentMethodId?: StringWithAggregatesFilter<"Order"> | string
    shippingAddress?: JsonNullableWithAggregatesFilter<"Order">
    comment?: StringNullableWithAggregatesFilter<"Order"> | string | null
    promoCodeId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringNullableFilter<"OrderItem"> | string | null
    chatProductId?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    chatProduct?: XOR<ChatProductNullableScalarRelationFilter, ChatProductWhereInput> | null
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrderInput | SortOrder
    chatProductId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    chatProduct?: ChatProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringNullableFilter<"OrderItem"> | string | null
    chatProductId?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
    chatProduct?: XOR<ChatProductNullableScalarRelationFilter, ChatProductWhereInput> | null
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrderInput | SortOrder
    chatProductId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    chatProductId?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
  }

  export type OrderStatusLogWhereInput = {
    AND?: OrderStatusLogWhereInput | OrderStatusLogWhereInput[]
    OR?: OrderStatusLogWhereInput[]
    NOT?: OrderStatusLogWhereInput | OrderStatusLogWhereInput[]
    id?: StringFilter<"OrderStatusLog"> | string
    orderId?: StringFilter<"OrderStatusLog"> | string
    statusId?: StringFilter<"OrderStatusLog"> | string
    comment?: StringNullableFilter<"OrderStatusLog"> | string | null
    createdById?: StringFilter<"OrderStatusLog"> | string
    createdAt?: DateTimeFilter<"OrderStatusLog"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrderStatusLogOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    statusId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    status?: OrderStatusOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type OrderStatusLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderStatusLogWhereInput | OrderStatusLogWhereInput[]
    OR?: OrderStatusLogWhereInput[]
    NOT?: OrderStatusLogWhereInput | OrderStatusLogWhereInput[]
    orderId?: StringFilter<"OrderStatusLog"> | string
    statusId?: StringFilter<"OrderStatusLog"> | string
    comment?: StringNullableFilter<"OrderStatusLog"> | string | null
    createdById?: StringFilter<"OrderStatusLog"> | string
    createdAt?: DateTimeFilter<"OrderStatusLog"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    status?: XOR<OrderStatusScalarRelationFilter, OrderStatusWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type OrderStatusLogOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    statusId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: OrderStatusLogCountOrderByAggregateInput
    _max?: OrderStatusLogMaxOrderByAggregateInput
    _min?: OrderStatusLogMinOrderByAggregateInput
  }

  export type OrderStatusLogScalarWhereWithAggregatesInput = {
    AND?: OrderStatusLogScalarWhereWithAggregatesInput | OrderStatusLogScalarWhereWithAggregatesInput[]
    OR?: OrderStatusLogScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusLogScalarWhereWithAggregatesInput | OrderStatusLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderStatusLog"> | string
    orderId?: StringWithAggregatesFilter<"OrderStatusLog"> | string
    statusId?: StringWithAggregatesFilter<"OrderStatusLog"> | string
    comment?: StringNullableWithAggregatesFilter<"OrderStatusLog"> | string | null
    createdById?: StringWithAggregatesFilter<"OrderStatusLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderStatusLog"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CustomerGroupWhereInput = {
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    id?: StringFilter<"CustomerGroup"> | string
    name?: StringFilter<"CustomerGroup"> | string
    discountPercent?: DecimalFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string
    minOrderAmount?: DecimalNullableFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string | null
    benefits?: JsonNullableFilter<"CustomerGroup">
    users?: UserListRelationFilter
    discountRules?: DiscountRuleListRelationFilter
  }

  export type CustomerGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    discountPercent?: SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    discountRules?: DiscountRuleOrderByRelationAggregateInput
  }

  export type CustomerGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    name?: StringFilter<"CustomerGroup"> | string
    discountPercent?: DecimalFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string
    minOrderAmount?: DecimalNullableFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string | null
    benefits?: JsonNullableFilter<"CustomerGroup">
    users?: UserListRelationFilter
    discountRules?: DiscountRuleListRelationFilter
  }, "id">

  export type CustomerGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    discountPercent?: SortOrder
    minOrderAmount?: SortOrderInput | SortOrder
    benefits?: SortOrderInput | SortOrder
    _count?: CustomerGroupCountOrderByAggregateInput
    _avg?: CustomerGroupAvgOrderByAggregateInput
    _max?: CustomerGroupMaxOrderByAggregateInput
    _min?: CustomerGroupMinOrderByAggregateInput
    _sum?: CustomerGroupSumOrderByAggregateInput
  }

  export type CustomerGroupScalarWhereWithAggregatesInput = {
    AND?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    OR?: CustomerGroupScalarWhereWithAggregatesInput[]
    NOT?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerGroup"> | string
    name?: StringWithAggregatesFilter<"CustomerGroup"> | string
    discountPercent?: DecimalWithAggregatesFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string
    minOrderAmount?: DecimalNullableWithAggregatesFilter<"CustomerGroup"> | Decimal | DecimalJsLike | number | string | null
    benefits?: JsonNullableWithAggregatesFilter<"CustomerGroup">
  }

  export type DiscountRuleWhereInput = {
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    name?: StringFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    usageLimit?: IntNullableFilter<"DiscountRule"> | number | null
    customerGroupId?: StringNullableFilter<"DiscountRule"> | string | null
    categories?: JsonNullableFilter<"DiscountRule">
    brands?: JsonNullableFilter<"DiscountRule">
    isActive?: BoolFilter<"DiscountRule"> | boolean
    customerGroup?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    promoCodes?: PromoCodeListRelationFilter
  }

  export type DiscountRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    customerGroupId?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    brands?: SortOrderInput | SortOrder
    isActive?: SortOrder
    customerGroup?: CustomerGroupOrderByWithRelationInput
    promoCodes?: PromoCodeOrderByRelationAggregateInput
  }

  export type DiscountRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    OR?: DiscountRuleWhereInput[]
    NOT?: DiscountRuleWhereInput | DiscountRuleWhereInput[]
    name?: StringFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    usageLimit?: IntNullableFilter<"DiscountRule"> | number | null
    customerGroupId?: StringNullableFilter<"DiscountRule"> | string | null
    categories?: JsonNullableFilter<"DiscountRule">
    brands?: JsonNullableFilter<"DiscountRule">
    isActive?: BoolFilter<"DiscountRule"> | boolean
    customerGroup?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    promoCodes?: PromoCodeListRelationFilter
  }, "id">

  export type DiscountRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    usageLimit?: SortOrderInput | SortOrder
    customerGroupId?: SortOrderInput | SortOrder
    categories?: SortOrderInput | SortOrder
    brands?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: DiscountRuleCountOrderByAggregateInput
    _avg?: DiscountRuleAvgOrderByAggregateInput
    _max?: DiscountRuleMaxOrderByAggregateInput
    _min?: DiscountRuleMinOrderByAggregateInput
    _sum?: DiscountRuleSumOrderByAggregateInput
  }

  export type DiscountRuleScalarWhereWithAggregatesInput = {
    AND?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    OR?: DiscountRuleScalarWhereWithAggregatesInput[]
    NOT?: DiscountRuleScalarWhereWithAggregatesInput | DiscountRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscountRule"> | string
    name?: StringWithAggregatesFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableWithAggregatesFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"DiscountRule"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"DiscountRule"> | Date | string | null
    usageLimit?: IntNullableWithAggregatesFilter<"DiscountRule"> | number | null
    customerGroupId?: StringNullableWithAggregatesFilter<"DiscountRule"> | string | null
    categories?: JsonNullableWithAggregatesFilter<"DiscountRule">
    brands?: JsonNullableWithAggregatesFilter<"DiscountRule">
    isActive?: BoolWithAggregatesFilter<"DiscountRule"> | boolean
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    discountRuleId?: StringFilter<"PromoCode"> | string
    usageCount?: IntFilter<"PromoCode"> | number
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    personalUserId?: StringNullableFilter<"PromoCode"> | string | null
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
    personalUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orders?: OrderListRelationFilter
    usage?: PromoCodeUsageListRelationFilter
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    discountRuleId?: SortOrder
    usageCount?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    personalUserId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    discountRule?: DiscountRuleOrderByWithRelationInput
    personalUser?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    usage?: PromoCodeUsageOrderByRelationAggregateInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    discountRuleId?: StringFilter<"PromoCode"> | string
    usageCount?: IntFilter<"PromoCode"> | number
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    personalUserId?: StringNullableFilter<"PromoCode"> | string | null
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    discountRule?: XOR<DiscountRuleScalarRelationFilter, DiscountRuleWhereInput>
    personalUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    orders?: OrderListRelationFilter
    usage?: PromoCodeUsageListRelationFilter
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    discountRuleId?: SortOrder
    usageCount?: SortOrder
    usageLimit?: SortOrderInput | SortOrder
    personalUserId?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _avg?: PromoCodeAvgOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
    _sum?: PromoCodeSumOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    discountRuleId?: StringWithAggregatesFilter<"PromoCode"> | string
    usageCount?: IntWithAggregatesFilter<"PromoCode"> | number
    usageLimit?: IntNullableWithAggregatesFilter<"PromoCode"> | number | null
    personalUserId?: StringNullableWithAggregatesFilter<"PromoCode"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PromoCode"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type PromoCodeUsageWhereInput = {
    AND?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    OR?: PromoCodeUsageWhereInput[]
    NOT?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    id?: StringFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    orderId?: StringNullableFilter<"PromoCodeUsage"> | string | null
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type PromoCodeUsageOrderByWithRelationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    promoCode?: PromoCodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type PromoCodeUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    promoCodeId_userId_orderId?: PromoCodeUsagePromoCodeIdUserIdOrderIdCompoundUniqueInput
    AND?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    OR?: PromoCodeUsageWhereInput[]
    NOT?: PromoCodeUsageWhereInput | PromoCodeUsageWhereInput[]
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    orderId?: StringNullableFilter<"PromoCodeUsage"> | string | null
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
    promoCode?: XOR<PromoCodeScalarRelationFilter, PromoCodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id" | "promoCodeId_userId_orderId">

  export type PromoCodeUsageOrderByWithAggregationInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromoCodeUsageCountOrderByAggregateInput
    _max?: PromoCodeUsageMaxOrderByAggregateInput
    _min?: PromoCodeUsageMinOrderByAggregateInput
  }

  export type PromoCodeUsageScalarWhereWithAggregatesInput = {
    AND?: PromoCodeUsageScalarWhereWithAggregatesInput | PromoCodeUsageScalarWhereWithAggregatesInput[]
    OR?: PromoCodeUsageScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeUsageScalarWhereWithAggregatesInput | PromoCodeUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    userId?: StringWithAggregatesFilter<"PromoCodeUsage"> | string
    orderId?: StringNullableWithAggregatesFilter<"PromoCodeUsage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PromoCodeUsage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnonymousUserCreateInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartCreateNestedManyWithoutAnonymousUserInput
    chats?: ChatCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserUncheckedCreateInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutAnonymousUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutAnonymousUserNestedInput
    chats?: ChatUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutAnonymousUserNestedInput
  }

  export type AnonymousUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutAnonymousUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutAnonymousUserNestedInput
  }

  export type AnonymousUserCreateManyInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
  }

  export type AnonymousUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnonymousUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
    user: UserCreateNestedOneWithoutPushSubscriptionInput
  }

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type PushSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPushSubscriptionNestedInput
  }

  export type PushSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionCreateManyInput = {
    id?: string
    userId: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type PushSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: string | null
    scheduleEnd?: string | null
    scheduleTimezone?: string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: string | null
    scheduleEnd?: string | null
    scheduleTimezone?: string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    userId: string
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: string | null
    scheduleEnd?: string | null
    scheduleTimezone?: string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationLogInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationLogNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryCreateInput = {
    id?: string
    isPrimary?: boolean
    product: ProductCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    productId: string
    categoryId: string
    isPrimary?: boolean
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    productId: string
    categoryId: string
    isPrimary?: boolean
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageCreateInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutImagesInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: string
    productId: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateManyInput = {
    id?: string
    productId: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutBrandInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutCrossBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutCrossBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBrandNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutCrossBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutCrossBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacteristicCreateInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueCreateNestedManyWithoutCharacteristicInput
    productValues?: ProductCharacteristicCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueUncheckedCreateNestedManyWithoutCharacteristicInput
    productValues?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUpdateManyWithoutCharacteristicNestedInput
    productValues?: ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUncheckedUpdateManyWithoutCharacteristicNestedInput
    productValues?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicCreateManyInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type CharacteristicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacteristicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacteristicCategoryCreateInput = {
    id?: string
    characteristic: CharacteristicCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutCharacteristicsInput
  }

  export type CharacteristicCategoryUncheckedCreateInput = {
    id?: string
    characteristicId: string
    categoryId: string
  }

  export type CharacteristicCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristic?: CharacteristicUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutCharacteristicsNestedInput
  }

  export type CharacteristicCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicCategoryCreateManyInput = {
    id?: string
    characteristicId: string
    categoryId: string
  }

  export type CharacteristicCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicValueCreateInput = {
    id?: string
    value: string
    sortOrder?: number
    characteristic: CharacteristicCreateNestedOneWithoutValuesInput
    productValues?: ProductCharacteristicCreateNestedManyWithoutCharacteristicValueInput
  }

  export type CharacteristicValueUncheckedCreateInput = {
    id?: string
    characteristicId: string
    value: string
    sortOrder?: number
    productValues?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicValueInput
  }

  export type CharacteristicValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    characteristic?: CharacteristicUpdateOneRequiredWithoutValuesNestedInput
    productValues?: ProductCharacteristicUpdateManyWithoutCharacteristicValueNestedInput
  }

  export type CharacteristicValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    productValues?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicValueNestedInput
  }

  export type CharacteristicValueCreateManyInput = {
    id?: string
    characteristicId: string
    value: string
    sortOrder?: number
  }

  export type CharacteristicValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type CharacteristicValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCharacteristicCreateInput = {
    id?: string
    value?: string | null
    product: ProductCreateNestedOneWithoutCharacteristicsInput
    characteristic: CharacteristicCreateNestedOneWithoutProductValuesInput
    characteristicValue?: CharacteristicValueCreateNestedOneWithoutProductValuesInput
  }

  export type ProductCharacteristicUncheckedCreateInput = {
    id?: string
    productId: string
    characteristicId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type ProductCharacteristicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutCharacteristicsNestedInput
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductValuesNestedInput
    characteristicValue?: CharacteristicValueUpdateOneWithoutProductValuesNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCharacteristicCreateManyInput = {
    id?: string
    productId: string
    characteristicId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type ProductCharacteristicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCharacteristicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleMakeCreateInput = {
    id?: string
    name: string
    slug: string
    country?: string | null
    logoUrl?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    models?: VehicleModelCreateNestedManyWithoutMakeInput
  }

  export type VehicleMakeUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    country?: string | null
    logoUrl?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    models?: VehicleModelUncheckedCreateNestedManyWithoutMakeInput
  }

  export type VehicleMakeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    models?: VehicleModelUpdateManyWithoutMakeNestedInput
  }

  export type VehicleMakeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    models?: VehicleModelUncheckedUpdateManyWithoutMakeNestedInput
  }

  export type VehicleMakeCreateManyInput = {
    id?: string
    name: string
    slug: string
    country?: string | null
    logoUrl?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleMakeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleMakeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModelCreateInput = {
    id?: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    make: VehicleMakeCreateNestedOneWithoutModelsInput
    generations?: VehicleGenerationCreateNestedManyWithoutModelInput
  }

  export type VehicleModelUncheckedCreateInput = {
    id?: string
    makeId: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    generations?: VehicleGenerationUncheckedCreateNestedManyWithoutModelInput
  }

  export type VehicleModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    make?: VehicleMakeUpdateOneRequiredWithoutModelsNestedInput
    generations?: VehicleGenerationUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    makeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    generations?: VehicleGenerationUncheckedUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelCreateManyInput = {
    id?: string
    makeId: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    makeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleGenerationCreateInput = {
    id?: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    model: VehicleModelCreateNestedOneWithoutGenerationsInput
    modifications?: VehicleModificationCreateNestedManyWithoutGenerationInput
  }

  export type VehicleGenerationUncheckedCreateInput = {
    id?: string
    modelId: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    modifications?: VehicleModificationUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type VehicleGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    model?: VehicleModelUpdateOneRequiredWithoutGenerationsNestedInput
    modifications?: VehicleModificationUpdateManyWithoutGenerationNestedInput
  }

  export type VehicleGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: VehicleModificationUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type VehicleGenerationCreateManyInput = {
    id?: string
    modelId: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModificationCreateInput = {
    id?: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
    generation: VehicleGenerationCreateNestedOneWithoutModificationsInput
    applications?: VehicleApplicationCreateNestedManyWithoutModificationInput
  }

  export type VehicleModificationUncheckedCreateInput = {
    id?: string
    generationId: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
    applications?: VehicleApplicationUncheckedCreateNestedManyWithoutModificationInput
  }

  export type VehicleModificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: VehicleGenerationUpdateOneRequiredWithoutModificationsNestedInput
    applications?: VehicleApplicationUpdateManyWithoutModificationNestedInput
  }

  export type VehicleModificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: VehicleApplicationUncheckedUpdateManyWithoutModificationNestedInput
  }

  export type VehicleModificationCreateManyInput = {
    id?: string
    generationId: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
  }

  export type VehicleModificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleApplicationCreateInput = {
    id?: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
    product: ProductCreateNestedOneWithoutVehicleApplicationsInput
    modification: VehicleModificationCreateNestedOneWithoutApplicationsInput
  }

  export type VehicleApplicationUncheckedCreateInput = {
    id?: string
    productId: string
    modificationId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type VehicleApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutVehicleApplicationsNestedInput
    modification?: VehicleModificationUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type VehicleApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    modificationId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleApplicationCreateManyInput = {
    id?: string
    productId: string
    modificationId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type VehicleApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    modificationId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceCreateInput = {
    id?: string
    crossPartNumber: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
    product: ProductCreateNestedOneWithoutCrossReferencesInput
    crossBrand: BrandCreateNestedOneWithoutCrossReferencesInput
  }

  export type CrossReferenceUncheckedCreateInput = {
    id?: string
    productId: string
    crossPartNumber: string
    crossBrandId: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type CrossReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCrossReferencesNestedInput
    crossBrand?: BrandUpdateOneRequiredWithoutCrossReferencesNestedInput
  }

  export type CrossReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossBrandId?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceCreateManyInput = {
    id?: string
    productId: string
    crossPartNumber: string
    crossBrandId: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type CrossReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossBrandId?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FavoriteCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    product: ProductCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    product?: ProductUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    productId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryCreateInput = {
    id?: string
    viewedAt?: Date | string
    user?: UserCreateNestedOneWithoutViewHistoryInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutViewHistoryInput
    product?: ProductCreateNestedOneWithoutViewHistoryInput
    category?: CategoryCreateNestedOneWithoutViewHistoryInput
  }

  export type ViewHistoryUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutViewHistoryNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutViewHistoryNestedInput
    product?: ProductUpdateOneWithoutViewHistoryNestedInput
    category?: CategoryUpdateOneWithoutViewHistoryNestedInput
  }

  export type ViewHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryCreateManyInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartCreateManyInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutCartItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateInput = {
    id?: string
    cartId: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutCartItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemCreateManyInput = {
    id?: string
    cartId: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductCreateInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutChatProductsInput
    images?: ChatProductImageCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUncheckedCreateInput = {
    id?: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    images?: ChatProductImageUncheckedCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutChatProductsNestedInput
    images?: ChatProductImageUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ChatProductImageUncheckedUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductCreateManyInput = {
    id?: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
  }

  export type ChatProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageCreateInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
    chatProduct: ChatProductCreateNestedOneWithoutImagesInput
  }

  export type ChatProductImageUncheckedCreateInput = {
    id?: string
    chatProductId: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ChatProductImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatProduct?: ChatProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ChatProductImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatProductId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageCreateManyInput = {
    id?: string
    chatProductId: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ChatProductImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatProductId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatStatusCreateInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    chats?: ChatCreateNestedManyWithoutStatusInput
  }

  export type ChatStatusUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutStatusInput
  }

  export type ChatStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutStatusNestedInput
  }

  export type ChatStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type ChatStatusCreateManyInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChatStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutChatsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutChatsInput
    manager?: UserCreateNestedOneWithoutManagedChatsInput
    status: ChatStatusCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutChatsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutChatsNestedInput
    manager?: UserUpdateOneWithoutManagedChatsNestedInput
    status?: ChatStatusUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    chatProducts?: ChatProductCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    chatId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatProducts?: ChatProductUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    chatProducts?: ChatProductUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatProducts?: ChatProductUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    chatId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusCreateInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutStatusInput
    orderLogs?: OrderStatusLogCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStatusInput
    orderLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutStatusNestedInput
    orderLogs?: OrderStatusLogUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStatusNestedInput
    orderLogs?: OrderStatusLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusCreateManyInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type OrderStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryMethodCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutDeliveryMethodInput
  }

  export type DeliveryMethodUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryMethodInput
  }

  export type DeliveryMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutDeliveryMethodNestedInput
  }

  export type DeliveryMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutDeliveryMethodNestedInput
  }

  export type DeliveryMethodCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeliveryMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    icon?: string | null
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    icon?: string | null
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    icon?: string | null
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    order: OrderCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutOrderItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutOrderItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderStatusLogCreateInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutStatusLogsInput
    status: OrderStatusCreateNestedOneWithoutOrderLogsInput
    createdBy: UserCreateNestedOneWithoutOrderStatusLogsInput
  }

  export type OrderStatusLogUncheckedCreateInput = {
    id?: string
    orderId: string
    statusId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type OrderStatusLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStatusLogsNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrderLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrderStatusLogsNestedInput
  }

  export type OrderStatusLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogCreateManyInput = {
    id?: string
    orderId: string
    statusId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type OrderStatusLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupCreateInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserCreateNestedManyWithoutCustomerGroupInput
    discountRules?: DiscountRuleCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUncheckedCreateInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUncheckedCreateNestedManyWithoutCustomerGroupInput
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUpdateManyWithoutCustomerGroupNestedInput
    discountRules?: DiscountRuleUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUncheckedUpdateManyWithoutCustomerGroupNestedInput
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupCreateManyInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CustomerGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DiscountRuleCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    customerGroup?: CustomerGroupCreateNestedOneWithoutDiscountRulesInput
    promoCodes?: PromoCodeCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    customerGroupId?: string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customerGroup?: CustomerGroupUpdateOneWithoutDiscountRulesNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleCreateManyInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    customerGroupId?: string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type DiscountRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DiscountRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutPromoCodesInput
    personalUser?: UserCreateNestedOneWithoutPersonalPromoCodesInput
    orders?: OrderCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutPromoCodesNestedInput
    personalUser?: UserUpdateOneWithoutPersonalPromoCodesNestedInput
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageCreateInput = {
    id?: string
    createdAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUsageInput
    user: UserCreateNestedOneWithoutPromoCodeUsageInput
    order?: OrderCreateNestedOneWithoutPromoCodeUsageInput
  }

  export type PromoCodeUsageUncheckedCreateInput = {
    id?: string
    promoCodeId: string
    userId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type PromoCodeUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUsageNestedInput
    user?: UserUpdateOneRequiredWithoutPromoCodeUsageNestedInput
    order?: OrderUpdateOneWithoutPromoCodeUsageNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageCreateManyInput = {
    id?: string
    promoCodeId: string
    userId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type PromoCodeUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CustomerGroupNullableScalarRelationFilter = {
    is?: CustomerGroupWhereInput | null
    isNot?: CustomerGroupWhereInput | null
  }

  export type CartListRelationFilter = {
    every?: CartWhereInput
    some?: CartWhereInput
    none?: CartWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type ViewHistoryListRelationFilter = {
    every?: ViewHistoryWhereInput
    some?: ViewHistoryWhereInput
    none?: ViewHistoryWhereInput
  }

  export type PromoCodeListRelationFilter = {
    every?: PromoCodeWhereInput
    some?: PromoCodeWhereInput
    none?: PromoCodeWhereInput
  }

  export type PromoCodeUsageListRelationFilter = {
    every?: PromoCodeUsageWhereInput
    some?: PromoCodeUsageWhereInput
    none?: PromoCodeUsageWhereInput
  }

  export type OrderStatusLogListRelationFilter = {
    every?: OrderStatusLogWhereInput
    some?: OrderStatusLogWhereInput
    none?: OrderStatusLogWhereInput
  }

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput
    some?: PushSubscriptionWhereInput
    none?: PushSubscriptionWhereInput
  }

  export type NotificationSettingsNullableScalarRelationFilter = {
    is?: NotificationSettingsWhereInput | null
    isNot?: NotificationSettingsWhereInput | null
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ViewHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderStatusLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    customerGroupId?: SortOrder
    personalDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    personalDiscount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    customerGroupId?: SortOrder
    personalDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    customerGroupId?: SortOrder
    personalDiscount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    personalDiscount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AnonymousUserCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type AnonymousUserMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type AnonymousUserMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    lastActivity?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    endpoint?: SortOrder
    p256dh?: SortOrder
    auth?: SortOrder
    userAgent?: SortOrder
    deviceName?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastUsedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newChat?: SortOrder
    newMessage?: SortOrder
    chatAssigned?: SortOrder
    chatStatusChanged?: SortOrder
    orderStatusChanged?: SortOrder
    enableSchedule?: SortOrder
    scheduleStart?: SortOrder
    scheduleEnd?: SortOrder
    scheduleTimezone?: SortOrder
    scheduleDays?: SortOrder
    soundEnabled?: SortOrder
    vibrationEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newChat?: SortOrder
    newMessage?: SortOrder
    chatAssigned?: SortOrder
    chatStatusChanged?: SortOrder
    orderStatusChanged?: SortOrder
    enableSchedule?: SortOrder
    scheduleStart?: SortOrder
    scheduleEnd?: SortOrder
    scheduleTimezone?: SortOrder
    soundEnabled?: SortOrder
    vibrationEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newChat?: SortOrder
    newMessage?: SortOrder
    chatAssigned?: SortOrder
    chatStatusChanged?: SortOrder
    orderStatusChanged?: SortOrder
    enableSchedule?: SortOrder
    scheduleStart?: SortOrder
    scheduleEnd?: SortOrder
    scheduleTimezone?: SortOrder
    soundEnabled?: SortOrder
    vibrationEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    subscriptionId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    subscriptionId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    subscriptionId?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    sentAt?: SortOrder
    clickedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type CharacteristicCategoryListRelationFilter = {
    every?: CharacteristicCategoryWhereInput
    some?: CharacteristicCategoryWhereInput
    none?: CharacteristicCategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacteristicCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type ProductCharacteristicListRelationFilter = {
    every?: ProductCharacteristicWhereInput
    some?: ProductCharacteristicWhereInput
    none?: ProductCharacteristicWhereInput
  }

  export type VehicleApplicationListRelationFilter = {
    every?: VehicleApplicationWhereInput
    some?: VehicleApplicationWhereInput
    none?: VehicleApplicationWhereInput
  }

  export type CrossReferenceListRelationFilter = {
    every?: CrossReferenceWhereInput
    some?: CrossReferenceWhereInput
    none?: CrossReferenceWhereInput
  }

  export type CartItemListRelationFilter = {
    every?: CartItemWhereInput
    some?: CartItemWhereInput
    none?: CartItemWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCharacteristicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrossReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CartItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrder
    brandId?: SortOrder
    isOriginal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    comparePrice?: SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrder
    brandId?: SortOrder
    isOriginal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    shortDescription?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrder
    brandId?: SortOrder
    isOriginal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    comparePrice?: SortOrder
    stock?: SortOrder
    deliveryDays?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ProductCategoryProductIdCategoryIdCompoundUniqueInput = {
    productId: string
    categoryId: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    isPrimary?: SortOrder
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    country?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacteristicValueListRelationFilter = {
    every?: CharacteristicValueWhereInput
    some?: CharacteristicValueWhereInput
    none?: CharacteristicValueWhereInput
  }

  export type CharacteristicValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacteristicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    filterType?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacteristicAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CharacteristicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    filterType?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacteristicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    unit?: SortOrder
    isRequired?: SortOrder
    isFilterable?: SortOrder
    filterType?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacteristicSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CharacteristicScalarRelationFilter = {
    is?: CharacteristicWhereInput
    isNot?: CharacteristicWhereInput
  }

  export type CharacteristicCategoryCharacteristicIdCategoryIdCompoundUniqueInput = {
    characteristicId: string
    categoryId: string
  }

  export type CharacteristicCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    categoryId?: SortOrder
  }

  export type CharacteristicCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    categoryId?: SortOrder
  }

  export type CharacteristicCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    categoryId?: SortOrder
  }

  export type CharacteristicValueCountOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
  }

  export type CharacteristicValueAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CharacteristicValueMaxOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
  }

  export type CharacteristicValueMinOrderByAggregateInput = {
    id?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    sortOrder?: SortOrder
  }

  export type CharacteristicValueSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type CharacteristicValueNullableScalarRelationFilter = {
    is?: CharacteristicValueWhereInput | null
    isNot?: CharacteristicValueWhereInput | null
  }

  export type ProductCharacteristicProductIdCharacteristicIdCompoundUniqueInput = {
    productId: string
    characteristicId: string
  }

  export type ProductCharacteristicCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    characteristicValueId?: SortOrder
  }

  export type ProductCharacteristicMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    characteristicValueId?: SortOrder
  }

  export type ProductCharacteristicMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    value?: SortOrder
    characteristicValueId?: SortOrder
  }

  export type VehicleModelListRelationFilter = {
    every?: VehicleModelWhereInput
    some?: VehicleModelWhereInput
    none?: VehicleModelWhereInput
  }

  export type VehicleModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleMakeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleMakeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleMakeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    country?: SortOrder
    logoUrl?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleMakeScalarRelationFilter = {
    is?: VehicleMakeWhereInput
    isNot?: VehicleMakeWhereInput
  }

  export type VehicleGenerationListRelationFilter = {
    every?: VehicleGenerationWhereInput
    some?: VehicleGenerationWhereInput
    none?: VehicleGenerationWhereInput
  }

  export type VehicleGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleModelCountOrderByAggregateInput = {
    id?: SortOrder
    makeId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    modelCode?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleModelAvgOrderByAggregateInput = {
    startYear?: SortOrder
    endYear?: SortOrder
  }

  export type VehicleModelMaxOrderByAggregateInput = {
    id?: SortOrder
    makeId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    modelCode?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleModelMinOrderByAggregateInput = {
    id?: SortOrder
    makeId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    modelCode?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleModelSumOrderByAggregateInput = {
    startYear?: SortOrder
    endYear?: SortOrder
  }

  export type VehicleModelScalarRelationFilter = {
    is?: VehicleModelWhereInput
    isNot?: VehicleModelWhereInput
  }

  export type VehicleModificationListRelationFilter = {
    every?: VehicleModificationWhereInput
    some?: VehicleModificationWhereInput
    none?: VehicleModificationWhereInput
  }

  export type VehicleModificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    bodyType?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleGenerationAvgOrderByAggregateInput = {
    startYear?: SortOrder
    endYear?: SortOrder
  }

  export type VehicleGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    bodyType?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    modelId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    startYear?: SortOrder
    endYear?: SortOrder
    bodyType?: SortOrder
    description?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
  }

  export type VehicleGenerationSumOrderByAggregateInput = {
    startYear?: SortOrder
    endYear?: SortOrder
  }

  export type VehicleGenerationScalarRelationFilter = {
    is?: VehicleGenerationWhereInput
    isNot?: VehicleGenerationWhereInput
  }

  export type VehicleModificationCountOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    name?: SortOrder
    engineCode?: SortOrder
    fuelType?: SortOrder
    powerHp?: SortOrder
    transmission?: SortOrder
  }

  export type VehicleModificationAvgOrderByAggregateInput = {
    powerHp?: SortOrder
  }

  export type VehicleModificationMaxOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    name?: SortOrder
    engineCode?: SortOrder
    fuelType?: SortOrder
    powerHp?: SortOrder
    transmission?: SortOrder
  }

  export type VehicleModificationMinOrderByAggregateInput = {
    id?: SortOrder
    generationId?: SortOrder
    name?: SortOrder
    engineCode?: SortOrder
    fuelType?: SortOrder
    powerHp?: SortOrder
    transmission?: SortOrder
  }

  export type VehicleModificationSumOrderByAggregateInput = {
    powerHp?: SortOrder
  }

  export type VehicleModificationScalarRelationFilter = {
    is?: VehicleModificationWhereInput
    isNot?: VehicleModificationWhereInput
  }

  export type VehicleApplicationProductIdModificationIdCompoundUniqueInput = {
    productId: string
    modificationId: string
  }

  export type VehicleApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    modificationId?: SortOrder
    kTypeId?: SortOrder
    notes?: SortOrder
    isVerified?: SortOrder
  }

  export type VehicleApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    modificationId?: SortOrder
    kTypeId?: SortOrder
    notes?: SortOrder
    isVerified?: SortOrder
  }

  export type VehicleApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    modificationId?: SortOrder
    kTypeId?: SortOrder
    notes?: SortOrder
    isVerified?: SortOrder
  }

  export type EnumCrossTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CrossType | EnumCrossTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrossTypeFilter<$PrismaModel> | $Enums.CrossType
  }

  export type CrossReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    crossPartNumber?: SortOrder
    crossBrandId?: SortOrder
    crossType?: SortOrder
    confidenceScore?: SortOrder
    verifiedByExpert?: SortOrder
  }

  export type CrossReferenceAvgOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type CrossReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    crossPartNumber?: SortOrder
    crossBrandId?: SortOrder
    crossType?: SortOrder
    confidenceScore?: SortOrder
    verifiedByExpert?: SortOrder
  }

  export type CrossReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    crossPartNumber?: SortOrder
    crossBrandId?: SortOrder
    crossType?: SortOrder
    confidenceScore?: SortOrder
    verifiedByExpert?: SortOrder
  }

  export type CrossReferenceSumOrderByAggregateInput = {
    confidenceScore?: SortOrder
  }

  export type EnumCrossTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrossType | EnumCrossTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrossTypeWithAggregatesFilter<$PrismaModel> | $Enums.CrossType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrossTypeFilter<$PrismaModel>
    _max?: NestedEnumCrossTypeFilter<$PrismaModel>
  }

  export type FavoriteUserIdProductIdCompoundUniqueInput = {
    userId: string
    productId: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AnonymousUserNullableScalarRelationFilter = {
    is?: AnonymousUserWhereInput | null
    isNot?: AnonymousUserWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type ViewHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ViewHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ViewHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    viewedAt?: SortOrder
  }

  export type CartCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CartScalarRelationFilter = {
    is?: CartWhereInput
    isNot?: CartWhereInput
  }

  export type ChatProductNullableScalarRelationFilter = {
    is?: ChatProductWhereInput | null
    isNot?: ChatProductWhereInput | null
  }

  export type CartItemCartIdProductIdChatProductIdCompoundUniqueInput = {
    cartId: string
    productId: string
    chatProductId: string
  }

  export type CartItemCountOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type CartItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type CartItemMaxOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type CartItemMinOrderByAggregateInput = {
    id?: SortOrder
    cartId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type CartItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type ChatProductImageListRelationFilter = {
    every?: ChatProductImageWhereInput
    some?: ChatProductImageWhereInput
    none?: ChatProductImageWhereInput
  }

  export type ChatProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatProductCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    isOriginal?: SortOrder
    deliveryDays?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductAvgOrderByAggregateInput = {
    price?: SortOrder
    comparePrice?: SortOrder
    deliveryDays?: SortOrder
  }

  export type ChatProductMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    isOriginal?: SortOrder
    deliveryDays?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    name?: SortOrder
    brand?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    comparePrice?: SortOrder
    isOriginal?: SortOrder
    deliveryDays?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductSumOrderByAggregateInput = {
    price?: SortOrder
    comparePrice?: SortOrder
    deliveryDays?: SortOrder
  }

  export type ChatProductScalarRelationFilter = {
    is?: ChatProductWhereInput
    isNot?: ChatProductWhereInput
  }

  export type ChatProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    chatProductId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChatProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatProductId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    chatProductId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatProductImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChatStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatStatusAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChatStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatStatusSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChatStatusScalarRelationFilter = {
    is?: ChatStatusWhereInput
    isNot?: ChatStatusWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    managerId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    managerId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    managerId?: SortOrder
    statusId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type EnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatProductListRelationFilter = {
    every?: ChatProductWhereInput
    some?: ChatProductWhereInput
    none?: ChatProductWhereInput
  }

  export type ChatProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    messageType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type OrderStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isInitial?: SortOrder
    isFinalSuccess?: SortOrder
    isFinalFailure?: SortOrder
    canCancelOrder?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStatusAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type OrderStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isInitial?: SortOrder
    isFinalSuccess?: SortOrder
    isFinalFailure?: SortOrder
    canCancelOrder?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isInitial?: SortOrder
    isFinalSuccess?: SortOrder
    isFinalFailure?: SortOrder
    canCancelOrder?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStatusSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type DeliveryMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryMethodAvgOrderByAggregateInput = {
    price?: SortOrder
    minAmount?: SortOrder
    sortOrder?: SortOrder
  }

  export type DeliveryMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    price?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type DeliveryMethodSumOrderByAggregateInput = {
    price?: SortOrder
    minAmount?: SortOrder
    sortOrder?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isOnline?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    settings?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMethodAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    commission?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isOnline?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    isOnline?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    commission?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMethodSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    commission?: SortOrder
  }

  export type OrderStatusScalarRelationFilter = {
    is?: OrderStatusWhereInput
    isNot?: OrderStatusWhereInput
  }

  export type DeliveryMethodScalarRelationFilter = {
    is?: DeliveryMethodWhereInput
    isNot?: DeliveryMethodWhereInput
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type PromoCodeNullableScalarRelationFilter = {
    is?: PromoCodeWhereInput | null
    isNot?: PromoCodeWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
    deliveryMethodId?: SortOrder
    paymentMethodId?: SortOrder
    shippingAddress?: SortOrder
    comment?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
    deliveryMethodId?: SortOrder
    paymentMethodId?: SortOrder
    comment?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    userId?: SortOrder
    statusId?: SortOrder
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
    deliveryMethodId?: SortOrder
    paymentMethodId?: SortOrder
    comment?: SortOrder
    promoCodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    discountAmount?: SortOrder
    shippingAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    chatProductId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    total?: SortOrder
  }

  export type OrderStatusLogCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    statusId?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStatusLogMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    statusId?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderStatusLogMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    statusId?: SortOrder
    comment?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DiscountRuleListRelationFilter = {
    every?: DiscountRuleWhereInput
    some?: DiscountRuleWhereInput
    none?: DiscountRuleWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountPercent?: SortOrder
    minOrderAmount?: SortOrder
    benefits?: SortOrder
  }

  export type CustomerGroupAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type CustomerGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountPercent?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type CustomerGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountPercent?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type CustomerGroupSumOrderByAggregateInput = {
    discountPercent?: SortOrder
    minOrderAmount?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DiscountRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    customerGroupId?: SortOrder
    categories?: SortOrder
    brands?: SortOrder
    isActive?: SortOrder
  }

  export type DiscountRuleAvgOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
  }

  export type DiscountRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    customerGroupId?: SortOrder
    isActive?: SortOrder
  }

  export type DiscountRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    usageLimit?: SortOrder
    customerGroupId?: SortOrder
    isActive?: SortOrder
  }

  export type DiscountRuleSumOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    usageLimit?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type DiscountRuleScalarRelationFilter = {
    is?: DiscountRuleWhereInput
    isNot?: DiscountRuleWhereInput
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountRuleId?: SortOrder
    usageCount?: SortOrder
    usageLimit?: SortOrder
    personalUserId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeAvgOrderByAggregateInput = {
    usageCount?: SortOrder
    usageLimit?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountRuleId?: SortOrder
    usageCount?: SortOrder
    usageLimit?: SortOrder
    personalUserId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    discountRuleId?: SortOrder
    usageCount?: SortOrder
    usageLimit?: SortOrder
    personalUserId?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeSumOrderByAggregateInput = {
    usageCount?: SortOrder
    usageLimit?: SortOrder
  }

  export type PromoCodeScalarRelationFilter = {
    is?: PromoCodeWhereInput
    isNot?: PromoCodeWhereInput
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type PromoCodeUsagePromoCodeIdUserIdOrderIdCompoundUniqueInput = {
    promoCodeId: string
    userId: string
    orderId: string
  }

  export type PromoCodeUsageCountOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoCodeUsageMinOrderByAggregateInput = {
    id?: SortOrder
    promoCodeId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerGroupCreateNestedOneWithoutUsersInput = {
    create?: XOR<CustomerGroupCreateWithoutUsersInput, CustomerGroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutUsersInput
    connect?: CustomerGroupWhereUniqueInput
  }

  export type CartCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutManagerInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ViewHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput> | ViewHistoryCreateWithoutUserInput[] | ViewHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutUserInput | ViewHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ViewHistoryCreateManyUserInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutPersonalUserInput = {
    create?: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput> | PromoCodeCreateWithoutPersonalUserInput[] | PromoCodeUncheckedCreateWithoutPersonalUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutPersonalUserInput | PromoCodeCreateOrConnectWithoutPersonalUserInput[]
    createMany?: PromoCodeCreateManyPersonalUserInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromoCodeUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type OrderStatusLogCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput> | OrderStatusLogCreateWithoutCreatedByInput[] | OrderStatusLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutCreatedByInput | OrderStatusLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderStatusLogCreateManyCreatedByInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type NotificationLogCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ViewHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput> | ViewHistoryCreateWithoutUserInput[] | ViewHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutUserInput | ViewHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ViewHistoryCreateManyUserInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput = {
    create?: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput> | PromoCodeCreateWithoutPersonalUserInput[] | PromoCodeUncheckedCreateWithoutPersonalUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutPersonalUserInput | PromoCodeCreateOrConnectWithoutPersonalUserInput[]
    createMany?: PromoCodeCreateManyPersonalUserInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput> | OrderStatusLogCreateWithoutCreatedByInput[] | OrderStatusLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutCreatedByInput | OrderStatusLogCreateOrConnectWithoutCreatedByInput[]
    createMany?: OrderStatusLogCreateManyCreatedByInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerGroupUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CustomerGroupCreateWithoutUsersInput, CustomerGroupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutUsersInput
    upsert?: CustomerGroupUpsertWithoutUsersInput
    disconnect?: CustomerGroupWhereInput | boolean
    delete?: CustomerGroupWhereInput | boolean
    connect?: CustomerGroupWhereUniqueInput
    update?: XOR<XOR<CustomerGroupUpdateToOneWithWhereWithoutUsersInput, CustomerGroupUpdateWithoutUsersInput>, CustomerGroupUncheckedUpdateWithoutUsersInput>
  }

  export type CartUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutManagerInput | ChatUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutManagerInput | ChatUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutManagerInput | ChatUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ViewHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput> | ViewHistoryCreateWithoutUserInput[] | ViewHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutUserInput | ViewHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutUserInput | ViewHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewHistoryCreateManyUserInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutUserInput | ViewHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutUserInput | ViewHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutPersonalUserNestedInput = {
    create?: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput> | PromoCodeCreateWithoutPersonalUserInput[] | PromoCodeUncheckedCreateWithoutPersonalUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutPersonalUserInput | PromoCodeCreateOrConnectWithoutPersonalUserInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutPersonalUserInput | PromoCodeUpsertWithWhereUniqueWithoutPersonalUserInput[]
    createMany?: PromoCodeCreateManyPersonalUserInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutPersonalUserInput | PromoCodeUpdateWithWhereUniqueWithoutPersonalUserInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutPersonalUserInput | PromoCodeUpdateManyWithWhereWithoutPersonalUserInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromoCodeUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput | PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput | PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutUserInput | PromoCodeUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type OrderStatusLogUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput> | OrderStatusLogCreateWithoutCreatedByInput[] | OrderStatusLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutCreatedByInput | OrderStatusLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutCreatedByInput | OrderStatusLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderStatusLogCreateManyCreatedByInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutCreatedByInput | OrderStatusLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutCreatedByInput | OrderStatusLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type NotificationSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput> | CartCreateWithoutUserInput[] | CartUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutUserInput | CartCreateOrConnectWithoutUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutUserInput | CartUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CartCreateManyUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutUserInput | CartUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutUserInput | CartUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput> | ChatCreateWithoutManagerInput[] | ChatUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutManagerInput | ChatCreateOrConnectWithoutManagerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutManagerInput | ChatUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ChatCreateManyManagerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutManagerInput | ChatUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutManagerInput | ChatUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ViewHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput> | ViewHistoryCreateWithoutUserInput[] | ViewHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutUserInput | ViewHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutUserInput | ViewHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ViewHistoryCreateManyUserInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutUserInput | ViewHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutUserInput | ViewHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput = {
    create?: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput> | PromoCodeCreateWithoutPersonalUserInput[] | PromoCodeUncheckedCreateWithoutPersonalUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutPersonalUserInput | PromoCodeCreateOrConnectWithoutPersonalUserInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutPersonalUserInput | PromoCodeUpsertWithWhereUniqueWithoutPersonalUserInput[]
    createMany?: PromoCodeCreateManyPersonalUserInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutPersonalUserInput | PromoCodeUpdateWithWhereUniqueWithoutPersonalUserInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutPersonalUserInput | PromoCodeUpdateManyWithWhereWithoutPersonalUserInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput> | PromoCodeUsageCreateWithoutUserInput[] | PromoCodeUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutUserInput | PromoCodeUsageCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput | PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeUsageCreateManyUserInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput | PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutUserInput | PromoCodeUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput> | OrderStatusLogCreateWithoutCreatedByInput[] | OrderStatusLogUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutCreatedByInput | OrderStatusLogCreateOrConnectWithoutCreatedByInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutCreatedByInput | OrderStatusLogUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: OrderStatusLogCreateManyCreatedByInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutCreatedByInput | OrderStatusLogUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutCreatedByInput | OrderStatusLogUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput> | PushSubscriptionCreateWithoutUserInput[] | PushSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PushSubscriptionCreateOrConnectWithoutUserInput | PushSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: PushSubscriptionUpsertWithWhereUniqueWithoutUserInput | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PushSubscriptionCreateManyUserInputEnvelope
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    disconnect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    delete?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    connect?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[]
    update?: PushSubscriptionUpdateWithWhereUniqueWithoutUserInput | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PushSubscriptionUpdateManyWithWhereWithoutUserInput | PushSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput> | NotificationLogCreateWithoutUserInput[] | NotificationLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutUserInput | NotificationLogCreateOrConnectWithoutUserInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutUserInput | NotificationLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationLogCreateManyUserInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutUserInput | NotificationLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutUserInput | NotificationLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type CartCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput> | CartCreateWithoutAnonymousUserInput[] | CartUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutAnonymousUserInput | CartCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: CartCreateManyAnonymousUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput> | ChatCreateWithoutAnonymousUserInput[] | ChatUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutAnonymousUserInput | ChatCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: ChatCreateManyAnonymousUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ViewHistoryCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput> | ViewHistoryCreateWithoutAnonymousUserInput[] | ViewHistoryUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutAnonymousUserInput | ViewHistoryCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: ViewHistoryCreateManyAnonymousUserInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type CartUncheckedCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput> | CartCreateWithoutAnonymousUserInput[] | CartUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutAnonymousUserInput | CartCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: CartCreateManyAnonymousUserInputEnvelope
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput> | ChatCreateWithoutAnonymousUserInput[] | ChatUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutAnonymousUserInput | ChatCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: ChatCreateManyAnonymousUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ViewHistoryUncheckedCreateNestedManyWithoutAnonymousUserInput = {
    create?: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput> | ViewHistoryCreateWithoutAnonymousUserInput[] | ViewHistoryUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutAnonymousUserInput | ViewHistoryCreateOrConnectWithoutAnonymousUserInput[]
    createMany?: ViewHistoryCreateManyAnonymousUserInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type CartUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput> | CartCreateWithoutAnonymousUserInput[] | CartUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutAnonymousUserInput | CartCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutAnonymousUserInput | CartUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: CartCreateManyAnonymousUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutAnonymousUserInput | CartUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutAnonymousUserInput | CartUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput> | ChatCreateWithoutAnonymousUserInput[] | ChatUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutAnonymousUserInput | ChatCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutAnonymousUserInput | ChatUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: ChatCreateManyAnonymousUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutAnonymousUserInput | ChatUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutAnonymousUserInput | ChatUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ViewHistoryUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput> | ViewHistoryCreateWithoutAnonymousUserInput[] | ViewHistoryUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutAnonymousUserInput | ViewHistoryCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutAnonymousUserInput | ViewHistoryUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: ViewHistoryCreateManyAnonymousUserInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutAnonymousUserInput | ViewHistoryUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutAnonymousUserInput | ViewHistoryUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type CartUncheckedUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput> | CartCreateWithoutAnonymousUserInput[] | CartUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: CartCreateOrConnectWithoutAnonymousUserInput | CartCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: CartUpsertWithWhereUniqueWithoutAnonymousUserInput | CartUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: CartCreateManyAnonymousUserInputEnvelope
    set?: CartWhereUniqueInput | CartWhereUniqueInput[]
    disconnect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    delete?: CartWhereUniqueInput | CartWhereUniqueInput[]
    connect?: CartWhereUniqueInput | CartWhereUniqueInput[]
    update?: CartUpdateWithWhereUniqueWithoutAnonymousUserInput | CartUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: CartUpdateManyWithWhereWithoutAnonymousUserInput | CartUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: CartScalarWhereInput | CartScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput> | ChatCreateWithoutAnonymousUserInput[] | ChatUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutAnonymousUserInput | ChatCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutAnonymousUserInput | ChatUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: ChatCreateManyAnonymousUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutAnonymousUserInput | ChatUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutAnonymousUserInput | ChatUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ViewHistoryUncheckedUpdateManyWithoutAnonymousUserNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput> | ViewHistoryCreateWithoutAnonymousUserInput[] | ViewHistoryUncheckedCreateWithoutAnonymousUserInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutAnonymousUserInput | ViewHistoryCreateOrConnectWithoutAnonymousUserInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutAnonymousUserInput | ViewHistoryUpsertWithWhereUniqueWithoutAnonymousUserInput[]
    createMany?: ViewHistoryCreateManyAnonymousUserInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutAnonymousUserInput | ViewHistoryUpdateWithWhereUniqueWithoutAnonymousUserInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutAnonymousUserInput | ViewHistoryUpdateManyWithWhereWithoutAnonymousUserInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPushSubscriptionInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPushSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionInput
    upsert?: UserUpsertWithoutPushSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPushSubscriptionInput, UserUpdateWithoutPushSubscriptionInput>, UserUncheckedUpdateWithoutPushSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutNotificationLogInput = {
    create?: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationLogNestedInput = {
    create?: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationLogInput
    upsert?: UserUpsertWithoutNotificationLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationLogInput, UserUpdateWithoutNotificationLogInput>, UserUncheckedUpdateWithoutNotificationLogInput>
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type CharacteristicCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput> | CharacteristicCategoryCreateWithoutCategoryInput[] | CharacteristicCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCategoryInput | CharacteristicCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CharacteristicCategoryCreateManyCategoryInputEnvelope
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
  }

  export type ViewHistoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput> | ViewHistoryCreateWithoutCategoryInput[] | ViewHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutCategoryInput | ViewHistoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ViewHistoryCreateManyCategoryInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput> | CharacteristicCategoryCreateWithoutCategoryInput[] | CharacteristicCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCategoryInput | CharacteristicCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: CharacteristicCategoryCreateManyCategoryInputEnvelope
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
  }

  export type ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput> | ViewHistoryCreateWithoutCategoryInput[] | ViewHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutCategoryInput | ViewHistoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ViewHistoryCreateManyCategoryInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type CharacteristicCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput> | CharacteristicCategoryCreateWithoutCategoryInput[] | CharacteristicCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCategoryInput | CharacteristicCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CharacteristicCategoryUpsertWithWhereUniqueWithoutCategoryInput | CharacteristicCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CharacteristicCategoryCreateManyCategoryInputEnvelope
    set?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    disconnect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    delete?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    update?: CharacteristicCategoryUpdateWithWhereUniqueWithoutCategoryInput | CharacteristicCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CharacteristicCategoryUpdateManyWithWhereWithoutCategoryInput | CharacteristicCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
  }

  export type ViewHistoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput> | ViewHistoryCreateWithoutCategoryInput[] | ViewHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutCategoryInput | ViewHistoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutCategoryInput | ViewHistoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ViewHistoryCreateManyCategoryInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutCategoryInput | ViewHistoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutCategoryInput | ViewHistoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput> | CharacteristicCategoryCreateWithoutCategoryInput[] | CharacteristicCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCategoryInput | CharacteristicCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: CharacteristicCategoryUpsertWithWhereUniqueWithoutCategoryInput | CharacteristicCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CharacteristicCategoryCreateManyCategoryInputEnvelope
    set?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    disconnect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    delete?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    update?: CharacteristicCategoryUpdateWithWhereUniqueWithoutCategoryInput | CharacteristicCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CharacteristicCategoryUpdateManyWithWhereWithoutCategoryInput | CharacteristicCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
  }

  export type ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput> | ViewHistoryCreateWithoutCategoryInput[] | ViewHistoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutCategoryInput | ViewHistoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutCategoryInput | ViewHistoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ViewHistoryCreateManyCategoryInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutCategoryInput | ViewHistoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutCategoryInput | ViewHistoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type BrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type ProductCharacteristicCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type VehicleApplicationCreateNestedManyWithoutProductInput = {
    create?: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput> | VehicleApplicationCreateWithoutProductInput[] | VehicleApplicationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutProductInput | VehicleApplicationCreateOrConnectWithoutProductInput[]
    createMany?: VehicleApplicationCreateManyProductInputEnvelope
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
  }

  export type CrossReferenceCreateNestedManyWithoutProductInput = {
    create?: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput> | CrossReferenceCreateWithoutProductInput[] | CrossReferenceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutProductInput | CrossReferenceCreateOrConnectWithoutProductInput[]
    createMany?: CrossReferenceCreateManyProductInputEnvelope
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutProductInput = {
    create?: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput> | FavoriteCreateWithoutProductInput[] | FavoriteUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
    createMany?: FavoriteCreateManyProductInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ViewHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput> | ViewHistoryCreateWithoutProductInput[] | ViewHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutProductInput | ViewHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ViewHistoryCreateManyProductInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type VehicleApplicationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput> | VehicleApplicationCreateWithoutProductInput[] | VehicleApplicationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutProductInput | VehicleApplicationCreateOrConnectWithoutProductInput[]
    createMany?: VehicleApplicationCreateManyProductInputEnvelope
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
  }

  export type CrossReferenceUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput> | CrossReferenceCreateWithoutProductInput[] | CrossReferenceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutProductInput | CrossReferenceCreateOrConnectWithoutProductInput[]
    createMany?: CrossReferenceCreateManyProductInputEnvelope
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput> | FavoriteCreateWithoutProductInput[] | FavoriteUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
    createMany?: FavoriteCreateManyProductInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ViewHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput> | ViewHistoryCreateWithoutProductInput[] | ViewHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutProductInput | ViewHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ViewHistoryCreateManyProductInputEnvelope
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BrandUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    upsert?: BrandUpsertWithoutProductsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductsInput, BrandUpdateWithoutProductsInput>, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductCharacteristicUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput | ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput | ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutProductInput | ProductCharacteristicUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type VehicleApplicationUpdateManyWithoutProductNestedInput = {
    create?: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput> | VehicleApplicationCreateWithoutProductInput[] | VehicleApplicationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutProductInput | VehicleApplicationCreateOrConnectWithoutProductInput[]
    upsert?: VehicleApplicationUpsertWithWhereUniqueWithoutProductInput | VehicleApplicationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VehicleApplicationCreateManyProductInputEnvelope
    set?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    disconnect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    delete?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    update?: VehicleApplicationUpdateWithWhereUniqueWithoutProductInput | VehicleApplicationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VehicleApplicationUpdateManyWithWhereWithoutProductInput | VehicleApplicationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
  }

  export type CrossReferenceUpdateManyWithoutProductNestedInput = {
    create?: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput> | CrossReferenceCreateWithoutProductInput[] | CrossReferenceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutProductInput | CrossReferenceCreateOrConnectWithoutProductInput[]
    upsert?: CrossReferenceUpsertWithWhereUniqueWithoutProductInput | CrossReferenceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CrossReferenceCreateManyProductInputEnvelope
    set?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    disconnect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    delete?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    update?: CrossReferenceUpdateWithWhereUniqueWithoutProductInput | CrossReferenceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CrossReferenceUpdateManyWithWhereWithoutProductInput | CrossReferenceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutProductNestedInput = {
    create?: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput> | FavoriteCreateWithoutProductInput[] | FavoriteUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutProductInput | FavoriteUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FavoriteCreateManyProductInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutProductInput | FavoriteUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutProductInput | FavoriteUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ViewHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput> | ViewHistoryCreateWithoutProductInput[] | ViewHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutProductInput | ViewHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutProductInput | ViewHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ViewHistoryCreateManyProductInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutProductInput | ViewHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutProductInput | ViewHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput | ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput | ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutProductInput | ProductCharacteristicUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput> | VehicleApplicationCreateWithoutProductInput[] | VehicleApplicationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutProductInput | VehicleApplicationCreateOrConnectWithoutProductInput[]
    upsert?: VehicleApplicationUpsertWithWhereUniqueWithoutProductInput | VehicleApplicationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VehicleApplicationCreateManyProductInputEnvelope
    set?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    disconnect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    delete?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    update?: VehicleApplicationUpdateWithWhereUniqueWithoutProductInput | VehicleApplicationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VehicleApplicationUpdateManyWithWhereWithoutProductInput | VehicleApplicationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
  }

  export type CrossReferenceUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput> | CrossReferenceCreateWithoutProductInput[] | CrossReferenceUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutProductInput | CrossReferenceCreateOrConnectWithoutProductInput[]
    upsert?: CrossReferenceUpsertWithWhereUniqueWithoutProductInput | CrossReferenceUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CrossReferenceCreateManyProductInputEnvelope
    set?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    disconnect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    delete?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    update?: CrossReferenceUpdateWithWhereUniqueWithoutProductInput | CrossReferenceUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CrossReferenceUpdateManyWithWhereWithoutProductInput | CrossReferenceUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput> | CartItemCreateWithoutProductInput[] | CartItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutProductInput | CartItemCreateOrConnectWithoutProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutProductInput | CartItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CartItemCreateManyProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutProductInput | CartItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutProductInput | CartItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput> | FavoriteCreateWithoutProductInput[] | FavoriteUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutProductInput | FavoriteCreateOrConnectWithoutProductInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutProductInput | FavoriteUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FavoriteCreateManyProductInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutProductInput | FavoriteUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutProductInput | FavoriteUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ViewHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput> | ViewHistoryCreateWithoutProductInput[] | ViewHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ViewHistoryCreateOrConnectWithoutProductInput | ViewHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ViewHistoryUpsertWithWhereUniqueWithoutProductInput | ViewHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ViewHistoryCreateManyProductInputEnvelope
    set?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    disconnect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    delete?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    connect?: ViewHistoryWhereUniqueInput | ViewHistoryWhereUniqueInput[]
    update?: ViewHistoryUpdateWithWhereUniqueWithoutProductInput | ViewHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ViewHistoryUpdateManyWithWhereWithoutProductInput | ViewHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    upsert?: ProductUpsertWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCategoriesInput, ProductUpdateWithoutCategoriesInput>, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImagesInput, ProductUpdateWithoutImagesInput>, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CrossReferenceCreateNestedManyWithoutCrossBrandInput = {
    create?: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput> | CrossReferenceCreateWithoutCrossBrandInput[] | CrossReferenceUncheckedCreateWithoutCrossBrandInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutCrossBrandInput | CrossReferenceCreateOrConnectWithoutCrossBrandInput[]
    createMany?: CrossReferenceCreateManyCrossBrandInputEnvelope
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CrossReferenceUncheckedCreateNestedManyWithoutCrossBrandInput = {
    create?: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput> | CrossReferenceCreateWithoutCrossBrandInput[] | CrossReferenceUncheckedCreateWithoutCrossBrandInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutCrossBrandInput | CrossReferenceCreateOrConnectWithoutCrossBrandInput[]
    createMany?: CrossReferenceCreateManyCrossBrandInputEnvelope
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CrossReferenceUpdateManyWithoutCrossBrandNestedInput = {
    create?: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput> | CrossReferenceCreateWithoutCrossBrandInput[] | CrossReferenceUncheckedCreateWithoutCrossBrandInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutCrossBrandInput | CrossReferenceCreateOrConnectWithoutCrossBrandInput[]
    upsert?: CrossReferenceUpsertWithWhereUniqueWithoutCrossBrandInput | CrossReferenceUpsertWithWhereUniqueWithoutCrossBrandInput[]
    createMany?: CrossReferenceCreateManyCrossBrandInputEnvelope
    set?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    disconnect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    delete?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    update?: CrossReferenceUpdateWithWhereUniqueWithoutCrossBrandInput | CrossReferenceUpdateWithWhereUniqueWithoutCrossBrandInput[]
    updateMany?: CrossReferenceUpdateManyWithWhereWithoutCrossBrandInput | CrossReferenceUpdateManyWithWhereWithoutCrossBrandInput[]
    deleteMany?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CrossReferenceUncheckedUpdateManyWithoutCrossBrandNestedInput = {
    create?: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput> | CrossReferenceCreateWithoutCrossBrandInput[] | CrossReferenceUncheckedCreateWithoutCrossBrandInput[]
    connectOrCreate?: CrossReferenceCreateOrConnectWithoutCrossBrandInput | CrossReferenceCreateOrConnectWithoutCrossBrandInput[]
    upsert?: CrossReferenceUpsertWithWhereUniqueWithoutCrossBrandInput | CrossReferenceUpsertWithWhereUniqueWithoutCrossBrandInput[]
    createMany?: CrossReferenceCreateManyCrossBrandInputEnvelope
    set?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    disconnect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    delete?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    connect?: CrossReferenceWhereUniqueInput | CrossReferenceWhereUniqueInput[]
    update?: CrossReferenceUpdateWithWhereUniqueWithoutCrossBrandInput | CrossReferenceUpdateWithWhereUniqueWithoutCrossBrandInput[]
    updateMany?: CrossReferenceUpdateManyWithWhereWithoutCrossBrandInput | CrossReferenceUpdateManyWithWhereWithoutCrossBrandInput[]
    deleteMany?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
  }

  export type CharacteristicValueCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput> | CharacteristicValueCreateWithoutCharacteristicInput[] | CharacteristicValueUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutCharacteristicInput | CharacteristicValueCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicValueCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
  }

  export type ProductCharacteristicCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type CharacteristicCategoryCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput> | CharacteristicCategoryCreateWithoutCharacteristicInput[] | CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput | CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicCategoryCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
  }

  export type CharacteristicValueUncheckedCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput> | CharacteristicValueCreateWithoutCharacteristicInput[] | CharacteristicValueUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutCharacteristicInput | CharacteristicValueCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicValueCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
  }

  export type ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type CharacteristicCategoryUncheckedCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput> | CharacteristicCategoryCreateWithoutCharacteristicInput[] | CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput | CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicCategoryCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
  }

  export type CharacteristicValueUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput> | CharacteristicValueCreateWithoutCharacteristicInput[] | CharacteristicValueUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutCharacteristicInput | CharacteristicValueCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicValueUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicValueUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicValueCreateManyCharacteristicInputEnvelope
    set?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    disconnect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    delete?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    connect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    update?: CharacteristicValueUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicValueUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicValueUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicValueUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicValueScalarWhereInput | CharacteristicValueScalarWhereInput[]
  }

  export type ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type CharacteristicCategoryUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput> | CharacteristicCategoryCreateWithoutCharacteristicInput[] | CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput | CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicCategoryUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicCategoryUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicCategoryCreateManyCharacteristicInputEnvelope
    set?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    disconnect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    delete?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    update?: CharacteristicCategoryUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicCategoryUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicCategoryUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicCategoryUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
  }

  export type CharacteristicValueUncheckedUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput> | CharacteristicValueCreateWithoutCharacteristicInput[] | CharacteristicValueUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutCharacteristicInput | CharacteristicValueCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicValueUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicValueUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicValueCreateManyCharacteristicInputEnvelope
    set?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    disconnect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    delete?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    connect?: CharacteristicValueWhereUniqueInput | CharacteristicValueWhereUniqueInput[]
    update?: CharacteristicValueUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicValueUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicValueUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicValueUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicValueScalarWhereInput | CharacteristicValueScalarWhereInput[]
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput> | CharacteristicCategoryCreateWithoutCharacteristicInput[] | CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput | CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicCategoryUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicCategoryUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicCategoryCreateManyCharacteristicInputEnvelope
    set?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    disconnect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    delete?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    connect?: CharacteristicCategoryWhereUniqueInput | CharacteristicCategoryWhereUniqueInput[]
    update?: CharacteristicCategoryUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicCategoryUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicCategoryUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicCategoryUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
  }

  export type CharacteristicCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<CharacteristicCreateWithoutCategoriesInput, CharacteristicUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutCategoriesInput
    connect?: CharacteristicWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutCharacteristicsInput = {
    create?: XOR<CategoryCreateWithoutCharacteristicsInput, CategoryUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCharacteristicsInput
    connect?: CategoryWhereUniqueInput
  }

  export type CharacteristicUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<CharacteristicCreateWithoutCategoriesInput, CharacteristicUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutCategoriesInput
    upsert?: CharacteristicUpsertWithoutCategoriesInput
    connect?: CharacteristicWhereUniqueInput
    update?: XOR<XOR<CharacteristicUpdateToOneWithWhereWithoutCategoriesInput, CharacteristicUpdateWithoutCategoriesInput>, CharacteristicUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutCharacteristicsNestedInput = {
    create?: XOR<CategoryCreateWithoutCharacteristicsInput, CategoryUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutCharacteristicsInput
    upsert?: CategoryUpsertWithoutCharacteristicsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutCharacteristicsInput, CategoryUpdateWithoutCharacteristicsInput>, CategoryUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type CharacteristicCreateNestedOneWithoutValuesInput = {
    create?: XOR<CharacteristicCreateWithoutValuesInput, CharacteristicUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutValuesInput
    connect?: CharacteristicWhereUniqueInput
  }

  export type ProductCharacteristicCreateNestedManyWithoutCharacteristicValueInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput> | ProductCharacteristicCreateWithoutCharacteristicValueInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicValueInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicValueInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput> | ProductCharacteristicCreateWithoutCharacteristicValueInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicValueInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type CharacteristicUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<CharacteristicCreateWithoutValuesInput, CharacteristicUncheckedCreateWithoutValuesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutValuesInput
    upsert?: CharacteristicUpsertWithoutValuesInput
    connect?: CharacteristicWhereUniqueInput
    update?: XOR<XOR<CharacteristicUpdateToOneWithWhereWithoutValuesInput, CharacteristicUpdateWithoutValuesInput>, CharacteristicUncheckedUpdateWithoutValuesInput>
  }

  export type ProductCharacteristicUpdateManyWithoutCharacteristicValueNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput> | ProductCharacteristicCreateWithoutCharacteristicValueInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicValueInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicValueInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicValueInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicValueInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicValueInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicValueInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicValueInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicValueNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput> | ProductCharacteristicCreateWithoutCharacteristicValueInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicValueInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicValueInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicValueInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicValueInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicValueInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicValueInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicValueInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCharacteristicsInput = {
    create?: XOR<ProductCreateWithoutCharacteristicsInput, ProductUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCharacteristicsInput
    connect?: ProductWhereUniqueInput
  }

  export type CharacteristicCreateNestedOneWithoutProductValuesInput = {
    create?: XOR<CharacteristicCreateWithoutProductValuesInput, CharacteristicUncheckedCreateWithoutProductValuesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutProductValuesInput
    connect?: CharacteristicWhereUniqueInput
  }

  export type CharacteristicValueCreateNestedOneWithoutProductValuesInput = {
    create?: XOR<CharacteristicValueCreateWithoutProductValuesInput, CharacteristicValueUncheckedCreateWithoutProductValuesInput>
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutProductValuesInput
    connect?: CharacteristicValueWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCharacteristicsNestedInput = {
    create?: XOR<ProductCreateWithoutCharacteristicsInput, ProductUncheckedCreateWithoutCharacteristicsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCharacteristicsInput
    upsert?: ProductUpsertWithoutCharacteristicsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCharacteristicsInput, ProductUpdateWithoutCharacteristicsInput>, ProductUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type CharacteristicUpdateOneRequiredWithoutProductValuesNestedInput = {
    create?: XOR<CharacteristicCreateWithoutProductValuesInput, CharacteristicUncheckedCreateWithoutProductValuesInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutProductValuesInput
    upsert?: CharacteristicUpsertWithoutProductValuesInput
    connect?: CharacteristicWhereUniqueInput
    update?: XOR<XOR<CharacteristicUpdateToOneWithWhereWithoutProductValuesInput, CharacteristicUpdateWithoutProductValuesInput>, CharacteristicUncheckedUpdateWithoutProductValuesInput>
  }

  export type CharacteristicValueUpdateOneWithoutProductValuesNestedInput = {
    create?: XOR<CharacteristicValueCreateWithoutProductValuesInput, CharacteristicValueUncheckedCreateWithoutProductValuesInput>
    connectOrCreate?: CharacteristicValueCreateOrConnectWithoutProductValuesInput
    upsert?: CharacteristicValueUpsertWithoutProductValuesInput
    disconnect?: CharacteristicValueWhereInput | boolean
    delete?: CharacteristicValueWhereInput | boolean
    connect?: CharacteristicValueWhereUniqueInput
    update?: XOR<XOR<CharacteristicValueUpdateToOneWithWhereWithoutProductValuesInput, CharacteristicValueUpdateWithoutProductValuesInput>, CharacteristicValueUncheckedUpdateWithoutProductValuesInput>
  }

  export type VehicleModelCreateNestedManyWithoutMakeInput = {
    create?: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput> | VehicleModelCreateWithoutMakeInput[] | VehicleModelUncheckedCreateWithoutMakeInput[]
    connectOrCreate?: VehicleModelCreateOrConnectWithoutMakeInput | VehicleModelCreateOrConnectWithoutMakeInput[]
    createMany?: VehicleModelCreateManyMakeInputEnvelope
    connect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
  }

  export type VehicleModelUncheckedCreateNestedManyWithoutMakeInput = {
    create?: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput> | VehicleModelCreateWithoutMakeInput[] | VehicleModelUncheckedCreateWithoutMakeInput[]
    connectOrCreate?: VehicleModelCreateOrConnectWithoutMakeInput | VehicleModelCreateOrConnectWithoutMakeInput[]
    createMany?: VehicleModelCreateManyMakeInputEnvelope
    connect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
  }

  export type VehicleModelUpdateManyWithoutMakeNestedInput = {
    create?: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput> | VehicleModelCreateWithoutMakeInput[] | VehicleModelUncheckedCreateWithoutMakeInput[]
    connectOrCreate?: VehicleModelCreateOrConnectWithoutMakeInput | VehicleModelCreateOrConnectWithoutMakeInput[]
    upsert?: VehicleModelUpsertWithWhereUniqueWithoutMakeInput | VehicleModelUpsertWithWhereUniqueWithoutMakeInput[]
    createMany?: VehicleModelCreateManyMakeInputEnvelope
    set?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    disconnect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    delete?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    connect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    update?: VehicleModelUpdateWithWhereUniqueWithoutMakeInput | VehicleModelUpdateWithWhereUniqueWithoutMakeInput[]
    updateMany?: VehicleModelUpdateManyWithWhereWithoutMakeInput | VehicleModelUpdateManyWithWhereWithoutMakeInput[]
    deleteMany?: VehicleModelScalarWhereInput | VehicleModelScalarWhereInput[]
  }

  export type VehicleModelUncheckedUpdateManyWithoutMakeNestedInput = {
    create?: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput> | VehicleModelCreateWithoutMakeInput[] | VehicleModelUncheckedCreateWithoutMakeInput[]
    connectOrCreate?: VehicleModelCreateOrConnectWithoutMakeInput | VehicleModelCreateOrConnectWithoutMakeInput[]
    upsert?: VehicleModelUpsertWithWhereUniqueWithoutMakeInput | VehicleModelUpsertWithWhereUniqueWithoutMakeInput[]
    createMany?: VehicleModelCreateManyMakeInputEnvelope
    set?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    disconnect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    delete?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    connect?: VehicleModelWhereUniqueInput | VehicleModelWhereUniqueInput[]
    update?: VehicleModelUpdateWithWhereUniqueWithoutMakeInput | VehicleModelUpdateWithWhereUniqueWithoutMakeInput[]
    updateMany?: VehicleModelUpdateManyWithWhereWithoutMakeInput | VehicleModelUpdateManyWithWhereWithoutMakeInput[]
    deleteMany?: VehicleModelScalarWhereInput | VehicleModelScalarWhereInput[]
  }

  export type VehicleMakeCreateNestedOneWithoutModelsInput = {
    create?: XOR<VehicleMakeCreateWithoutModelsInput, VehicleMakeUncheckedCreateWithoutModelsInput>
    connectOrCreate?: VehicleMakeCreateOrConnectWithoutModelsInput
    connect?: VehicleMakeWhereUniqueInput
  }

  export type VehicleGenerationCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput> | VehicleGenerationCreateWithoutModelInput[] | VehicleGenerationUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModelInput | VehicleGenerationCreateOrConnectWithoutModelInput[]
    createMany?: VehicleGenerationCreateManyModelInputEnvelope
    connect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
  }

  export type VehicleGenerationUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput> | VehicleGenerationCreateWithoutModelInput[] | VehicleGenerationUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModelInput | VehicleGenerationCreateOrConnectWithoutModelInput[]
    createMany?: VehicleGenerationCreateManyModelInputEnvelope
    connect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
  }

  export type VehicleMakeUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<VehicleMakeCreateWithoutModelsInput, VehicleMakeUncheckedCreateWithoutModelsInput>
    connectOrCreate?: VehicleMakeCreateOrConnectWithoutModelsInput
    upsert?: VehicleMakeUpsertWithoutModelsInput
    connect?: VehicleMakeWhereUniqueInput
    update?: XOR<XOR<VehicleMakeUpdateToOneWithWhereWithoutModelsInput, VehicleMakeUpdateWithoutModelsInput>, VehicleMakeUncheckedUpdateWithoutModelsInput>
  }

  export type VehicleGenerationUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput> | VehicleGenerationCreateWithoutModelInput[] | VehicleGenerationUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModelInput | VehicleGenerationCreateOrConnectWithoutModelInput[]
    upsert?: VehicleGenerationUpsertWithWhereUniqueWithoutModelInput | VehicleGenerationUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleGenerationCreateManyModelInputEnvelope
    set?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    disconnect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    delete?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    connect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    update?: VehicleGenerationUpdateWithWhereUniqueWithoutModelInput | VehicleGenerationUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleGenerationUpdateManyWithWhereWithoutModelInput | VehicleGenerationUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleGenerationScalarWhereInput | VehicleGenerationScalarWhereInput[]
  }

  export type VehicleGenerationUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput> | VehicleGenerationCreateWithoutModelInput[] | VehicleGenerationUncheckedCreateWithoutModelInput[]
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModelInput | VehicleGenerationCreateOrConnectWithoutModelInput[]
    upsert?: VehicleGenerationUpsertWithWhereUniqueWithoutModelInput | VehicleGenerationUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: VehicleGenerationCreateManyModelInputEnvelope
    set?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    disconnect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    delete?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    connect?: VehicleGenerationWhereUniqueInput | VehicleGenerationWhereUniqueInput[]
    update?: VehicleGenerationUpdateWithWhereUniqueWithoutModelInput | VehicleGenerationUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: VehicleGenerationUpdateManyWithWhereWithoutModelInput | VehicleGenerationUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: VehicleGenerationScalarWhereInput | VehicleGenerationScalarWhereInput[]
  }

  export type VehicleModelCreateNestedOneWithoutGenerationsInput = {
    create?: XOR<VehicleModelCreateWithoutGenerationsInput, VehicleModelUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: VehicleModelCreateOrConnectWithoutGenerationsInput
    connect?: VehicleModelWhereUniqueInput
  }

  export type VehicleModificationCreateNestedManyWithoutGenerationInput = {
    create?: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput> | VehicleModificationCreateWithoutGenerationInput[] | VehicleModificationUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutGenerationInput | VehicleModificationCreateOrConnectWithoutGenerationInput[]
    createMany?: VehicleModificationCreateManyGenerationInputEnvelope
    connect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
  }

  export type VehicleModificationUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput> | VehicleModificationCreateWithoutGenerationInput[] | VehicleModificationUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutGenerationInput | VehicleModificationCreateOrConnectWithoutGenerationInput[]
    createMany?: VehicleModificationCreateManyGenerationInputEnvelope
    connect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
  }

  export type VehicleModelUpdateOneRequiredWithoutGenerationsNestedInput = {
    create?: XOR<VehicleModelCreateWithoutGenerationsInput, VehicleModelUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: VehicleModelCreateOrConnectWithoutGenerationsInput
    upsert?: VehicleModelUpsertWithoutGenerationsInput
    connect?: VehicleModelWhereUniqueInput
    update?: XOR<XOR<VehicleModelUpdateToOneWithWhereWithoutGenerationsInput, VehicleModelUpdateWithoutGenerationsInput>, VehicleModelUncheckedUpdateWithoutGenerationsInput>
  }

  export type VehicleModificationUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput> | VehicleModificationCreateWithoutGenerationInput[] | VehicleModificationUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutGenerationInput | VehicleModificationCreateOrConnectWithoutGenerationInput[]
    upsert?: VehicleModificationUpsertWithWhereUniqueWithoutGenerationInput | VehicleModificationUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: VehicleModificationCreateManyGenerationInputEnvelope
    set?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    disconnect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    delete?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    connect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    update?: VehicleModificationUpdateWithWhereUniqueWithoutGenerationInput | VehicleModificationUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: VehicleModificationUpdateManyWithWhereWithoutGenerationInput | VehicleModificationUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: VehicleModificationScalarWhereInput | VehicleModificationScalarWhereInput[]
  }

  export type VehicleModificationUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput> | VehicleModificationCreateWithoutGenerationInput[] | VehicleModificationUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutGenerationInput | VehicleModificationCreateOrConnectWithoutGenerationInput[]
    upsert?: VehicleModificationUpsertWithWhereUniqueWithoutGenerationInput | VehicleModificationUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: VehicleModificationCreateManyGenerationInputEnvelope
    set?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    disconnect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    delete?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    connect?: VehicleModificationWhereUniqueInput | VehicleModificationWhereUniqueInput[]
    update?: VehicleModificationUpdateWithWhereUniqueWithoutGenerationInput | VehicleModificationUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: VehicleModificationUpdateManyWithWhereWithoutGenerationInput | VehicleModificationUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: VehicleModificationScalarWhereInput | VehicleModificationScalarWhereInput[]
  }

  export type VehicleGenerationCreateNestedOneWithoutModificationsInput = {
    create?: XOR<VehicleGenerationCreateWithoutModificationsInput, VehicleGenerationUncheckedCreateWithoutModificationsInput>
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModificationsInput
    connect?: VehicleGenerationWhereUniqueInput
  }

  export type VehicleApplicationCreateNestedManyWithoutModificationInput = {
    create?: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput> | VehicleApplicationCreateWithoutModificationInput[] | VehicleApplicationUncheckedCreateWithoutModificationInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutModificationInput | VehicleApplicationCreateOrConnectWithoutModificationInput[]
    createMany?: VehicleApplicationCreateManyModificationInputEnvelope
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
  }

  export type VehicleApplicationUncheckedCreateNestedManyWithoutModificationInput = {
    create?: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput> | VehicleApplicationCreateWithoutModificationInput[] | VehicleApplicationUncheckedCreateWithoutModificationInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutModificationInput | VehicleApplicationCreateOrConnectWithoutModificationInput[]
    createMany?: VehicleApplicationCreateManyModificationInputEnvelope
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
  }

  export type VehicleGenerationUpdateOneRequiredWithoutModificationsNestedInput = {
    create?: XOR<VehicleGenerationCreateWithoutModificationsInput, VehicleGenerationUncheckedCreateWithoutModificationsInput>
    connectOrCreate?: VehicleGenerationCreateOrConnectWithoutModificationsInput
    upsert?: VehicleGenerationUpsertWithoutModificationsInput
    connect?: VehicleGenerationWhereUniqueInput
    update?: XOR<XOR<VehicleGenerationUpdateToOneWithWhereWithoutModificationsInput, VehicleGenerationUpdateWithoutModificationsInput>, VehicleGenerationUncheckedUpdateWithoutModificationsInput>
  }

  export type VehicleApplicationUpdateManyWithoutModificationNestedInput = {
    create?: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput> | VehicleApplicationCreateWithoutModificationInput[] | VehicleApplicationUncheckedCreateWithoutModificationInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutModificationInput | VehicleApplicationCreateOrConnectWithoutModificationInput[]
    upsert?: VehicleApplicationUpsertWithWhereUniqueWithoutModificationInput | VehicleApplicationUpsertWithWhereUniqueWithoutModificationInput[]
    createMany?: VehicleApplicationCreateManyModificationInputEnvelope
    set?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    disconnect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    delete?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    update?: VehicleApplicationUpdateWithWhereUniqueWithoutModificationInput | VehicleApplicationUpdateWithWhereUniqueWithoutModificationInput[]
    updateMany?: VehicleApplicationUpdateManyWithWhereWithoutModificationInput | VehicleApplicationUpdateManyWithWhereWithoutModificationInput[]
    deleteMany?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
  }

  export type VehicleApplicationUncheckedUpdateManyWithoutModificationNestedInput = {
    create?: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput> | VehicleApplicationCreateWithoutModificationInput[] | VehicleApplicationUncheckedCreateWithoutModificationInput[]
    connectOrCreate?: VehicleApplicationCreateOrConnectWithoutModificationInput | VehicleApplicationCreateOrConnectWithoutModificationInput[]
    upsert?: VehicleApplicationUpsertWithWhereUniqueWithoutModificationInput | VehicleApplicationUpsertWithWhereUniqueWithoutModificationInput[]
    createMany?: VehicleApplicationCreateManyModificationInputEnvelope
    set?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    disconnect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    delete?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    connect?: VehicleApplicationWhereUniqueInput | VehicleApplicationWhereUniqueInput[]
    update?: VehicleApplicationUpdateWithWhereUniqueWithoutModificationInput | VehicleApplicationUpdateWithWhereUniqueWithoutModificationInput[]
    updateMany?: VehicleApplicationUpdateManyWithWhereWithoutModificationInput | VehicleApplicationUpdateManyWithWhereWithoutModificationInput[]
    deleteMany?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVehicleApplicationsInput = {
    create?: XOR<ProductCreateWithoutVehicleApplicationsInput, ProductUncheckedCreateWithoutVehicleApplicationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVehicleApplicationsInput
    connect?: ProductWhereUniqueInput
  }

  export type VehicleModificationCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<VehicleModificationCreateWithoutApplicationsInput, VehicleModificationUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutApplicationsInput
    connect?: VehicleModificationWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutVehicleApplicationsNestedInput = {
    create?: XOR<ProductCreateWithoutVehicleApplicationsInput, ProductUncheckedCreateWithoutVehicleApplicationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVehicleApplicationsInput
    upsert?: ProductUpsertWithoutVehicleApplicationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVehicleApplicationsInput, ProductUpdateWithoutVehicleApplicationsInput>, ProductUncheckedUpdateWithoutVehicleApplicationsInput>
  }

  export type VehicleModificationUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<VehicleModificationCreateWithoutApplicationsInput, VehicleModificationUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: VehicleModificationCreateOrConnectWithoutApplicationsInput
    upsert?: VehicleModificationUpsertWithoutApplicationsInput
    connect?: VehicleModificationWhereUniqueInput
    update?: XOR<XOR<VehicleModificationUpdateToOneWithWhereWithoutApplicationsInput, VehicleModificationUpdateWithoutApplicationsInput>, VehicleModificationUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProductCreateNestedOneWithoutCrossReferencesInput = {
    create?: XOR<ProductCreateWithoutCrossReferencesInput, ProductUncheckedCreateWithoutCrossReferencesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCrossReferencesInput
    connect?: ProductWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutCrossReferencesInput = {
    create?: XOR<BrandCreateWithoutCrossReferencesInput, BrandUncheckedCreateWithoutCrossReferencesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCrossReferencesInput
    connect?: BrandWhereUniqueInput
  }

  export type EnumCrossTypeFieldUpdateOperationsInput = {
    set?: $Enums.CrossType
  }

  export type ProductUpdateOneRequiredWithoutCrossReferencesNestedInput = {
    create?: XOR<ProductCreateWithoutCrossReferencesInput, ProductUncheckedCreateWithoutCrossReferencesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCrossReferencesInput
    upsert?: ProductUpsertWithoutCrossReferencesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCrossReferencesInput, ProductUpdateWithoutCrossReferencesInput>, ProductUncheckedUpdateWithoutCrossReferencesInput>
  }

  export type BrandUpdateOneRequiredWithoutCrossReferencesNestedInput = {
    create?: XOR<BrandCreateWithoutCrossReferencesInput, BrandUncheckedCreateWithoutCrossReferencesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutCrossReferencesInput
    upsert?: BrandUpsertWithoutCrossReferencesInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutCrossReferencesInput, BrandUpdateWithoutCrossReferencesInput>, BrandUncheckedUpdateWithoutCrossReferencesInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ProductCreateWithoutFavoritesInput, ProductUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFavoritesInput
    connect?: ProductWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type ProductUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ProductCreateWithoutFavoritesInput, ProductUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFavoritesInput
    upsert?: ProductUpsertWithoutFavoritesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFavoritesInput, ProductUpdateWithoutFavoritesInput>, ProductUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserCreateNestedOneWithoutViewHistoryInput = {
    create?: XOR<UserCreateWithoutViewHistoryInput, UserUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type AnonymousUserCreateNestedOneWithoutViewHistoryInput = {
    create?: XOR<AnonymousUserCreateWithoutViewHistoryInput, AnonymousUserUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutViewHistoryInput
    connect?: AnonymousUserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutViewHistoryInput = {
    create?: XOR<ProductCreateWithoutViewHistoryInput, ProductUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutViewHistoryInput = {
    create?: XOR<CategoryCreateWithoutViewHistoryInput, CategoryUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutViewHistoryInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserUpdateOneWithoutViewHistoryNestedInput = {
    create?: XOR<UserCreateWithoutViewHistoryInput, UserUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewHistoryInput
    upsert?: UserUpsertWithoutViewHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewHistoryInput, UserUpdateWithoutViewHistoryInput>, UserUncheckedUpdateWithoutViewHistoryInput>
  }

  export type AnonymousUserUpdateOneWithoutViewHistoryNestedInput = {
    create?: XOR<AnonymousUserCreateWithoutViewHistoryInput, AnonymousUserUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutViewHistoryInput
    upsert?: AnonymousUserUpsertWithoutViewHistoryInput
    disconnect?: AnonymousUserWhereInput | boolean
    delete?: AnonymousUserWhereInput | boolean
    connect?: AnonymousUserWhereUniqueInput
    update?: XOR<XOR<AnonymousUserUpdateToOneWithWhereWithoutViewHistoryInput, AnonymousUserUpdateWithoutViewHistoryInput>, AnonymousUserUncheckedUpdateWithoutViewHistoryInput>
  }

  export type ProductUpdateOneWithoutViewHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutViewHistoryInput, ProductUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutViewHistoryInput
    upsert?: ProductUpsertWithoutViewHistoryInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutViewHistoryInput, ProductUpdateWithoutViewHistoryInput>, ProductUncheckedUpdateWithoutViewHistoryInput>
  }

  export type CategoryUpdateOneWithoutViewHistoryNestedInput = {
    create?: XOR<CategoryCreateWithoutViewHistoryInput, CategoryUncheckedCreateWithoutViewHistoryInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutViewHistoryInput
    upsert?: CategoryUpsertWithoutViewHistoryInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutViewHistoryInput, CategoryUpdateWithoutViewHistoryInput>, CategoryUncheckedUpdateWithoutViewHistoryInput>
  }

  export type UserCreateNestedOneWithoutCartsInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    connect?: UserWhereUniqueInput
  }

  export type AnonymousUserCreateNestedOneWithoutCartsInput = {
    create?: XOR<AnonymousUserCreateWithoutCartsInput, AnonymousUserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutCartsInput
    connect?: AnonymousUserWhereUniqueInput
  }

  export type CartItemCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCartsNestedInput = {
    create?: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCartsInput
    upsert?: UserUpsertWithoutCartsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCartsInput, UserUpdateWithoutCartsInput>, UserUncheckedUpdateWithoutCartsInput>
  }

  export type AnonymousUserUpdateOneWithoutCartsNestedInput = {
    create?: XOR<AnonymousUserCreateWithoutCartsInput, AnonymousUserUncheckedCreateWithoutCartsInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutCartsInput
    upsert?: AnonymousUserUpsertWithoutCartsInput
    disconnect?: AnonymousUserWhereInput | boolean
    delete?: AnonymousUserWhereInput | boolean
    connect?: AnonymousUserWhereUniqueInput
    update?: XOR<XOR<AnonymousUserUpdateToOneWithWhereWithoutCartsInput, AnonymousUserUpdateWithoutCartsInput>, AnonymousUserUncheckedUpdateWithoutCartsInput>
  }

  export type CartItemUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput> | CartItemCreateWithoutCartInput[] | CartItemUncheckedCreateWithoutCartInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutCartInput | CartItemCreateOrConnectWithoutCartInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutCartInput | CartItemUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: CartItemCreateManyCartInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutCartInput | CartItemUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutCartInput | CartItemUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type CartCreateNestedOneWithoutItemsInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    connect?: CartWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ChatProductCreateNestedOneWithoutCartItemsInput = {
    create?: XOR<ChatProductCreateWithoutCartItemsInput, ChatProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutCartItemsInput
    connect?: ChatProductWhereUniqueInput
  }

  export type CartUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    connectOrCreate?: CartCreateOrConnectWithoutItemsInput
    upsert?: CartUpsertWithoutItemsInput
    connect?: CartWhereUniqueInput
    update?: XOR<XOR<CartUpdateToOneWithWhereWithoutItemsInput, CartUpdateWithoutItemsInput>, CartUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutCartItemsNestedInput = {
    create?: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCartItemsInput
    upsert?: ProductUpsertWithoutCartItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCartItemsInput, ProductUpdateWithoutCartItemsInput>, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ChatProductUpdateOneWithoutCartItemsNestedInput = {
    create?: XOR<ChatProductCreateWithoutCartItemsInput, ChatProductUncheckedCreateWithoutCartItemsInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutCartItemsInput
    upsert?: ChatProductUpsertWithoutCartItemsInput
    disconnect?: ChatProductWhereInput | boolean
    delete?: ChatProductWhereInput | boolean
    connect?: ChatProductWhereUniqueInput
    update?: XOR<XOR<ChatProductUpdateToOneWithWhereWithoutCartItemsInput, ChatProductUpdateWithoutCartItemsInput>, ChatProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type MessageCreateNestedOneWithoutChatProductsInput = {
    create?: XOR<MessageCreateWithoutChatProductsInput, MessageUncheckedCreateWithoutChatProductsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChatProductsInput
    connect?: MessageWhereUniqueInput
  }

  export type ChatProductImageCreateNestedManyWithoutChatProductInput = {
    create?: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput> | ChatProductImageCreateWithoutChatProductInput[] | ChatProductImageUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: ChatProductImageCreateOrConnectWithoutChatProductInput | ChatProductImageCreateOrConnectWithoutChatProductInput[]
    createMany?: ChatProductImageCreateManyChatProductInputEnvelope
    connect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
  }

  export type CartItemCreateNestedManyWithoutChatProductInput = {
    create?: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput> | CartItemCreateWithoutChatProductInput[] | CartItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutChatProductInput | CartItemCreateOrConnectWithoutChatProductInput[]
    createMany?: CartItemCreateManyChatProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutChatProductInput = {
    create?: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput> | OrderItemCreateWithoutChatProductInput[] | OrderItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutChatProductInput | OrderItemCreateOrConnectWithoutChatProductInput[]
    createMany?: OrderItemCreateManyChatProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ChatProductImageUncheckedCreateNestedManyWithoutChatProductInput = {
    create?: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput> | ChatProductImageCreateWithoutChatProductInput[] | ChatProductImageUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: ChatProductImageCreateOrConnectWithoutChatProductInput | ChatProductImageCreateOrConnectWithoutChatProductInput[]
    createMany?: ChatProductImageCreateManyChatProductInputEnvelope
    connect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
  }

  export type CartItemUncheckedCreateNestedManyWithoutChatProductInput = {
    create?: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput> | CartItemCreateWithoutChatProductInput[] | CartItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutChatProductInput | CartItemCreateOrConnectWithoutChatProductInput[]
    createMany?: CartItemCreateManyChatProductInputEnvelope
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutChatProductInput = {
    create?: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput> | OrderItemCreateWithoutChatProductInput[] | OrderItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutChatProductInput | OrderItemCreateOrConnectWithoutChatProductInput[]
    createMany?: OrderItemCreateManyChatProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type MessageUpdateOneRequiredWithoutChatProductsNestedInput = {
    create?: XOR<MessageCreateWithoutChatProductsInput, MessageUncheckedCreateWithoutChatProductsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutChatProductsInput
    upsert?: MessageUpsertWithoutChatProductsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutChatProductsInput, MessageUpdateWithoutChatProductsInput>, MessageUncheckedUpdateWithoutChatProductsInput>
  }

  export type ChatProductImageUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput> | ChatProductImageCreateWithoutChatProductInput[] | ChatProductImageUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: ChatProductImageCreateOrConnectWithoutChatProductInput | ChatProductImageCreateOrConnectWithoutChatProductInput[]
    upsert?: ChatProductImageUpsertWithWhereUniqueWithoutChatProductInput | ChatProductImageUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: ChatProductImageCreateManyChatProductInputEnvelope
    set?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    disconnect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    delete?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    connect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    update?: ChatProductImageUpdateWithWhereUniqueWithoutChatProductInput | ChatProductImageUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: ChatProductImageUpdateManyWithWhereWithoutChatProductInput | ChatProductImageUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: ChatProductImageScalarWhereInput | ChatProductImageScalarWhereInput[]
  }

  export type CartItemUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput> | CartItemCreateWithoutChatProductInput[] | CartItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutChatProductInput | CartItemCreateOrConnectWithoutChatProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutChatProductInput | CartItemUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: CartItemCreateManyChatProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutChatProductInput | CartItemUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutChatProductInput | CartItemUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput> | OrderItemCreateWithoutChatProductInput[] | OrderItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutChatProductInput | OrderItemCreateOrConnectWithoutChatProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutChatProductInput | OrderItemUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: OrderItemCreateManyChatProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutChatProductInput | OrderItemUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutChatProductInput | OrderItemUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ChatProductImageUncheckedUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput> | ChatProductImageCreateWithoutChatProductInput[] | ChatProductImageUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: ChatProductImageCreateOrConnectWithoutChatProductInput | ChatProductImageCreateOrConnectWithoutChatProductInput[]
    upsert?: ChatProductImageUpsertWithWhereUniqueWithoutChatProductInput | ChatProductImageUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: ChatProductImageCreateManyChatProductInputEnvelope
    set?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    disconnect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    delete?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    connect?: ChatProductImageWhereUniqueInput | ChatProductImageWhereUniqueInput[]
    update?: ChatProductImageUpdateWithWhereUniqueWithoutChatProductInput | ChatProductImageUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: ChatProductImageUpdateManyWithWhereWithoutChatProductInput | ChatProductImageUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: ChatProductImageScalarWhereInput | ChatProductImageScalarWhereInput[]
  }

  export type CartItemUncheckedUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput> | CartItemCreateWithoutChatProductInput[] | CartItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: CartItemCreateOrConnectWithoutChatProductInput | CartItemCreateOrConnectWithoutChatProductInput[]
    upsert?: CartItemUpsertWithWhereUniqueWithoutChatProductInput | CartItemUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: CartItemCreateManyChatProductInputEnvelope
    set?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    disconnect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    delete?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    connect?: CartItemWhereUniqueInput | CartItemWhereUniqueInput[]
    update?: CartItemUpdateWithWhereUniqueWithoutChatProductInput | CartItemUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: CartItemUpdateManyWithWhereWithoutChatProductInput | CartItemUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutChatProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput> | OrderItemCreateWithoutChatProductInput[] | OrderItemUncheckedCreateWithoutChatProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutChatProductInput | OrderItemCreateOrConnectWithoutChatProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutChatProductInput | OrderItemUpsertWithWhereUniqueWithoutChatProductInput[]
    createMany?: OrderItemCreateManyChatProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutChatProductInput | OrderItemUpdateWithWhereUniqueWithoutChatProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutChatProductInput | OrderItemUpdateManyWithWhereWithoutChatProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ChatProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ChatProductCreateWithoutImagesInput, ChatProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutImagesInput
    connect?: ChatProductWhereUniqueInput
  }

  export type ChatProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ChatProductCreateWithoutImagesInput, ChatProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutImagesInput
    upsert?: ChatProductUpsertWithoutImagesInput
    connect?: ChatProductWhereUniqueInput
    update?: XOR<XOR<ChatProductUpdateToOneWithWhereWithoutImagesInput, ChatProductUpdateWithoutImagesInput>, ChatProductUncheckedUpdateWithoutImagesInput>
  }

  export type ChatCreateNestedManyWithoutStatusInput = {
    create?: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput> | ChatCreateWithoutStatusInput[] | ChatUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStatusInput | ChatCreateOrConnectWithoutStatusInput[]
    createMany?: ChatCreateManyStatusInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput> | ChatCreateWithoutStatusInput[] | ChatUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStatusInput | ChatCreateOrConnectWithoutStatusInput[]
    createMany?: ChatCreateManyStatusInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ChatUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput> | ChatCreateWithoutStatusInput[] | ChatUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStatusInput | ChatCreateOrConnectWithoutStatusInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStatusInput | ChatUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ChatCreateManyStatusInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStatusInput | ChatUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStatusInput | ChatUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput> | ChatCreateWithoutStatusInput[] | ChatUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutStatusInput | ChatCreateOrConnectWithoutStatusInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutStatusInput | ChatUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: ChatCreateManyStatusInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutStatusInput | ChatUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutStatusInput | ChatUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChatsInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    connect?: UserWhereUniqueInput
  }

  export type AnonymousUserCreateNestedOneWithoutChatsInput = {
    create?: XOR<AnonymousUserCreateWithoutChatsInput, AnonymousUserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutChatsInput
    connect?: AnonymousUserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutManagedChatsInput = {
    create?: XOR<UserCreateWithoutManagedChatsInput, UserUncheckedCreateWithoutManagedChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedChatsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatStatusCreateNestedOneWithoutChatsInput = {
    create?: XOR<ChatStatusCreateWithoutChatsInput, ChatStatusUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ChatStatusCreateOrConnectWithoutChatsInput
    connect?: ChatStatusWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutChatsNestedInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    upsert?: UserUpsertWithoutChatsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsInput, UserUpdateWithoutChatsInput>, UserUncheckedUpdateWithoutChatsInput>
  }

  export type AnonymousUserUpdateOneWithoutChatsNestedInput = {
    create?: XOR<AnonymousUserCreateWithoutChatsInput, AnonymousUserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: AnonymousUserCreateOrConnectWithoutChatsInput
    upsert?: AnonymousUserUpsertWithoutChatsInput
    disconnect?: AnonymousUserWhereInput | boolean
    delete?: AnonymousUserWhereInput | boolean
    connect?: AnonymousUserWhereUniqueInput
    update?: XOR<XOR<AnonymousUserUpdateToOneWithWhereWithoutChatsInput, AnonymousUserUpdateWithoutChatsInput>, AnonymousUserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateOneWithoutManagedChatsNestedInput = {
    create?: XOR<UserCreateWithoutManagedChatsInput, UserUncheckedCreateWithoutManagedChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedChatsInput
    upsert?: UserUpsertWithoutManagedChatsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedChatsInput, UserUpdateWithoutManagedChatsInput>, UserUncheckedUpdateWithoutManagedChatsInput>
  }

  export type ChatStatusUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<ChatStatusCreateWithoutChatsInput, ChatStatusUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ChatStatusCreateOrConnectWithoutChatsInput
    upsert?: ChatStatusUpsertWithoutChatsInput
    connect?: ChatStatusWhereUniqueInput
    update?: XOR<XOR<ChatStatusUpdateToOneWithWhereWithoutChatsInput, ChatStatusUpdateWithoutChatsInput>, ChatStatusUncheckedUpdateWithoutChatsInput>
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type ChatProductCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput> | ChatProductCreateWithoutMessageInput[] | ChatProductUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatProductCreateOrConnectWithoutMessageInput | ChatProductCreateOrConnectWithoutMessageInput[]
    createMany?: ChatProductCreateManyMessageInputEnvelope
    connect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
  }

  export type ChatProductUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput> | ChatProductCreateWithoutMessageInput[] | ChatProductUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatProductCreateOrConnectWithoutMessageInput | ChatProductCreateOrConnectWithoutMessageInput[]
    createMany?: ChatProductCreateManyMessageInputEnvelope
    connect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
  }

  export type EnumSenderTypeFieldUpdateOperationsInput = {
    set?: $Enums.SenderType
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatProductUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput> | ChatProductCreateWithoutMessageInput[] | ChatProductUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatProductCreateOrConnectWithoutMessageInput | ChatProductCreateOrConnectWithoutMessageInput[]
    upsert?: ChatProductUpsertWithWhereUniqueWithoutMessageInput | ChatProductUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatProductCreateManyMessageInputEnvelope
    set?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    disconnect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    delete?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    connect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    update?: ChatProductUpdateWithWhereUniqueWithoutMessageInput | ChatProductUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatProductUpdateManyWithWhereWithoutMessageInput | ChatProductUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatProductScalarWhereInput | ChatProductScalarWhereInput[]
  }

  export type ChatProductUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput> | ChatProductCreateWithoutMessageInput[] | ChatProductUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: ChatProductCreateOrConnectWithoutMessageInput | ChatProductCreateOrConnectWithoutMessageInput[]
    upsert?: ChatProductUpsertWithWhereUniqueWithoutMessageInput | ChatProductUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: ChatProductCreateManyMessageInputEnvelope
    set?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    disconnect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    delete?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    connect?: ChatProductWhereUniqueInput | ChatProductWhereUniqueInput[]
    update?: ChatProductUpdateWithWhereUniqueWithoutMessageInput | ChatProductUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: ChatProductUpdateManyWithWhereWithoutMessageInput | ChatProductUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: ChatProductScalarWhereInput | ChatProductScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderStatusLogCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput> | OrderStatusLogCreateWithoutStatusInput[] | OrderStatusLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutStatusInput | OrderStatusLogCreateOrConnectWithoutStatusInput[]
    createMany?: OrderStatusLogCreateManyStatusInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderStatusLogUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput> | OrderStatusLogCreateWithoutStatusInput[] | OrderStatusLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutStatusInput | OrderStatusLogCreateOrConnectWithoutStatusInput[]
    createMany?: OrderStatusLogCreateManyStatusInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStatusInput | OrderUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStatusInput | OrderUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStatusInput | OrderUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderStatusLogUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput> | OrderStatusLogCreateWithoutStatusInput[] | OrderStatusLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutStatusInput | OrderStatusLogCreateOrConnectWithoutStatusInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutStatusInput | OrderStatusLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderStatusLogCreateManyStatusInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutStatusInput | OrderStatusLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutStatusInput | OrderStatusLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput> | OrderCreateWithoutStatusInput[] | OrderUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutStatusInput | OrderCreateOrConnectWithoutStatusInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutStatusInput | OrderUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderCreateManyStatusInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutStatusInput | OrderUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutStatusInput | OrderUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput> | OrderStatusLogCreateWithoutStatusInput[] | OrderStatusLogUncheckedCreateWithoutStatusInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutStatusInput | OrderStatusLogCreateOrConnectWithoutStatusInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutStatusInput | OrderStatusLogUpsertWithWhereUniqueWithoutStatusInput[]
    createMany?: OrderStatusLogCreateManyStatusInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutStatusInput | OrderStatusLogUpdateWithWhereUniqueWithoutStatusInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutStatusInput | OrderStatusLogUpdateManyWithWhereWithoutStatusInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutDeliveryMethodInput = {
    create?: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput> | OrderCreateWithoutDeliveryMethodInput[] | OrderUncheckedCreateWithoutDeliveryMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryMethodInput | OrderCreateOrConnectWithoutDeliveryMethodInput[]
    createMany?: OrderCreateManyDeliveryMethodInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutDeliveryMethodInput = {
    create?: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput> | OrderCreateWithoutDeliveryMethodInput[] | OrderUncheckedCreateWithoutDeliveryMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryMethodInput | OrderCreateOrConnectWithoutDeliveryMethodInput[]
    createMany?: OrderCreateManyDeliveryMethodInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutDeliveryMethodNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput> | OrderCreateWithoutDeliveryMethodInput[] | OrderUncheckedCreateWithoutDeliveryMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryMethodInput | OrderCreateOrConnectWithoutDeliveryMethodInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryMethodInput | OrderUpsertWithWhereUniqueWithoutDeliveryMethodInput[]
    createMany?: OrderCreateManyDeliveryMethodInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryMethodInput | OrderUpdateWithWhereUniqueWithoutDeliveryMethodInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryMethodInput | OrderUpdateManyWithWhereWithoutDeliveryMethodInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryMethodNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput> | OrderCreateWithoutDeliveryMethodInput[] | OrderUncheckedCreateWithoutDeliveryMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryMethodInput | OrderCreateOrConnectWithoutDeliveryMethodInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryMethodInput | OrderUpsertWithWhereUniqueWithoutDeliveryMethodInput[]
    createMany?: OrderCreateManyDeliveryMethodInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryMethodInput | OrderUpdateWithWhereUniqueWithoutDeliveryMethodInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryMethodInput | OrderUpdateManyWithWhereWithoutDeliveryMethodInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput> | OrderCreateWithoutPaymentMethodInput[] | OrderUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMethodInput | OrderCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: OrderCreateManyPaymentMethodInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput> | OrderCreateWithoutPaymentMethodInput[] | OrderUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMethodInput | OrderCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: OrderCreateManyPaymentMethodInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput> | OrderCreateWithoutPaymentMethodInput[] | OrderUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMethodInput | OrderCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPaymentMethodInput | OrderUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: OrderCreateManyPaymentMethodInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPaymentMethodInput | OrderUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPaymentMethodInput | OrderUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput> | OrderCreateWithoutPaymentMethodInput[] | OrderUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentMethodInput | OrderCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPaymentMethodInput | OrderUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: OrderCreateManyPaymentMethodInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPaymentMethodInput | OrderUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPaymentMethodInput | OrderUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderStatusCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
  }

  export type DeliveryMethodCreateNestedOneWithoutOrdersInput = {
    create?: XOR<DeliveryMethodCreateWithoutOrdersInput, DeliveryMethodUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryMethodCreateOrConnectWithoutOrdersInput
    connect?: DeliveryMethodWhereUniqueInput
  }

  export type PaymentMethodCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PaymentMethodCreateWithoutOrdersInput, PaymentMethodUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutOrdersInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type PromoCodeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStatusLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput> | OrderStatusLogCreateWithoutOrderInput[] | OrderStatusLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutOrderInput | OrderStatusLogCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusLogCreateManyOrderInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromoCodeUsageCreateNestedManyWithoutOrderInput = {
    create?: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput> | PromoCodeUsageCreateWithoutOrderInput[] | PromoCodeUsageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutOrderInput | PromoCodeUsageCreateOrConnectWithoutOrderInput[]
    createMany?: PromoCodeUsageCreateManyOrderInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput> | OrderStatusLogCreateWithoutOrderInput[] | OrderStatusLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutOrderInput | OrderStatusLogCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusLogCreateManyOrderInputEnvelope
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput> | PromoCodeUsageCreateWithoutOrderInput[] | PromoCodeUsageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutOrderInput | PromoCodeUsageCreateOrConnectWithoutOrderInput[]
    createMany?: PromoCodeUsageCreateManyOrderInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrdersInput
    upsert?: OrderStatusUpsertWithoutOrdersInput
    connect?: OrderStatusWhereUniqueInput
    update?: XOR<XOR<OrderStatusUpdateToOneWithWhereWithoutOrdersInput, OrderStatusUpdateWithoutOrdersInput>, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<DeliveryMethodCreateWithoutOrdersInput, DeliveryMethodUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: DeliveryMethodCreateOrConnectWithoutOrdersInput
    upsert?: DeliveryMethodUpsertWithoutOrdersInput
    connect?: DeliveryMethodWhereUniqueInput
    update?: XOR<XOR<DeliveryMethodUpdateToOneWithWhereWithoutOrdersInput, DeliveryMethodUpdateWithoutOrdersInput>, DeliveryMethodUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutOrdersInput, PaymentMethodUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutOrdersInput
    upsert?: PaymentMethodUpsertWithoutOrdersInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutOrdersInput, PaymentMethodUpdateWithoutOrdersInput>, PaymentMethodUncheckedUpdateWithoutOrdersInput>
  }

  export type PromoCodeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutOrdersInput
    upsert?: PromoCodeUpsertWithoutOrdersInput
    disconnect?: PromoCodeWhereInput | boolean
    delete?: PromoCodeWhereInput | boolean
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutOrdersInput, PromoCodeUpdateWithoutOrdersInput>, PromoCodeUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStatusLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput> | OrderStatusLogCreateWithoutOrderInput[] | OrderStatusLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutOrderInput | OrderStatusLogCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutOrderInput | OrderStatusLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusLogCreateManyOrderInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutOrderInput | OrderStatusLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutOrderInput | OrderStatusLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromoCodeUsageUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput> | PromoCodeUsageCreateWithoutOrderInput[] | PromoCodeUsageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutOrderInput | PromoCodeUsageCreateOrConnectWithoutOrderInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutOrderInput | PromoCodeUsageUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PromoCodeUsageCreateManyOrderInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutOrderInput | PromoCodeUsageUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutOrderInput | PromoCodeUsageUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput> | OrderStatusLogCreateWithoutOrderInput[] | OrderStatusLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusLogCreateOrConnectWithoutOrderInput | OrderStatusLogCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusLogUpsertWithWhereUniqueWithoutOrderInput | OrderStatusLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusLogCreateManyOrderInputEnvelope
    set?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    disconnect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    delete?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    connect?: OrderStatusLogWhereUniqueInput | OrderStatusLogWhereUniqueInput[]
    update?: OrderStatusLogUpdateWithWhereUniqueWithoutOrderInput | OrderStatusLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusLogUpdateManyWithWhereWithoutOrderInput | OrderStatusLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput> | PromoCodeUsageCreateWithoutOrderInput[] | PromoCodeUsageUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutOrderInput | PromoCodeUsageCreateOrConnectWithoutOrderInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutOrderInput | PromoCodeUsageUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PromoCodeUsageCreateManyOrderInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutOrderInput | PromoCodeUsageUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutOrderInput | PromoCodeUsageUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type ChatProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ChatProductCreateWithoutOrderItemsInput, ChatProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutOrderItemsInput
    connect?: ChatProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type ProductUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ChatProductUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<ChatProductCreateWithoutOrderItemsInput, ChatProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ChatProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ChatProductUpsertWithoutOrderItemsInput
    disconnect?: ChatProductWhereInput | boolean
    delete?: ChatProductWhereInput | boolean
    connect?: ChatProductWhereUniqueInput
    update?: XOR<XOR<ChatProductUpdateToOneWithWhereWithoutOrderItemsInput, ChatProductUpdateWithoutOrderItemsInput>, ChatProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutStatusLogsInput = {
    create?: XOR<OrderCreateWithoutStatusLogsInput, OrderUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusLogsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderStatusCreateNestedOneWithoutOrderLogsInput = {
    create?: XOR<OrderStatusCreateWithoutOrderLogsInput, OrderStatusUncheckedCreateWithoutOrderLogsInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderLogsInput
    connect?: OrderStatusWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderStatusLogsInput = {
    create?: XOR<UserCreateWithoutOrderStatusLogsInput, UserUncheckedCreateWithoutOrderStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderStatusLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutStatusLogsNestedInput = {
    create?: XOR<OrderCreateWithoutStatusLogsInput, OrderUncheckedCreateWithoutStatusLogsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusLogsInput
    upsert?: OrderUpsertWithoutStatusLogsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStatusLogsInput, OrderUpdateWithoutStatusLogsInput>, OrderUncheckedUpdateWithoutStatusLogsInput>
  }

  export type OrderStatusUpdateOneRequiredWithoutOrderLogsNestedInput = {
    create?: XOR<OrderStatusCreateWithoutOrderLogsInput, OrderStatusUncheckedCreateWithoutOrderLogsInput>
    connectOrCreate?: OrderStatusCreateOrConnectWithoutOrderLogsInput
    upsert?: OrderStatusUpsertWithoutOrderLogsInput
    connect?: OrderStatusWhereUniqueInput
    update?: XOR<XOR<OrderStatusUpdateToOneWithWhereWithoutOrderLogsInput, OrderStatusUpdateWithoutOrderLogsInput>, OrderStatusUncheckedUpdateWithoutOrderLogsInput>
  }

  export type UserUpdateOneRequiredWithoutOrderStatusLogsNestedInput = {
    create?: XOR<UserCreateWithoutOrderStatusLogsInput, UserUncheckedCreateWithoutOrderStatusLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderStatusLogsInput
    upsert?: UserUpsertWithoutOrderStatusLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderStatusLogsInput, UserUpdateWithoutOrderStatusLogsInput>, UserUncheckedUpdateWithoutOrderStatusLogsInput>
  }

  export type OrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentsInput
    upsert?: OrderUpsertWithoutPaymentsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentsInput, OrderUpdateWithoutPaymentsInput>, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput> | UserCreateWithoutCustomerGroupInput[] | UserUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerGroupInput | UserCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: UserCreateManyCustomerGroupInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DiscountRuleCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput> | DiscountRuleCreateWithoutCustomerGroupInput[] | DiscountRuleUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerGroupInput | DiscountRuleCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: DiscountRuleCreateManyCustomerGroupInputEnvelope
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput> | UserCreateWithoutCustomerGroupInput[] | UserUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerGroupInput | UserCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: UserCreateManyCustomerGroupInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DiscountRuleUncheckedCreateNestedManyWithoutCustomerGroupInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput> | DiscountRuleCreateWithoutCustomerGroupInput[] | DiscountRuleUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerGroupInput | DiscountRuleCreateOrConnectWithoutCustomerGroupInput[]
    createMany?: DiscountRuleCreateManyCustomerGroupInputEnvelope
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput> | UserCreateWithoutCustomerGroupInput[] | UserUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerGroupInput | UserCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomerGroupInput | UserUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: UserCreateManyCustomerGroupInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomerGroupInput | UserUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomerGroupInput | UserUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DiscountRuleUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput> | DiscountRuleCreateWithoutCustomerGroupInput[] | DiscountRuleUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerGroupInput | DiscountRuleCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: DiscountRuleUpsertWithWhereUniqueWithoutCustomerGroupInput | DiscountRuleUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: DiscountRuleCreateManyCustomerGroupInputEnvelope
    set?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    disconnect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    delete?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    update?: DiscountRuleUpdateWithWhereUniqueWithoutCustomerGroupInput | DiscountRuleUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: DiscountRuleUpdateManyWithWhereWithoutCustomerGroupInput | DiscountRuleUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput> | UserCreateWithoutCustomerGroupInput[] | UserUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCustomerGroupInput | UserCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCustomerGroupInput | UserUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: UserCreateManyCustomerGroupInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCustomerGroupInput | UserUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCustomerGroupInput | UserUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DiscountRuleUncheckedUpdateManyWithoutCustomerGroupNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput> | DiscountRuleCreateWithoutCustomerGroupInput[] | DiscountRuleUncheckedCreateWithoutCustomerGroupInput[]
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutCustomerGroupInput | DiscountRuleCreateOrConnectWithoutCustomerGroupInput[]
    upsert?: DiscountRuleUpsertWithWhereUniqueWithoutCustomerGroupInput | DiscountRuleUpsertWithWhereUniqueWithoutCustomerGroupInput[]
    createMany?: DiscountRuleCreateManyCustomerGroupInputEnvelope
    set?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    disconnect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    delete?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    connect?: DiscountRuleWhereUniqueInput | DiscountRuleWhereUniqueInput[]
    update?: DiscountRuleUpdateWithWhereUniqueWithoutCustomerGroupInput | DiscountRuleUpdateWithWhereUniqueWithoutCustomerGroupInput[]
    updateMany?: DiscountRuleUpdateManyWithWhereWithoutCustomerGroupInput | DiscountRuleUpdateManyWithWhereWithoutCustomerGroupInput[]
    deleteMany?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
  }

  export type CustomerGroupCreateNestedOneWithoutDiscountRulesInput = {
    create?: XOR<CustomerGroupCreateWithoutDiscountRulesInput, CustomerGroupUncheckedCreateWithoutDiscountRulesInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutDiscountRulesInput
    connect?: CustomerGroupWhereUniqueInput
  }

  export type PromoCodeCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput> | PromoCodeCreateWithoutDiscountRuleInput[] | PromoCodeUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutDiscountRuleInput | PromoCodeCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: PromoCodeCreateManyDiscountRuleInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutDiscountRuleInput = {
    create?: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput> | PromoCodeCreateWithoutDiscountRuleInput[] | PromoCodeUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutDiscountRuleInput | PromoCodeCreateOrConnectWithoutDiscountRuleInput[]
    createMany?: PromoCodeCreateManyDiscountRuleInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type CustomerGroupUpdateOneWithoutDiscountRulesNestedInput = {
    create?: XOR<CustomerGroupCreateWithoutDiscountRulesInput, CustomerGroupUncheckedCreateWithoutDiscountRulesInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutDiscountRulesInput
    upsert?: CustomerGroupUpsertWithoutDiscountRulesInput
    disconnect?: CustomerGroupWhereInput | boolean
    delete?: CustomerGroupWhereInput | boolean
    connect?: CustomerGroupWhereUniqueInput
    update?: XOR<XOR<CustomerGroupUpdateToOneWithWhereWithoutDiscountRulesInput, CustomerGroupUpdateWithoutDiscountRulesInput>, CustomerGroupUncheckedUpdateWithoutDiscountRulesInput>
  }

  export type PromoCodeUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput> | PromoCodeCreateWithoutDiscountRuleInput[] | PromoCodeUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutDiscountRuleInput | PromoCodeCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutDiscountRuleInput | PromoCodeUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: PromoCodeCreateManyDiscountRuleInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutDiscountRuleInput | PromoCodeUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutDiscountRuleInput | PromoCodeUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutDiscountRuleNestedInput = {
    create?: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput> | PromoCodeCreateWithoutDiscountRuleInput[] | PromoCodeUncheckedCreateWithoutDiscountRuleInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutDiscountRuleInput | PromoCodeCreateOrConnectWithoutDiscountRuleInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutDiscountRuleInput | PromoCodeUpsertWithWhereUniqueWithoutDiscountRuleInput[]
    createMany?: PromoCodeCreateManyDiscountRuleInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutDiscountRuleInput | PromoCodeUpdateWithWhereUniqueWithoutDiscountRuleInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutDiscountRuleInput | PromoCodeUpdateManyWithWhereWithoutDiscountRuleInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type DiscountRuleCreateNestedOneWithoutPromoCodesInput = {
    create?: XOR<DiscountRuleCreateWithoutPromoCodesInput, DiscountRuleUncheckedCreateWithoutPromoCodesInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutPromoCodesInput
    connect?: DiscountRuleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPersonalPromoCodesInput = {
    create?: XOR<UserCreateWithoutPersonalPromoCodesInput, UserUncheckedCreateWithoutPersonalPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalPromoCodesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromoCodeUsageCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
  }

  export type DiscountRuleUpdateOneRequiredWithoutPromoCodesNestedInput = {
    create?: XOR<DiscountRuleCreateWithoutPromoCodesInput, DiscountRuleUncheckedCreateWithoutPromoCodesInput>
    connectOrCreate?: DiscountRuleCreateOrConnectWithoutPromoCodesInput
    upsert?: DiscountRuleUpsertWithoutPromoCodesInput
    connect?: DiscountRuleWhereUniqueInput
    update?: XOR<XOR<DiscountRuleUpdateToOneWithWhereWithoutPromoCodesInput, DiscountRuleUpdateWithoutPromoCodesInput>, DiscountRuleUncheckedUpdateWithoutPromoCodesInput>
  }

  export type UserUpdateOneWithoutPersonalPromoCodesNestedInput = {
    create?: XOR<UserCreateWithoutPersonalPromoCodesInput, UserUncheckedCreateWithoutPersonalPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalPromoCodesInput
    upsert?: UserUpsertWithoutPersonalPromoCodesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalPromoCodesInput, UserUpdateWithoutPersonalPromoCodesInput>, UserUncheckedUpdateWithoutPersonalPromoCodesInput>
  }

  export type OrderUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPromoCodeInput | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPromoCodeInput | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPromoCodeInput | OrderUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput | PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput> | OrderCreateWithoutPromoCodeInput[] | OrderUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeInput | OrderCreateOrConnectWithoutPromoCodeInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPromoCodeInput | OrderUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: OrderCreateManyPromoCodeInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPromoCodeInput | OrderUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPromoCodeInput | OrderUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput = {
    create?: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput> | PromoCodeUsageCreateWithoutPromoCodeInput[] | PromoCodeUsageUncheckedCreateWithoutPromoCodeInput[]
    connectOrCreate?: PromoCodeUsageCreateOrConnectWithoutPromoCodeInput | PromoCodeUsageCreateOrConnectWithoutPromoCodeInput[]
    upsert?: PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput[]
    createMany?: PromoCodeUsageCreateManyPromoCodeInputEnvelope
    set?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    disconnect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    delete?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    connect?: PromoCodeUsageWhereUniqueInput | PromoCodeUsageWhereUniqueInput[]
    update?: PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput | PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput[]
    updateMany?: PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput | PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput[]
    deleteMany?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
  }

  export type PromoCodeCreateNestedOneWithoutUsageInput = {
    create?: XOR<PromoCodeCreateWithoutUsageInput, PromoCodeUncheckedCreateWithoutUsageInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUsageInput
    connect?: PromoCodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPromoCodeUsageInput = {
    create?: XOR<UserCreateWithoutPromoCodeUsageInput, UserUncheckedCreateWithoutPromoCodeUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodeUsageInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutPromoCodeUsageInput = {
    create?: XOR<OrderCreateWithoutPromoCodeUsageInput, OrderUncheckedCreateWithoutPromoCodeUsageInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeUsageInput
    connect?: OrderWhereUniqueInput
  }

  export type PromoCodeUpdateOneRequiredWithoutUsageNestedInput = {
    create?: XOR<PromoCodeCreateWithoutUsageInput, PromoCodeUncheckedCreateWithoutUsageInput>
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUsageInput
    upsert?: PromoCodeUpsertWithoutUsageInput
    connect?: PromoCodeWhereUniqueInput
    update?: XOR<XOR<PromoCodeUpdateToOneWithWhereWithoutUsageInput, PromoCodeUpdateWithoutUsageInput>, PromoCodeUncheckedUpdateWithoutUsageInput>
  }

  export type UserUpdateOneRequiredWithoutPromoCodeUsageNestedInput = {
    create?: XOR<UserCreateWithoutPromoCodeUsageInput, UserUncheckedCreateWithoutPromoCodeUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodeUsageInput
    upsert?: UserUpsertWithoutPromoCodeUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPromoCodeUsageInput, UserUpdateWithoutPromoCodeUsageInput>, UserUncheckedUpdateWithoutPromoCodeUsageInput>
  }

  export type OrderUpdateOneWithoutPromoCodeUsageNestedInput = {
    create?: XOR<OrderCreateWithoutPromoCodeUsageInput, OrderUncheckedCreateWithoutPromoCodeUsageInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPromoCodeUsageInput
    upsert?: OrderUpsertWithoutPromoCodeUsageInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPromoCodeUsageInput, OrderUpdateWithoutPromoCodeUsageInput>, OrderUncheckedUpdateWithoutPromoCodeUsageInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCrossTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CrossType | EnumCrossTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrossTypeFilter<$PrismaModel> | $Enums.CrossType
  }

  export type NestedEnumCrossTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrossType | EnumCrossTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrossType[] | ListEnumCrossTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCrossTypeWithAggregatesFilter<$PrismaModel> | $Enums.CrossType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrossTypeFilter<$PrismaModel>
    _max?: NestedEnumCrossTypeFilter<$PrismaModel>
  }

  export type NestedEnumSenderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeFilter<$PrismaModel> | $Enums.SenderType
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SenderType | EnumSenderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SenderType[] | ListEnumSenderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSenderTypeWithAggregatesFilter<$PrismaModel> | $Enums.SenderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSenderTypeFilter<$PrismaModel>
    _max?: NestedEnumSenderTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type CustomerGroupCreateWithoutUsersInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    discountRules?: DiscountRuleCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    discountRules?: DiscountRuleUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupCreateOrConnectWithoutUsersInput = {
    where: CustomerGroupWhereUniqueInput
    create: XOR<CustomerGroupCreateWithoutUsersInput, CustomerGroupUncheckedCreateWithoutUsersInput>
  }

  export type CartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    anonymousUser?: AnonymousUserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartCreateManyUserInputEnvelope = {
    data: CartCreateManyUserInput | CartCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    anonymousUser?: AnonymousUserCreateNestedOneWithoutChatsInput
    manager?: UserCreateNestedOneWithoutManagedChatsInput
    status: ChatStatusCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatCreateManyUserInputEnvelope = {
    data: ChatCreateManyUserInput | ChatCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutManagerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutChatsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutChatsInput
    status: ChatStatusCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutManagerInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutManagerInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput>
  }

  export type ChatCreateManyManagerInputEnvelope = {
    data: ChatCreateManyManagerInput | ChatCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewHistoryCreateWithoutUserInput = {
    id?: string
    viewedAt?: Date | string
    anonymousUser?: AnonymousUserCreateNestedOneWithoutViewHistoryInput
    product?: ProductCreateNestedOneWithoutViewHistoryInput
    category?: CategoryCreateNestedOneWithoutViewHistoryInput
  }

  export type ViewHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryCreateOrConnectWithoutUserInput = {
    where: ViewHistoryWhereUniqueInput
    create: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput>
  }

  export type ViewHistoryCreateManyUserInputEnvelope = {
    data: ViewHistoryCreateManyUserInput | ViewHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutPersonalUserInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutPromoCodesInput
    orders?: OrderCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateWithoutPersonalUserInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeCreateOrConnectWithoutPersonalUserInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput>
  }

  export type PromoCodeCreateManyPersonalUserInputEnvelope = {
    data: PromoCodeCreateManyPersonalUserInput | PromoCodeCreateManyPersonalUserInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeUsageCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUsageInput
    order?: OrderCreateNestedOneWithoutPromoCodeUsageInput
  }

  export type PromoCodeUsageUncheckedCreateWithoutUserInput = {
    id?: string
    promoCodeId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateOrConnectWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    create: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeUsageCreateManyUserInputEnvelope = {
    data: PromoCodeUsageCreateManyUserInput | PromoCodeUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderStatusLogCreateWithoutCreatedByInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutStatusLogsInput
    status: OrderStatusCreateNestedOneWithoutOrderLogsInput
  }

  export type OrderStatusLogUncheckedCreateWithoutCreatedByInput = {
    id?: string
    orderId: string
    statusId: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type OrderStatusLogCreateOrConnectWithoutCreatedByInput = {
    where: OrderStatusLogWhereUniqueInput
    create: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderStatusLogCreateManyCreatedByInputEnvelope = {
    data: OrderStatusLogCreateManyCreatedByInput | OrderStatusLogCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data: PushSubscriptionCreateManyUserInput | PushSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    id?: string
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: string | null
    scheduleEnd?: string | null
    scheduleTimezone?: string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    newChat?: boolean
    newMessage?: boolean
    chatAssigned?: boolean
    chatStatusChanged?: boolean
    orderStatusChanged?: boolean
    enableSchedule?: boolean
    scheduleStart?: string | null
    scheduleEnd?: string | null
    scheduleTimezone?: string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: boolean
    vibrationEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
  }

  export type NotificationLogUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
  }

  export type NotificationLogCreateOrConnectWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogCreateManyUserInputEnvelope = {
    data: NotificationLogCreateManyUserInput | NotificationLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerGroupUpsertWithoutUsersInput = {
    update: XOR<CustomerGroupUpdateWithoutUsersInput, CustomerGroupUncheckedUpdateWithoutUsersInput>
    create: XOR<CustomerGroupCreateWithoutUsersInput, CustomerGroupUncheckedCreateWithoutUsersInput>
    where?: CustomerGroupWhereInput
  }

  export type CustomerGroupUpdateToOneWithWhereWithoutUsersInput = {
    where?: CustomerGroupWhereInput
    data: XOR<CustomerGroupUpdateWithoutUsersInput, CustomerGroupUncheckedUpdateWithoutUsersInput>
  }

  export type CustomerGroupUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    discountRules?: DiscountRuleUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    discountRules?: DiscountRuleUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CartUpsertWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
    create: XOR<CartCreateWithoutUserInput, CartUncheckedCreateWithoutUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutUserInput, CartUncheckedUpdateWithoutUserInput>
  }

  export type CartUpdateManyWithWhereWithoutUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutUserInput>
  }

  export type CartScalarWhereInput = {
    AND?: CartScalarWhereInput | CartScalarWhereInput[]
    OR?: CartScalarWhereInput[]
    NOT?: CartScalarWhereInput | CartScalarWhereInput[]
    id?: StringFilter<"Cart"> | string
    userId?: StringNullableFilter<"Cart"> | string | null
    anonymousId?: StringNullableFilter<"Cart"> | string | null
    createdAt?: DateTimeFilter<"Cart"> | Date | string
    updatedAt?: DateTimeFilter<"Cart"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    statusId?: StringFilter<"Order"> | string
    subtotal?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFilter<"Order"> | string
    paymentMethodId?: StringFilter<"Order"> | string
    shippingAddress?: JsonNullableFilter<"Order">
    comment?: StringNullableFilter<"Order"> | string | null
    promoCodeId?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    userId?: StringNullableFilter<"Chat"> | string | null
    anonymousId?: StringNullableFilter<"Chat"> | string | null
    managerId?: StringNullableFilter<"Chat"> | string | null
    statusId?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    closedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
  }

  export type ChatUpsertWithWhereUniqueWithoutManagerInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutManagerInput, ChatUncheckedUpdateWithoutManagerInput>
    create: XOR<ChatCreateWithoutManagerInput, ChatUncheckedCreateWithoutManagerInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutManagerInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutManagerInput, ChatUncheckedUpdateWithoutManagerInput>
  }

  export type ChatUpdateManyWithWhereWithoutManagerInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutManagerInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    productId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type ViewHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ViewHistoryWhereUniqueInput
    update: XOR<ViewHistoryUpdateWithoutUserInput, ViewHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ViewHistoryCreateWithoutUserInput, ViewHistoryUncheckedCreateWithoutUserInput>
  }

  export type ViewHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ViewHistoryWhereUniqueInput
    data: XOR<ViewHistoryUpdateWithoutUserInput, ViewHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ViewHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ViewHistoryScalarWhereInput
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type ViewHistoryScalarWhereInput = {
    AND?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
    OR?: ViewHistoryScalarWhereInput[]
    NOT?: ViewHistoryScalarWhereInput | ViewHistoryScalarWhereInput[]
    id?: StringFilter<"ViewHistory"> | string
    userId?: StringNullableFilter<"ViewHistory"> | string | null
    anonymousId?: StringNullableFilter<"ViewHistory"> | string | null
    productId?: StringNullableFilter<"ViewHistory"> | string | null
    categoryId?: StringNullableFilter<"ViewHistory"> | string | null
    viewedAt?: DateTimeFilter<"ViewHistory"> | Date | string
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutPersonalUserInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutPersonalUserInput, PromoCodeUncheckedUpdateWithoutPersonalUserInput>
    create: XOR<PromoCodeCreateWithoutPersonalUserInput, PromoCodeUncheckedCreateWithoutPersonalUserInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutPersonalUserInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutPersonalUserInput, PromoCodeUncheckedUpdateWithoutPersonalUserInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutPersonalUserInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutPersonalUserInput>
  }

  export type PromoCodeScalarWhereInput = {
    AND?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    OR?: PromoCodeScalarWhereInput[]
    NOT?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    discountRuleId?: StringFilter<"PromoCode"> | string
    usageCount?: IntFilter<"PromoCode"> | number
    usageLimit?: IntNullableFilter<"PromoCode"> | number | null
    personalUserId?: StringNullableFilter<"PromoCode"> | string | null
    expiresAt?: DateTimeNullableFilter<"PromoCode"> | Date | string | null
    isActive?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
  }

  export type PromoCodeUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    update: XOR<PromoCodeUsageUpdateWithoutUserInput, PromoCodeUsageUncheckedUpdateWithoutUserInput>
    create: XOR<PromoCodeUsageCreateWithoutUserInput, PromoCodeUsageUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: PromoCodeUsageWhereUniqueInput
    data: XOR<PromoCodeUsageUpdateWithoutUserInput, PromoCodeUsageUncheckedUpdateWithoutUserInput>
  }

  export type PromoCodeUsageUpdateManyWithWhereWithoutUserInput = {
    where: PromoCodeUsageScalarWhereInput
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type PromoCodeUsageScalarWhereInput = {
    AND?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
    OR?: PromoCodeUsageScalarWhereInput[]
    NOT?: PromoCodeUsageScalarWhereInput | PromoCodeUsageScalarWhereInput[]
    id?: StringFilter<"PromoCodeUsage"> | string
    promoCodeId?: StringFilter<"PromoCodeUsage"> | string
    userId?: StringFilter<"PromoCodeUsage"> | string
    orderId?: StringNullableFilter<"PromoCodeUsage"> | string | null
    createdAt?: DateTimeFilter<"PromoCodeUsage"> | Date | string
  }

  export type OrderStatusLogUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: OrderStatusLogWhereUniqueInput
    update: XOR<OrderStatusLogUpdateWithoutCreatedByInput, OrderStatusLogUncheckedUpdateWithoutCreatedByInput>
    create: XOR<OrderStatusLogCreateWithoutCreatedByInput, OrderStatusLogUncheckedCreateWithoutCreatedByInput>
  }

  export type OrderStatusLogUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: OrderStatusLogWhereUniqueInput
    data: XOR<OrderStatusLogUpdateWithoutCreatedByInput, OrderStatusLogUncheckedUpdateWithoutCreatedByInput>
  }

  export type OrderStatusLogUpdateManyWithWhereWithoutCreatedByInput = {
    where: OrderStatusLogScalarWhereInput
    data: XOR<OrderStatusLogUpdateManyMutationInput, OrderStatusLogUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type OrderStatusLogScalarWhereInput = {
    AND?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
    OR?: OrderStatusLogScalarWhereInput[]
    NOT?: OrderStatusLogScalarWhereInput | OrderStatusLogScalarWhereInput[]
    id?: StringFilter<"OrderStatusLog"> | string
    orderId?: StringFilter<"OrderStatusLog"> | string
    statusId?: StringFilter<"OrderStatusLog"> | string
    comment?: StringNullableFilter<"OrderStatusLog"> | string | null
    createdById?: StringFilter<"OrderStatusLog"> | string
    createdAt?: DateTimeFilter<"OrderStatusLog"> | Date | string
  }

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    update: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<PushSubscriptionCreateWithoutUserInput, PushSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput
    data: XOR<PushSubscriptionUpdateWithoutUserInput, PushSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput
    data: XOR<PushSubscriptionUpdateManyMutationInput, PushSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    OR?: PushSubscriptionScalarWhereInput[]
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[]
    id?: StringFilter<"PushSubscription"> | string
    userId?: StringFilter<"PushSubscription"> | string
    endpoint?: StringFilter<"PushSubscription"> | string
    p256dh?: StringFilter<"PushSubscription"> | string
    auth?: StringFilter<"PushSubscription"> | string
    userAgent?: StringNullableFilter<"PushSubscription"> | string | null
    deviceName?: StringNullableFilter<"PushSubscription"> | string | null
    isActive?: BoolFilter<"PushSubscription"> | boolean
    createdAt?: DateTimeFilter<"PushSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"PushSubscription"> | Date | string
    lastUsedAt?: DateTimeFilter<"PushSubscription"> | Date | string
  }

  export type NotificationSettingsUpsertWithoutUserInput = {
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    where?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationSettingsWhereInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    newChat?: BoolFieldUpdateOperationsInput | boolean
    newMessage?: BoolFieldUpdateOperationsInput | boolean
    chatAssigned?: BoolFieldUpdateOperationsInput | boolean
    chatStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    orderStatusChanged?: BoolFieldUpdateOperationsInput | boolean
    enableSchedule?: BoolFieldUpdateOperationsInput | boolean
    scheduleStart?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleEnd?: NullableStringFieldUpdateOperationsInput | string | null
    scheduleTimezone?: StringFieldUpdateOperationsInput | string
    scheduleDays?: NullableJsonNullValueInput | InputJsonValue
    soundEnabled?: BoolFieldUpdateOperationsInput | boolean
    vibrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationLogCreateWithoutUserInput, NotificationLogUncheckedCreateWithoutUserInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutUserInput, NotificationLogUncheckedUpdateWithoutUserInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutUserInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    userId?: StringFilter<"NotificationLog"> | string
    type?: StringFilter<"NotificationLog"> | string
    title?: StringFilter<"NotificationLog"> | string
    body?: StringFilter<"NotificationLog"> | string
    data?: JsonNullableFilter<"NotificationLog">
    subscriptionId?: StringNullableFilter<"NotificationLog"> | string | null
    status?: StringFilter<"NotificationLog"> | string
    errorMessage?: StringNullableFilter<"NotificationLog"> | string | null
    sentAt?: DateTimeFilter<"NotificationLog"> | Date | string
    clickedAt?: DateTimeNullableFilter<"NotificationLog"> | Date | string | null
  }

  export type CartCreateWithoutAnonymousUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
    items?: CartItemCreateNestedManyWithoutCartInput
  }

  export type CartUncheckedCreateWithoutAnonymousUserInput = {
    id?: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: CartItemUncheckedCreateNestedManyWithoutCartInput
  }

  export type CartCreateOrConnectWithoutAnonymousUserInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput>
  }

  export type CartCreateManyAnonymousUserInputEnvelope = {
    data: CartCreateManyAnonymousUserInput | CartCreateManyAnonymousUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutAnonymousUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutChatsInput
    manager?: UserCreateNestedOneWithoutManagedChatsInput
    status: ChatStatusCreateNestedOneWithoutChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutAnonymousUserInput = {
    id?: string
    userId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutAnonymousUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput>
  }

  export type ChatCreateManyAnonymousUserInputEnvelope = {
    data: ChatCreateManyAnonymousUserInput | ChatCreateManyAnonymousUserInput[]
    skipDuplicates?: boolean
  }

  export type ViewHistoryCreateWithoutAnonymousUserInput = {
    id?: string
    viewedAt?: Date | string
    user?: UserCreateNestedOneWithoutViewHistoryInput
    product?: ProductCreateNestedOneWithoutViewHistoryInput
    category?: CategoryCreateNestedOneWithoutViewHistoryInput
  }

  export type ViewHistoryUncheckedCreateWithoutAnonymousUserInput = {
    id?: string
    userId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryCreateOrConnectWithoutAnonymousUserInput = {
    where: ViewHistoryWhereUniqueInput
    create: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput>
  }

  export type ViewHistoryCreateManyAnonymousUserInputEnvelope = {
    data: ViewHistoryCreateManyAnonymousUserInput | ViewHistoryCreateManyAnonymousUserInput[]
    skipDuplicates?: boolean
  }

  export type CartUpsertWithWhereUniqueWithoutAnonymousUserInput = {
    where: CartWhereUniqueInput
    update: XOR<CartUpdateWithoutAnonymousUserInput, CartUncheckedUpdateWithoutAnonymousUserInput>
    create: XOR<CartCreateWithoutAnonymousUserInput, CartUncheckedCreateWithoutAnonymousUserInput>
  }

  export type CartUpdateWithWhereUniqueWithoutAnonymousUserInput = {
    where: CartWhereUniqueInput
    data: XOR<CartUpdateWithoutAnonymousUserInput, CartUncheckedUpdateWithoutAnonymousUserInput>
  }

  export type CartUpdateManyWithWhereWithoutAnonymousUserInput = {
    where: CartScalarWhereInput
    data: XOR<CartUpdateManyMutationInput, CartUncheckedUpdateManyWithoutAnonymousUserInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutAnonymousUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutAnonymousUserInput, ChatUncheckedUpdateWithoutAnonymousUserInput>
    create: XOR<ChatCreateWithoutAnonymousUserInput, ChatUncheckedCreateWithoutAnonymousUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutAnonymousUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutAnonymousUserInput, ChatUncheckedUpdateWithoutAnonymousUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutAnonymousUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutAnonymousUserInput>
  }

  export type ViewHistoryUpsertWithWhereUniqueWithoutAnonymousUserInput = {
    where: ViewHistoryWhereUniqueInput
    update: XOR<ViewHistoryUpdateWithoutAnonymousUserInput, ViewHistoryUncheckedUpdateWithoutAnonymousUserInput>
    create: XOR<ViewHistoryCreateWithoutAnonymousUserInput, ViewHistoryUncheckedCreateWithoutAnonymousUserInput>
  }

  export type ViewHistoryUpdateWithWhereUniqueWithoutAnonymousUserInput = {
    where: ViewHistoryWhereUniqueInput
    data: XOR<ViewHistoryUpdateWithoutAnonymousUserInput, ViewHistoryUncheckedUpdateWithoutAnonymousUserInput>
  }

  export type ViewHistoryUpdateManyWithWhereWithoutAnonymousUserInput = {
    where: ViewHistoryScalarWhereInput
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyWithoutAnonymousUserInput>
  }

  export type UserCreateWithoutPushSubscriptionInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPushSubscriptionInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPushSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
  }

  export type UserUpsertWithoutPushSubscriptionInput = {
    update: XOR<UserUpdateWithoutPushSubscriptionInput, UserUncheckedUpdateWithoutPushSubscriptionInput>
    create: XOR<UserCreateWithoutPushSubscriptionInput, UserUncheckedCreateWithoutPushSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPushSubscriptionInput, UserUncheckedUpdateWithoutPushSubscriptionInput>
  }

  export type UserUpdateWithoutPushSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPushSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationLogInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationLogInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
  }

  export type UserUpsertWithoutNotificationLogInput = {
    update: XOR<UserUpdateWithoutNotificationLogInput, UserUncheckedUpdateWithoutNotificationLogInput>
    create: XOR<UserCreateWithoutNotificationLogInput, UserUncheckedCreateWithoutNotificationLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationLogInput, UserUncheckedUpdateWithoutNotificationLogInput>
  }

  export type UserUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryCreateWithoutCategoryInput = {
    id?: string
    isPrimary?: boolean
    product: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    productId: string
    isPrimary?: boolean
  }

  export type ProductCategoryCreateOrConnectWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryCreateManyCategoryInputEnvelope = {
    data: ProductCategoryCreateManyCategoryInput | ProductCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CharacteristicCategoryCreateWithoutCategoryInput = {
    id?: string
    characteristic: CharacteristicCreateNestedOneWithoutCategoriesInput
  }

  export type CharacteristicCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    characteristicId: string
  }

  export type CharacteristicCategoryCreateOrConnectWithoutCategoryInput = {
    where: CharacteristicCategoryWhereUniqueInput
    create: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CharacteristicCategoryCreateManyCategoryInputEnvelope = {
    data: CharacteristicCategoryCreateManyCategoryInput | CharacteristicCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ViewHistoryCreateWithoutCategoryInput = {
    id?: string
    viewedAt?: Date | string
    user?: UserCreateNestedOneWithoutViewHistoryInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutViewHistoryInput
    product?: ProductCreateNestedOneWithoutViewHistoryInput
  }

  export type ViewHistoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    productId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryCreateOrConnectWithoutCategoryInput = {
    where: ViewHistoryWhereUniqueInput
    create: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput>
  }

  export type ViewHistoryCreateManyCategoryInputEnvelope = {
    data: ViewHistoryCreateManyCategoryInput | ViewHistoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    sortOrder?: IntFilter<"Category"> | number
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    metaTitle?: StringNullableFilter<"Category"> | string | null
    metaDescription?: StringNullableFilter<"Category"> | string | null
    metaKeywords?: StringNullableFilter<"Category"> | string | null
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    isPrimary?: BoolFilter<"ProductCategory"> | boolean
  }

  export type CharacteristicCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CharacteristicCategoryWhereUniqueInput
    update: XOR<CharacteristicCategoryUpdateWithoutCategoryInput, CharacteristicCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<CharacteristicCategoryCreateWithoutCategoryInput, CharacteristicCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type CharacteristicCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CharacteristicCategoryWhereUniqueInput
    data: XOR<CharacteristicCategoryUpdateWithoutCategoryInput, CharacteristicCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type CharacteristicCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: CharacteristicCategoryScalarWhereInput
    data: XOR<CharacteristicCategoryUpdateManyMutationInput, CharacteristicCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CharacteristicCategoryScalarWhereInput = {
    AND?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
    OR?: CharacteristicCategoryScalarWhereInput[]
    NOT?: CharacteristicCategoryScalarWhereInput | CharacteristicCategoryScalarWhereInput[]
    id?: StringFilter<"CharacteristicCategory"> | string
    characteristicId?: StringFilter<"CharacteristicCategory"> | string
    categoryId?: StringFilter<"CharacteristicCategory"> | string
  }

  export type ViewHistoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ViewHistoryWhereUniqueInput
    update: XOR<ViewHistoryUpdateWithoutCategoryInput, ViewHistoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ViewHistoryCreateWithoutCategoryInput, ViewHistoryUncheckedCreateWithoutCategoryInput>
  }

  export type ViewHistoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ViewHistoryWhereUniqueInput
    data: XOR<ViewHistoryUpdateWithoutCategoryInput, ViewHistoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ViewHistoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ViewHistoryScalarWhereInput
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BrandCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    crossReferences?: CrossReferenceCreateNestedManyWithoutCrossBrandInput
  }

  export type BrandUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutCrossBrandInput
  }

  export type BrandCreateOrConnectWithoutProductsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id?: string
    isPrimary?: boolean
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    categoryId: string
    isPrimary?: boolean
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateManyProductInputEnvelope = {
    data: ProductCategoryCreateManyProductInput | ProductCategoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductImageCreateWithoutProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCharacteristicCreateWithoutProductInput = {
    id?: string
    value?: string | null
    characteristic: CharacteristicCreateNestedOneWithoutProductValuesInput
    characteristicValue?: CharacteristicValueCreateNestedOneWithoutProductValuesInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutProductInput = {
    id?: string
    characteristicId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type ProductCharacteristicCreateOrConnectWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput>
  }

  export type ProductCharacteristicCreateManyProductInputEnvelope = {
    data: ProductCharacteristicCreateManyProductInput | ProductCharacteristicCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type VehicleApplicationCreateWithoutProductInput = {
    id?: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
    modification: VehicleModificationCreateNestedOneWithoutApplicationsInput
  }

  export type VehicleApplicationUncheckedCreateWithoutProductInput = {
    id?: string
    modificationId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type VehicleApplicationCreateOrConnectWithoutProductInput = {
    where: VehicleApplicationWhereUniqueInput
    create: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput>
  }

  export type VehicleApplicationCreateManyProductInputEnvelope = {
    data: VehicleApplicationCreateManyProductInput | VehicleApplicationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CrossReferenceCreateWithoutProductInput = {
    id?: string
    crossPartNumber: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
    crossBrand: BrandCreateNestedOneWithoutCrossReferencesInput
  }

  export type CrossReferenceUncheckedCreateWithoutProductInput = {
    id?: string
    crossPartNumber: string
    crossBrandId: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type CrossReferenceCreateOrConnectWithoutProductInput = {
    where: CrossReferenceWhereUniqueInput
    create: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput>
  }

  export type CrossReferenceCreateManyProductInputEnvelope = {
    data: CrossReferenceCreateManyProductInput | CrossReferenceCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutProductInput = {
    id?: string
    cartId: string
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemCreateManyProductInputEnvelope = {
    data: CartItemCreateManyProductInput | CartItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    order: OrderCreateNestedOneWithoutItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutProductInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
  }

  export type FavoriteCreateManyProductInputEnvelope = {
    data: FavoriteCreateManyProductInput | FavoriteCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ViewHistoryCreateWithoutProductInput = {
    id?: string
    viewedAt?: Date | string
    user?: UserCreateNestedOneWithoutViewHistoryInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutViewHistoryInput
    category?: CategoryCreateNestedOneWithoutViewHistoryInput
  }

  export type ViewHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ViewHistoryCreateOrConnectWithoutProductInput = {
    where: ViewHistoryWhereUniqueInput
    create: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput>
  }

  export type ViewHistoryCreateManyProductInputEnvelope = {
    data: ViewHistoryCreateManyProductInput | ViewHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutProductsInput = {
    update: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossReferences?: CrossReferenceUpdateManyWithoutCrossBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutCrossBrandNestedInput
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    alt?: StringNullableFilter<"ProductImage"> | string | null
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
  }

  export type ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    update: XOR<ProductCharacteristicUpdateWithoutProductInput, ProductCharacteristicUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput>
  }

  export type ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    data: XOR<ProductCharacteristicUpdateWithoutProductInput, ProductCharacteristicUncheckedUpdateWithoutProductInput>
  }

  export type ProductCharacteristicUpdateManyWithWhereWithoutProductInput = {
    where: ProductCharacteristicScalarWhereInput
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCharacteristicScalarWhereInput = {
    AND?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
    OR?: ProductCharacteristicScalarWhereInput[]
    NOT?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
    id?: StringFilter<"ProductCharacteristic"> | string
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    value?: StringNullableFilter<"ProductCharacteristic"> | string | null
    characteristicValueId?: StringNullableFilter<"ProductCharacteristic"> | string | null
  }

  export type VehicleApplicationUpsertWithWhereUniqueWithoutProductInput = {
    where: VehicleApplicationWhereUniqueInput
    update: XOR<VehicleApplicationUpdateWithoutProductInput, VehicleApplicationUncheckedUpdateWithoutProductInput>
    create: XOR<VehicleApplicationCreateWithoutProductInput, VehicleApplicationUncheckedCreateWithoutProductInput>
  }

  export type VehicleApplicationUpdateWithWhereUniqueWithoutProductInput = {
    where: VehicleApplicationWhereUniqueInput
    data: XOR<VehicleApplicationUpdateWithoutProductInput, VehicleApplicationUncheckedUpdateWithoutProductInput>
  }

  export type VehicleApplicationUpdateManyWithWhereWithoutProductInput = {
    where: VehicleApplicationScalarWhereInput
    data: XOR<VehicleApplicationUpdateManyMutationInput, VehicleApplicationUncheckedUpdateManyWithoutProductInput>
  }

  export type VehicleApplicationScalarWhereInput = {
    AND?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
    OR?: VehicleApplicationScalarWhereInput[]
    NOT?: VehicleApplicationScalarWhereInput | VehicleApplicationScalarWhereInput[]
    id?: StringFilter<"VehicleApplication"> | string
    productId?: StringFilter<"VehicleApplication"> | string
    modificationId?: StringFilter<"VehicleApplication"> | string
    kTypeId?: StringNullableFilter<"VehicleApplication"> | string | null
    notes?: StringNullableFilter<"VehicleApplication"> | string | null
    isVerified?: BoolFilter<"VehicleApplication"> | boolean
  }

  export type CrossReferenceUpsertWithWhereUniqueWithoutProductInput = {
    where: CrossReferenceWhereUniqueInput
    update: XOR<CrossReferenceUpdateWithoutProductInput, CrossReferenceUncheckedUpdateWithoutProductInput>
    create: XOR<CrossReferenceCreateWithoutProductInput, CrossReferenceUncheckedCreateWithoutProductInput>
  }

  export type CrossReferenceUpdateWithWhereUniqueWithoutProductInput = {
    where: CrossReferenceWhereUniqueInput
    data: XOR<CrossReferenceUpdateWithoutProductInput, CrossReferenceUncheckedUpdateWithoutProductInput>
  }

  export type CrossReferenceUpdateManyWithWhereWithoutProductInput = {
    where: CrossReferenceScalarWhereInput
    data: XOR<CrossReferenceUpdateManyMutationInput, CrossReferenceUncheckedUpdateManyWithoutProductInput>
  }

  export type CrossReferenceScalarWhereInput = {
    AND?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
    OR?: CrossReferenceScalarWhereInput[]
    NOT?: CrossReferenceScalarWhereInput | CrossReferenceScalarWhereInput[]
    id?: StringFilter<"CrossReference"> | string
    productId?: StringFilter<"CrossReference"> | string
    crossPartNumber?: StringFilter<"CrossReference"> | string
    crossBrandId?: StringFilter<"CrossReference"> | string
    crossType?: EnumCrossTypeFilter<"CrossReference"> | $Enums.CrossType
    confidenceScore?: DecimalFilter<"CrossReference"> | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFilter<"CrossReference"> | boolean
  }

  export type CartItemUpsertWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
    create: XOR<CartItemCreateWithoutProductInput, CartItemUncheckedCreateWithoutProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutProductInput, CartItemUncheckedUpdateWithoutProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutProductInput>
  }

  export type CartItemScalarWhereInput = {
    AND?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    OR?: CartItemScalarWhereInput[]
    NOT?: CartItemScalarWhereInput | CartItemScalarWhereInput[]
    id?: StringFilter<"CartItem"> | string
    cartId?: StringFilter<"CartItem"> | string
    productId?: StringNullableFilter<"CartItem"> | string | null
    chatProductId?: StringNullableFilter<"CartItem"> | string | null
    quantity?: IntFilter<"CartItem"> | number
    price?: DecimalFilter<"CartItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"CartItem"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    productId?: StringNullableFilter<"OrderItem"> | string | null
    chatProductId?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    price?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutProductInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutProductInput, FavoriteUncheckedUpdateWithoutProductInput>
    create: XOR<FavoriteCreateWithoutProductInput, FavoriteUncheckedCreateWithoutProductInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutProductInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutProductInput, FavoriteUncheckedUpdateWithoutProductInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutProductInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutProductInput>
  }

  export type ViewHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ViewHistoryWhereUniqueInput
    update: XOR<ViewHistoryUpdateWithoutProductInput, ViewHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<ViewHistoryCreateWithoutProductInput, ViewHistoryUncheckedCreateWithoutProductInput>
  }

  export type ViewHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ViewHistoryWhereUniqueInput
    data: XOR<ViewHistoryUpdateWithoutProductInput, ViewHistoryUncheckedUpdateWithoutProductInput>
  }

  export type ViewHistoryUpdateManyWithWhereWithoutProductInput = {
    where: ViewHistoryScalarWhereInput
    data: XOR<ViewHistoryUpdateManyMutationInput, ViewHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    characteristics?: CharacteristicCategoryCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    characteristics?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutCategoriesInput = {
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    characteristics?: CharacteristicCategoryUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    characteristics?: CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ProductCreateWithoutImagesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutBrandInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type CrossReferenceCreateWithoutCrossBrandInput = {
    id?: string
    crossPartNumber: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
    product: ProductCreateNestedOneWithoutCrossReferencesInput
  }

  export type CrossReferenceUncheckedCreateWithoutCrossBrandInput = {
    id?: string
    productId: string
    crossPartNumber: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type CrossReferenceCreateOrConnectWithoutCrossBrandInput = {
    where: CrossReferenceWhereUniqueInput
    create: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput>
  }

  export type CrossReferenceCreateManyCrossBrandInputEnvelope = {
    data: CrossReferenceCreateManyCrossBrandInput | CrossReferenceCreateManyCrossBrandInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    shortDescription?: StringNullableFilter<"Product"> | string | null
    sku?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    stock?: IntFilter<"Product"> | number
    deliveryDays?: IntNullableFilter<"Product"> | number | null
    brandId?: StringFilter<"Product"> | string
    isOriginal?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDescription?: StringNullableFilter<"Product"> | string | null
    metaKeywords?: StringNullableFilter<"Product"> | string | null
  }

  export type CrossReferenceUpsertWithWhereUniqueWithoutCrossBrandInput = {
    where: CrossReferenceWhereUniqueInput
    update: XOR<CrossReferenceUpdateWithoutCrossBrandInput, CrossReferenceUncheckedUpdateWithoutCrossBrandInput>
    create: XOR<CrossReferenceCreateWithoutCrossBrandInput, CrossReferenceUncheckedCreateWithoutCrossBrandInput>
  }

  export type CrossReferenceUpdateWithWhereUniqueWithoutCrossBrandInput = {
    where: CrossReferenceWhereUniqueInput
    data: XOR<CrossReferenceUpdateWithoutCrossBrandInput, CrossReferenceUncheckedUpdateWithoutCrossBrandInput>
  }

  export type CrossReferenceUpdateManyWithWhereWithoutCrossBrandInput = {
    where: CrossReferenceScalarWhereInput
    data: XOR<CrossReferenceUpdateManyMutationInput, CrossReferenceUncheckedUpdateManyWithoutCrossBrandInput>
  }

  export type CharacteristicValueCreateWithoutCharacteristicInput = {
    id?: string
    value: string
    sortOrder?: number
    productValues?: ProductCharacteristicCreateNestedManyWithoutCharacteristicValueInput
  }

  export type CharacteristicValueUncheckedCreateWithoutCharacteristicInput = {
    id?: string
    value: string
    sortOrder?: number
    productValues?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicValueInput
  }

  export type CharacteristicValueCreateOrConnectWithoutCharacteristicInput = {
    where: CharacteristicValueWhereUniqueInput
    create: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicValueCreateManyCharacteristicInputEnvelope = {
    data: CharacteristicValueCreateManyCharacteristicInput | CharacteristicValueCreateManyCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type ProductCharacteristicCreateWithoutCharacteristicInput = {
    id?: string
    value?: string | null
    product: ProductCreateNestedOneWithoutCharacteristicsInput
    characteristicValue?: CharacteristicValueCreateNestedOneWithoutProductValuesInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutCharacteristicInput = {
    id?: string
    productId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type ProductCharacteristicCreateOrConnectWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicCreateManyCharacteristicInputEnvelope = {
    data: ProductCharacteristicCreateManyCharacteristicInput | ProductCharacteristicCreateManyCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type CharacteristicCategoryCreateWithoutCharacteristicInput = {
    id?: string
    category: CategoryCreateNestedOneWithoutCharacteristicsInput
  }

  export type CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput = {
    id?: string
    categoryId: string
  }

  export type CharacteristicCategoryCreateOrConnectWithoutCharacteristicInput = {
    where: CharacteristicCategoryWhereUniqueInput
    create: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicCategoryCreateManyCharacteristicInputEnvelope = {
    data: CharacteristicCategoryCreateManyCharacteristicInput | CharacteristicCategoryCreateManyCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type CharacteristicValueUpsertWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicValueWhereUniqueInput
    update: XOR<CharacteristicValueUpdateWithoutCharacteristicInput, CharacteristicValueUncheckedUpdateWithoutCharacteristicInput>
    create: XOR<CharacteristicValueCreateWithoutCharacteristicInput, CharacteristicValueUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicValueUpdateWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicValueWhereUniqueInput
    data: XOR<CharacteristicValueUpdateWithoutCharacteristicInput, CharacteristicValueUncheckedUpdateWithoutCharacteristicInput>
  }

  export type CharacteristicValueUpdateManyWithWhereWithoutCharacteristicInput = {
    where: CharacteristicValueScalarWhereInput
    data: XOR<CharacteristicValueUpdateManyMutationInput, CharacteristicValueUncheckedUpdateManyWithoutCharacteristicInput>
  }

  export type CharacteristicValueScalarWhereInput = {
    AND?: CharacteristicValueScalarWhereInput | CharacteristicValueScalarWhereInput[]
    OR?: CharacteristicValueScalarWhereInput[]
    NOT?: CharacteristicValueScalarWhereInput | CharacteristicValueScalarWhereInput[]
    id?: StringFilter<"CharacteristicValue"> | string
    characteristicId?: StringFilter<"CharacteristicValue"> | string
    value?: StringFilter<"CharacteristicValue"> | string
    sortOrder?: IntFilter<"CharacteristicValue"> | number
  }

  export type ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    update: XOR<ProductCharacteristicUpdateWithoutCharacteristicInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput>
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    data: XOR<ProductCharacteristicUpdateWithoutCharacteristicInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput = {
    where: ProductCharacteristicScalarWhereInput
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicInput>
  }

  export type CharacteristicCategoryUpsertWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicCategoryWhereUniqueInput
    update: XOR<CharacteristicCategoryUpdateWithoutCharacteristicInput, CharacteristicCategoryUncheckedUpdateWithoutCharacteristicInput>
    create: XOR<CharacteristicCategoryCreateWithoutCharacteristicInput, CharacteristicCategoryUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicCategoryUpdateWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicCategoryWhereUniqueInput
    data: XOR<CharacteristicCategoryUpdateWithoutCharacteristicInput, CharacteristicCategoryUncheckedUpdateWithoutCharacteristicInput>
  }

  export type CharacteristicCategoryUpdateManyWithWhereWithoutCharacteristicInput = {
    where: CharacteristicCategoryScalarWhereInput
    data: XOR<CharacteristicCategoryUpdateManyMutationInput, CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicInput>
  }

  export type CharacteristicCreateWithoutCategoriesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueCreateNestedManyWithoutCharacteristicInput
    productValues?: ProductCharacteristicCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateWithoutCategoriesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueUncheckedCreateNestedManyWithoutCharacteristicInput
    productValues?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicCreateOrConnectWithoutCategoriesInput = {
    where: CharacteristicWhereUniqueInput
    create: XOR<CharacteristicCreateWithoutCategoriesInput, CharacteristicUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutCharacteristicsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutCharacteristicsInput, CategoryUncheckedCreateWithoutCharacteristicsInput>
  }

  export type CharacteristicUpsertWithoutCategoriesInput = {
    update: XOR<CharacteristicUpdateWithoutCategoriesInput, CharacteristicUncheckedUpdateWithoutCategoriesInput>
    create: XOR<CharacteristicCreateWithoutCategoriesInput, CharacteristicUncheckedCreateWithoutCategoriesInput>
    where?: CharacteristicWhereInput
  }

  export type CharacteristicUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: CharacteristicWhereInput
    data: XOR<CharacteristicUpdateWithoutCategoriesInput, CharacteristicUncheckedUpdateWithoutCategoriesInput>
  }

  export type CharacteristicUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUpdateManyWithoutCharacteristicNestedInput
    productValues?: ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUncheckedUpdateManyWithoutCharacteristicNestedInput
    productValues?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type CategoryUpsertWithoutCharacteristicsInput = {
    update: XOR<CategoryUpdateWithoutCharacteristicsInput, CategoryUncheckedUpdateWithoutCharacteristicsInput>
    create: XOR<CategoryCreateWithoutCharacteristicsInput, CategoryUncheckedCreateWithoutCharacteristicsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutCharacteristicsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutCharacteristicsInput, CategoryUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type CategoryUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CharacteristicCreateWithoutValuesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    productValues?: ProductCharacteristicCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateWithoutValuesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    productValues?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicCreateOrConnectWithoutValuesInput = {
    where: CharacteristicWhereUniqueInput
    create: XOR<CharacteristicCreateWithoutValuesInput, CharacteristicUncheckedCreateWithoutValuesInput>
  }

  export type ProductCharacteristicCreateWithoutCharacteristicValueInput = {
    id?: string
    value?: string | null
    product: ProductCreateNestedOneWithoutCharacteristicsInput
    characteristic: CharacteristicCreateNestedOneWithoutProductValuesInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput = {
    id?: string
    productId: string
    characteristicId: string
    value?: string | null
  }

  export type ProductCharacteristicCreateOrConnectWithoutCharacteristicValueInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput>
  }

  export type ProductCharacteristicCreateManyCharacteristicValueInputEnvelope = {
    data: ProductCharacteristicCreateManyCharacteristicValueInput | ProductCharacteristicCreateManyCharacteristicValueInput[]
    skipDuplicates?: boolean
  }

  export type CharacteristicUpsertWithoutValuesInput = {
    update: XOR<CharacteristicUpdateWithoutValuesInput, CharacteristicUncheckedUpdateWithoutValuesInput>
    create: XOR<CharacteristicCreateWithoutValuesInput, CharacteristicUncheckedCreateWithoutValuesInput>
    where?: CharacteristicWhereInput
  }

  export type CharacteristicUpdateToOneWithWhereWithoutValuesInput = {
    where?: CharacteristicWhereInput
    data: XOR<CharacteristicUpdateWithoutValuesInput, CharacteristicUncheckedUpdateWithoutValuesInput>
  }

  export type CharacteristicUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productValues?: ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productValues?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicValueInput = {
    where: ProductCharacteristicWhereUniqueInput
    update: XOR<ProductCharacteristicUpdateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicValueInput>
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicValueInput>
  }

  export type ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicValueInput = {
    where: ProductCharacteristicWhereUniqueInput
    data: XOR<ProductCharacteristicUpdateWithoutCharacteristicValueInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicValueInput>
  }

  export type ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicValueInput = {
    where: ProductCharacteristicScalarWhereInput
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicValueInput>
  }

  export type ProductCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCharacteristicsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCharacteristicsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCharacteristicsInput, ProductUncheckedCreateWithoutCharacteristicsInput>
  }

  export type CharacteristicCreateWithoutProductValuesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateWithoutProductValuesInput = {
    id?: string
    name: string
    code: string
    type: string
    unit?: string | null
    isRequired?: boolean
    isFilterable?: boolean
    filterType?: string | null
    sortOrder?: number
    createdAt?: Date | string
    values?: CharacteristicValueUncheckedCreateNestedManyWithoutCharacteristicInput
    categories?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicCreateOrConnectWithoutProductValuesInput = {
    where: CharacteristicWhereUniqueInput
    create: XOR<CharacteristicCreateWithoutProductValuesInput, CharacteristicUncheckedCreateWithoutProductValuesInput>
  }

  export type CharacteristicValueCreateWithoutProductValuesInput = {
    id?: string
    value: string
    sortOrder?: number
    characteristic: CharacteristicCreateNestedOneWithoutValuesInput
  }

  export type CharacteristicValueUncheckedCreateWithoutProductValuesInput = {
    id?: string
    characteristicId: string
    value: string
    sortOrder?: number
  }

  export type CharacteristicValueCreateOrConnectWithoutProductValuesInput = {
    where: CharacteristicValueWhereUniqueInput
    create: XOR<CharacteristicValueCreateWithoutProductValuesInput, CharacteristicValueUncheckedCreateWithoutProductValuesInput>
  }

  export type ProductUpsertWithoutCharacteristicsInput = {
    update: XOR<ProductUpdateWithoutCharacteristicsInput, ProductUncheckedUpdateWithoutCharacteristicsInput>
    create: XOR<ProductCreateWithoutCharacteristicsInput, ProductUncheckedCreateWithoutCharacteristicsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCharacteristicsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCharacteristicsInput, ProductUncheckedUpdateWithoutCharacteristicsInput>
  }

  export type ProductUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CharacteristicUpsertWithoutProductValuesInput = {
    update: XOR<CharacteristicUpdateWithoutProductValuesInput, CharacteristicUncheckedUpdateWithoutProductValuesInput>
    create: XOR<CharacteristicCreateWithoutProductValuesInput, CharacteristicUncheckedCreateWithoutProductValuesInput>
    where?: CharacteristicWhereInput
  }

  export type CharacteristicUpdateToOneWithWhereWithoutProductValuesInput = {
    where?: CharacteristicWhereInput
    data: XOR<CharacteristicUpdateWithoutProductValuesInput, CharacteristicUncheckedUpdateWithoutProductValuesInput>
  }

  export type CharacteristicUpdateWithoutProductValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateWithoutProductValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isFilterable?: BoolFieldUpdateOperationsInput | boolean
    filterType?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    values?: CharacteristicValueUncheckedUpdateManyWithoutCharacteristicNestedInput
    categories?: CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicValueUpsertWithoutProductValuesInput = {
    update: XOR<CharacteristicValueUpdateWithoutProductValuesInput, CharacteristicValueUncheckedUpdateWithoutProductValuesInput>
    create: XOR<CharacteristicValueCreateWithoutProductValuesInput, CharacteristicValueUncheckedCreateWithoutProductValuesInput>
    where?: CharacteristicValueWhereInput
  }

  export type CharacteristicValueUpdateToOneWithWhereWithoutProductValuesInput = {
    where?: CharacteristicValueWhereInput
    data: XOR<CharacteristicValueUpdateWithoutProductValuesInput, CharacteristicValueUncheckedUpdateWithoutProductValuesInput>
  }

  export type CharacteristicValueUpdateWithoutProductValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    characteristic?: CharacteristicUpdateOneRequiredWithoutValuesNestedInput
  }

  export type CharacteristicValueUncheckedUpdateWithoutProductValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleModelCreateWithoutMakeInput = {
    id?: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    generations?: VehicleGenerationCreateNestedManyWithoutModelInput
  }

  export type VehicleModelUncheckedCreateWithoutMakeInput = {
    id?: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    generations?: VehicleGenerationUncheckedCreateNestedManyWithoutModelInput
  }

  export type VehicleModelCreateOrConnectWithoutMakeInput = {
    where: VehicleModelWhereUniqueInput
    create: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput>
  }

  export type VehicleModelCreateManyMakeInputEnvelope = {
    data: VehicleModelCreateManyMakeInput | VehicleModelCreateManyMakeInput[]
    skipDuplicates?: boolean
  }

  export type VehicleModelUpsertWithWhereUniqueWithoutMakeInput = {
    where: VehicleModelWhereUniqueInput
    update: XOR<VehicleModelUpdateWithoutMakeInput, VehicleModelUncheckedUpdateWithoutMakeInput>
    create: XOR<VehicleModelCreateWithoutMakeInput, VehicleModelUncheckedCreateWithoutMakeInput>
  }

  export type VehicleModelUpdateWithWhereUniqueWithoutMakeInput = {
    where: VehicleModelWhereUniqueInput
    data: XOR<VehicleModelUpdateWithoutMakeInput, VehicleModelUncheckedUpdateWithoutMakeInput>
  }

  export type VehicleModelUpdateManyWithWhereWithoutMakeInput = {
    where: VehicleModelScalarWhereInput
    data: XOR<VehicleModelUpdateManyMutationInput, VehicleModelUncheckedUpdateManyWithoutMakeInput>
  }

  export type VehicleModelScalarWhereInput = {
    AND?: VehicleModelScalarWhereInput | VehicleModelScalarWhereInput[]
    OR?: VehicleModelScalarWhereInput[]
    NOT?: VehicleModelScalarWhereInput | VehicleModelScalarWhereInput[]
    id?: StringFilter<"VehicleModel"> | string
    makeId?: StringFilter<"VehicleModel"> | string
    name?: StringFilter<"VehicleModel"> | string
    slug?: StringFilter<"VehicleModel"> | string
    modelCode?: StringNullableFilter<"VehicleModel"> | string | null
    startYear?: IntFilter<"VehicleModel"> | number
    endYear?: IntNullableFilter<"VehicleModel"> | number | null
    description?: StringNullableFilter<"VehicleModel"> | string | null
    metaTitle?: StringNullableFilter<"VehicleModel"> | string | null
    metaDescription?: StringNullableFilter<"VehicleModel"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleModel"> | string | null
  }

  export type VehicleMakeCreateWithoutModelsInput = {
    id?: string
    name: string
    slug: string
    country?: string | null
    logoUrl?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleMakeUncheckedCreateWithoutModelsInput = {
    id?: string
    name: string
    slug: string
    country?: string | null
    logoUrl?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleMakeCreateOrConnectWithoutModelsInput = {
    where: VehicleMakeWhereUniqueInput
    create: XOR<VehicleMakeCreateWithoutModelsInput, VehicleMakeUncheckedCreateWithoutModelsInput>
  }

  export type VehicleGenerationCreateWithoutModelInput = {
    id?: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    modifications?: VehicleModificationCreateNestedManyWithoutGenerationInput
  }

  export type VehicleGenerationUncheckedCreateWithoutModelInput = {
    id?: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    modifications?: VehicleModificationUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type VehicleGenerationCreateOrConnectWithoutModelInput = {
    where: VehicleGenerationWhereUniqueInput
    create: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput>
  }

  export type VehicleGenerationCreateManyModelInputEnvelope = {
    data: VehicleGenerationCreateManyModelInput | VehicleGenerationCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type VehicleMakeUpsertWithoutModelsInput = {
    update: XOR<VehicleMakeUpdateWithoutModelsInput, VehicleMakeUncheckedUpdateWithoutModelsInput>
    create: XOR<VehicleMakeCreateWithoutModelsInput, VehicleMakeUncheckedCreateWithoutModelsInput>
    where?: VehicleMakeWhereInput
  }

  export type VehicleMakeUpdateToOneWithWhereWithoutModelsInput = {
    where?: VehicleMakeWhereInput
    data: XOR<VehicleMakeUpdateWithoutModelsInput, VehicleMakeUncheckedUpdateWithoutModelsInput>
  }

  export type VehicleMakeUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleMakeUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleGenerationUpsertWithWhereUniqueWithoutModelInput = {
    where: VehicleGenerationWhereUniqueInput
    update: XOR<VehicleGenerationUpdateWithoutModelInput, VehicleGenerationUncheckedUpdateWithoutModelInput>
    create: XOR<VehicleGenerationCreateWithoutModelInput, VehicleGenerationUncheckedCreateWithoutModelInput>
  }

  export type VehicleGenerationUpdateWithWhereUniqueWithoutModelInput = {
    where: VehicleGenerationWhereUniqueInput
    data: XOR<VehicleGenerationUpdateWithoutModelInput, VehicleGenerationUncheckedUpdateWithoutModelInput>
  }

  export type VehicleGenerationUpdateManyWithWhereWithoutModelInput = {
    where: VehicleGenerationScalarWhereInput
    data: XOR<VehicleGenerationUpdateManyMutationInput, VehicleGenerationUncheckedUpdateManyWithoutModelInput>
  }

  export type VehicleGenerationScalarWhereInput = {
    AND?: VehicleGenerationScalarWhereInput | VehicleGenerationScalarWhereInput[]
    OR?: VehicleGenerationScalarWhereInput[]
    NOT?: VehicleGenerationScalarWhereInput | VehicleGenerationScalarWhereInput[]
    id?: StringFilter<"VehicleGeneration"> | string
    modelId?: StringFilter<"VehicleGeneration"> | string
    name?: StringFilter<"VehicleGeneration"> | string
    slug?: StringFilter<"VehicleGeneration"> | string
    startYear?: IntFilter<"VehicleGeneration"> | number
    endYear?: IntNullableFilter<"VehicleGeneration"> | number | null
    bodyType?: StringNullableFilter<"VehicleGeneration"> | string | null
    description?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaTitle?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaDescription?: StringNullableFilter<"VehicleGeneration"> | string | null
    metaKeywords?: StringNullableFilter<"VehicleGeneration"> | string | null
  }

  export type VehicleModelCreateWithoutGenerationsInput = {
    id?: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    make: VehicleMakeCreateNestedOneWithoutModelsInput
  }

  export type VehicleModelUncheckedCreateWithoutGenerationsInput = {
    id?: string
    makeId: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleModelCreateOrConnectWithoutGenerationsInput = {
    where: VehicleModelWhereUniqueInput
    create: XOR<VehicleModelCreateWithoutGenerationsInput, VehicleModelUncheckedCreateWithoutGenerationsInput>
  }

  export type VehicleModificationCreateWithoutGenerationInput = {
    id?: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
    applications?: VehicleApplicationCreateNestedManyWithoutModificationInput
  }

  export type VehicleModificationUncheckedCreateWithoutGenerationInput = {
    id?: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
    applications?: VehicleApplicationUncheckedCreateNestedManyWithoutModificationInput
  }

  export type VehicleModificationCreateOrConnectWithoutGenerationInput = {
    where: VehicleModificationWhereUniqueInput
    create: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput>
  }

  export type VehicleModificationCreateManyGenerationInputEnvelope = {
    data: VehicleModificationCreateManyGenerationInput | VehicleModificationCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type VehicleModelUpsertWithoutGenerationsInput = {
    update: XOR<VehicleModelUpdateWithoutGenerationsInput, VehicleModelUncheckedUpdateWithoutGenerationsInput>
    create: XOR<VehicleModelCreateWithoutGenerationsInput, VehicleModelUncheckedCreateWithoutGenerationsInput>
    where?: VehicleModelWhereInput
  }

  export type VehicleModelUpdateToOneWithWhereWithoutGenerationsInput = {
    where?: VehicleModelWhereInput
    data: XOR<VehicleModelUpdateWithoutGenerationsInput, VehicleModelUncheckedUpdateWithoutGenerationsInput>
  }

  export type VehicleModelUpdateWithoutGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    make?: VehicleMakeUpdateOneRequiredWithoutModelsNestedInput
  }

  export type VehicleModelUncheckedUpdateWithoutGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    makeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModificationUpsertWithWhereUniqueWithoutGenerationInput = {
    where: VehicleModificationWhereUniqueInput
    update: XOR<VehicleModificationUpdateWithoutGenerationInput, VehicleModificationUncheckedUpdateWithoutGenerationInput>
    create: XOR<VehicleModificationCreateWithoutGenerationInput, VehicleModificationUncheckedCreateWithoutGenerationInput>
  }

  export type VehicleModificationUpdateWithWhereUniqueWithoutGenerationInput = {
    where: VehicleModificationWhereUniqueInput
    data: XOR<VehicleModificationUpdateWithoutGenerationInput, VehicleModificationUncheckedUpdateWithoutGenerationInput>
  }

  export type VehicleModificationUpdateManyWithWhereWithoutGenerationInput = {
    where: VehicleModificationScalarWhereInput
    data: XOR<VehicleModificationUpdateManyMutationInput, VehicleModificationUncheckedUpdateManyWithoutGenerationInput>
  }

  export type VehicleModificationScalarWhereInput = {
    AND?: VehicleModificationScalarWhereInput | VehicleModificationScalarWhereInput[]
    OR?: VehicleModificationScalarWhereInput[]
    NOT?: VehicleModificationScalarWhereInput | VehicleModificationScalarWhereInput[]
    id?: StringFilter<"VehicleModification"> | string
    generationId?: StringFilter<"VehicleModification"> | string
    name?: StringFilter<"VehicleModification"> | string
    engineCode?: StringNullableFilter<"VehicleModification"> | string | null
    fuelType?: StringNullableFilter<"VehicleModification"> | string | null
    powerHp?: IntNullableFilter<"VehicleModification"> | number | null
    transmission?: StringNullableFilter<"VehicleModification"> | string | null
  }

  export type VehicleGenerationCreateWithoutModificationsInput = {
    id?: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    model: VehicleModelCreateNestedOneWithoutGenerationsInput
  }

  export type VehicleGenerationUncheckedCreateWithoutModificationsInput = {
    id?: string
    modelId: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleGenerationCreateOrConnectWithoutModificationsInput = {
    where: VehicleGenerationWhereUniqueInput
    create: XOR<VehicleGenerationCreateWithoutModificationsInput, VehicleGenerationUncheckedCreateWithoutModificationsInput>
  }

  export type VehicleApplicationCreateWithoutModificationInput = {
    id?: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
    product: ProductCreateNestedOneWithoutVehicleApplicationsInput
  }

  export type VehicleApplicationUncheckedCreateWithoutModificationInput = {
    id?: string
    productId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type VehicleApplicationCreateOrConnectWithoutModificationInput = {
    where: VehicleApplicationWhereUniqueInput
    create: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput>
  }

  export type VehicleApplicationCreateManyModificationInputEnvelope = {
    data: VehicleApplicationCreateManyModificationInput | VehicleApplicationCreateManyModificationInput[]
    skipDuplicates?: boolean
  }

  export type VehicleGenerationUpsertWithoutModificationsInput = {
    update: XOR<VehicleGenerationUpdateWithoutModificationsInput, VehicleGenerationUncheckedUpdateWithoutModificationsInput>
    create: XOR<VehicleGenerationCreateWithoutModificationsInput, VehicleGenerationUncheckedCreateWithoutModificationsInput>
    where?: VehicleGenerationWhereInput
  }

  export type VehicleGenerationUpdateToOneWithWhereWithoutModificationsInput = {
    where?: VehicleGenerationWhereInput
    data: XOR<VehicleGenerationUpdateWithoutModificationsInput, VehicleGenerationUncheckedUpdateWithoutModificationsInput>
  }

  export type VehicleGenerationUpdateWithoutModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    model?: VehicleModelUpdateOneRequiredWithoutGenerationsNestedInput
  }

  export type VehicleGenerationUncheckedUpdateWithoutModificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleApplicationUpsertWithWhereUniqueWithoutModificationInput = {
    where: VehicleApplicationWhereUniqueInput
    update: XOR<VehicleApplicationUpdateWithoutModificationInput, VehicleApplicationUncheckedUpdateWithoutModificationInput>
    create: XOR<VehicleApplicationCreateWithoutModificationInput, VehicleApplicationUncheckedCreateWithoutModificationInput>
  }

  export type VehicleApplicationUpdateWithWhereUniqueWithoutModificationInput = {
    where: VehicleApplicationWhereUniqueInput
    data: XOR<VehicleApplicationUpdateWithoutModificationInput, VehicleApplicationUncheckedUpdateWithoutModificationInput>
  }

  export type VehicleApplicationUpdateManyWithWhereWithoutModificationInput = {
    where: VehicleApplicationScalarWhereInput
    data: XOR<VehicleApplicationUpdateManyMutationInput, VehicleApplicationUncheckedUpdateManyWithoutModificationInput>
  }

  export type ProductCreateWithoutVehicleApplicationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVehicleApplicationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVehicleApplicationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVehicleApplicationsInput, ProductUncheckedCreateWithoutVehicleApplicationsInput>
  }

  export type VehicleModificationCreateWithoutApplicationsInput = {
    id?: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
    generation: VehicleGenerationCreateNestedOneWithoutModificationsInput
  }

  export type VehicleModificationUncheckedCreateWithoutApplicationsInput = {
    id?: string
    generationId: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
  }

  export type VehicleModificationCreateOrConnectWithoutApplicationsInput = {
    where: VehicleModificationWhereUniqueInput
    create: XOR<VehicleModificationCreateWithoutApplicationsInput, VehicleModificationUncheckedCreateWithoutApplicationsInput>
  }

  export type ProductUpsertWithoutVehicleApplicationsInput = {
    update: XOR<ProductUpdateWithoutVehicleApplicationsInput, ProductUncheckedUpdateWithoutVehicleApplicationsInput>
    create: XOR<ProductCreateWithoutVehicleApplicationsInput, ProductUncheckedCreateWithoutVehicleApplicationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVehicleApplicationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVehicleApplicationsInput, ProductUncheckedUpdateWithoutVehicleApplicationsInput>
  }

  export type ProductUpdateWithoutVehicleApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVehicleApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type VehicleModificationUpsertWithoutApplicationsInput = {
    update: XOR<VehicleModificationUpdateWithoutApplicationsInput, VehicleModificationUncheckedUpdateWithoutApplicationsInput>
    create: XOR<VehicleModificationCreateWithoutApplicationsInput, VehicleModificationUncheckedCreateWithoutApplicationsInput>
    where?: VehicleModificationWhereInput
  }

  export type VehicleModificationUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: VehicleModificationWhereInput
    data: XOR<VehicleModificationUpdateWithoutApplicationsInput, VehicleModificationUncheckedUpdateWithoutApplicationsInput>
  }

  export type VehicleModificationUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: VehicleGenerationUpdateOneRequiredWithoutModificationsNestedInput
  }

  export type VehicleModificationUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    generationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCreateWithoutCrossReferencesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCrossReferencesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCrossReferencesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCrossReferencesInput, ProductUncheckedCreateWithoutCrossReferencesInput>
  }

  export type BrandCreateWithoutCrossReferencesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutCrossReferencesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    description?: string | null
    country?: string | null
    isActive?: boolean
    createdAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutCrossReferencesInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutCrossReferencesInput, BrandUncheckedCreateWithoutCrossReferencesInput>
  }

  export type ProductUpsertWithoutCrossReferencesInput = {
    update: XOR<ProductUpdateWithoutCrossReferencesInput, ProductUncheckedUpdateWithoutCrossReferencesInput>
    create: XOR<ProductCreateWithoutCrossReferencesInput, ProductUncheckedCreateWithoutCrossReferencesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCrossReferencesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCrossReferencesInput, ProductUncheckedUpdateWithoutCrossReferencesInput>
  }

  export type ProductUpdateWithoutCrossReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCrossReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BrandUpsertWithoutCrossReferencesInput = {
    update: XOR<BrandUpdateWithoutCrossReferencesInput, BrandUncheckedUpdateWithoutCrossReferencesInput>
    create: XOR<BrandCreateWithoutCrossReferencesInput, BrandUncheckedCreateWithoutCrossReferencesInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutCrossReferencesInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutCrossReferencesInput, BrandUncheckedUpdateWithoutCrossReferencesInput>
  }

  export type BrandUpdateWithoutCrossReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutCrossReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type ProductCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFavoritesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFavoritesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFavoritesInput, ProductUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductUpsertWithoutFavoritesInput = {
    update: XOR<ProductUpdateWithoutFavoritesInput, ProductUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ProductCreateWithoutFavoritesInput, ProductUncheckedCreateWithoutFavoritesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFavoritesInput, ProductUncheckedUpdateWithoutFavoritesInput>
  }

  export type ProductUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutViewHistoryInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViewHistoryInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViewHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewHistoryInput, UserUncheckedCreateWithoutViewHistoryInput>
  }

  export type AnonymousUserCreateWithoutViewHistoryInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartCreateNestedManyWithoutAnonymousUserInput
    chats?: ChatCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserUncheckedCreateWithoutViewHistoryInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutAnonymousUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserCreateOrConnectWithoutViewHistoryInput = {
    where: AnonymousUserWhereUniqueInput
    create: XOR<AnonymousUserCreateWithoutViewHistoryInput, AnonymousUserUncheckedCreateWithoutViewHistoryInput>
  }

  export type ProductCreateWithoutViewHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutViewHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutViewHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutViewHistoryInput, ProductUncheckedCreateWithoutViewHistoryInput>
  }

  export type CategoryCreateWithoutViewHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutViewHistoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    parentId?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    characteristics?: CharacteristicCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutViewHistoryInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutViewHistoryInput, CategoryUncheckedCreateWithoutViewHistoryInput>
  }

  export type UserUpsertWithoutViewHistoryInput = {
    update: XOR<UserUpdateWithoutViewHistoryInput, UserUncheckedUpdateWithoutViewHistoryInput>
    create: XOR<UserCreateWithoutViewHistoryInput, UserUncheckedCreateWithoutViewHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewHistoryInput, UserUncheckedUpdateWithoutViewHistoryInput>
  }

  export type UserUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnonymousUserUpsertWithoutViewHistoryInput = {
    update: XOR<AnonymousUserUpdateWithoutViewHistoryInput, AnonymousUserUncheckedUpdateWithoutViewHistoryInput>
    create: XOR<AnonymousUserCreateWithoutViewHistoryInput, AnonymousUserUncheckedCreateWithoutViewHistoryInput>
    where?: AnonymousUserWhereInput
  }

  export type AnonymousUserUpdateToOneWithWhereWithoutViewHistoryInput = {
    where?: AnonymousUserWhereInput
    data: XOR<AnonymousUserUpdateWithoutViewHistoryInput, AnonymousUserUncheckedUpdateWithoutViewHistoryInput>
  }

  export type AnonymousUserUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutAnonymousUserNestedInput
    chats?: ChatUpdateManyWithoutAnonymousUserNestedInput
  }

  export type AnonymousUserUncheckedUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutAnonymousUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutAnonymousUserNestedInput
  }

  export type ProductUpsertWithoutViewHistoryInput = {
    update: XOR<ProductUpdateWithoutViewHistoryInput, ProductUncheckedUpdateWithoutViewHistoryInput>
    create: XOR<ProductCreateWithoutViewHistoryInput, ProductUncheckedCreateWithoutViewHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutViewHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutViewHistoryInput, ProductUncheckedUpdateWithoutViewHistoryInput>
  }

  export type ProductUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryUpsertWithoutViewHistoryInput = {
    update: XOR<CategoryUpdateWithoutViewHistoryInput, CategoryUncheckedUpdateWithoutViewHistoryInput>
    create: XOR<CategoryCreateWithoutViewHistoryInput, CategoryUncheckedCreateWithoutViewHistoryInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutViewHistoryInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutViewHistoryInput, CategoryUncheckedUpdateWithoutViewHistoryInput>
  }

  export type CategoryUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutViewHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserCreateWithoutCartsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCartsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCartsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
  }

  export type AnonymousUserCreateWithoutCartsInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    chats?: ChatCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserUncheckedCreateWithoutCartsInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserCreateOrConnectWithoutCartsInput = {
    where: AnonymousUserWhereUniqueInput
    create: XOR<AnonymousUserCreateWithoutCartsInput, AnonymousUserUncheckedCreateWithoutCartsInput>
  }

  export type CartItemCreateWithoutCartInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    product?: ProductCreateNestedOneWithoutCartItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutCartInput = {
    id?: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutCartInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemCreateManyCartInputEnvelope = {
    data: CartItemCreateManyCartInput | CartItemCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCartsInput = {
    update: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
    create: XOR<UserCreateWithoutCartsInput, UserUncheckedCreateWithoutCartsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCartsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCartsInput, UserUncheckedUpdateWithoutCartsInput>
  }

  export type UserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnonymousUserUpsertWithoutCartsInput = {
    update: XOR<AnonymousUserUpdateWithoutCartsInput, AnonymousUserUncheckedUpdateWithoutCartsInput>
    create: XOR<AnonymousUserCreateWithoutCartsInput, AnonymousUserUncheckedCreateWithoutCartsInput>
    where?: AnonymousUserWhereInput
  }

  export type AnonymousUserUpdateToOneWithWhereWithoutCartsInput = {
    where?: AnonymousUserWhereInput
    data: XOR<AnonymousUserUpdateWithoutCartsInput, AnonymousUserUncheckedUpdateWithoutCartsInput>
  }

  export type AnonymousUserUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutAnonymousUserNestedInput
  }

  export type AnonymousUserUncheckedUpdateWithoutCartsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutAnonymousUserNestedInput
  }

  export type CartItemUpsertWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
    create: XOR<CartItemCreateWithoutCartInput, CartItemUncheckedCreateWithoutCartInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutCartInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutCartInput, CartItemUncheckedUpdateWithoutCartInput>
  }

  export type CartItemUpdateManyWithWhereWithoutCartInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutCartInput>
  }

  export type CartCreateWithoutItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutCartsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutCartsInput
  }

  export type CartUncheckedCreateWithoutItemsInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CartCreateOrConnectWithoutItemsInput = {
    where: CartWhereUniqueInput
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutCartItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCartItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
  }

  export type ChatProductCreateWithoutCartItemsInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutChatProductsInput
    images?: ChatProductImageCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUncheckedCreateWithoutCartItemsInput = {
    id?: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    images?: ChatProductImageUncheckedCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductCreateOrConnectWithoutCartItemsInput = {
    where: ChatProductWhereUniqueInput
    create: XOR<ChatProductCreateWithoutCartItemsInput, ChatProductUncheckedCreateWithoutCartItemsInput>
  }

  export type CartUpsertWithoutItemsInput = {
    update: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
    create: XOR<CartCreateWithoutItemsInput, CartUncheckedCreateWithoutItemsInput>
    where?: CartWhereInput
  }

  export type CartUpdateToOneWithWhereWithoutItemsInput = {
    where?: CartWhereInput
    data: XOR<CartUpdateWithoutItemsInput, CartUncheckedUpdateWithoutItemsInput>
  }

  export type CartUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutCartsNestedInput
  }

  export type CartUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutCartItemsInput = {
    update: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ProductCreateWithoutCartItemsInput, ProductUncheckedCreateWithoutCartItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCartItemsInput, ProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ChatProductUpsertWithoutCartItemsInput = {
    update: XOR<ChatProductUpdateWithoutCartItemsInput, ChatProductUncheckedUpdateWithoutCartItemsInput>
    create: XOR<ChatProductCreateWithoutCartItemsInput, ChatProductUncheckedCreateWithoutCartItemsInput>
    where?: ChatProductWhereInput
  }

  export type ChatProductUpdateToOneWithWhereWithoutCartItemsInput = {
    where?: ChatProductWhereInput
    data: XOR<ChatProductUpdateWithoutCartItemsInput, ChatProductUncheckedUpdateWithoutCartItemsInput>
  }

  export type ChatProductUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutChatProductsNestedInput
    images?: ChatProductImageUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateWithoutCartItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ChatProductImageUncheckedUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutChatProductNestedInput
  }

  export type MessageCreateWithoutChatProductsInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatProductsInput = {
    id?: string
    chatId: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatProductsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatProductsInput, MessageUncheckedCreateWithoutChatProductsInput>
  }

  export type ChatProductImageCreateWithoutChatProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ChatProductImageUncheckedCreateWithoutChatProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ChatProductImageCreateOrConnectWithoutChatProductInput = {
    where: ChatProductImageWhereUniqueInput
    create: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput>
  }

  export type ChatProductImageCreateManyChatProductInputEnvelope = {
    data: ChatProductImageCreateManyChatProductInput | ChatProductImageCreateManyChatProductInput[]
    skipDuplicates?: boolean
  }

  export type CartItemCreateWithoutChatProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    cart: CartCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutCartItemsInput
  }

  export type CartItemUncheckedCreateWithoutChatProductInput = {
    id?: string
    cartId: string
    productId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemCreateOrConnectWithoutChatProductInput = {
    where: CartItemWhereUniqueInput
    create: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput>
  }

  export type CartItemCreateManyChatProductInputEnvelope = {
    data: CartItemCreateManyChatProductInput | CartItemCreateManyChatProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutChatProductInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    order: OrderCreateNestedOneWithoutItemsInput
    product?: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutChatProductInput = {
    id?: string
    orderId: string
    productId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemCreateOrConnectWithoutChatProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput>
  }

  export type OrderItemCreateManyChatProductInputEnvelope = {
    data: OrderItemCreateManyChatProductInput | OrderItemCreateManyChatProductInput[]
    skipDuplicates?: boolean
  }

  export type MessageUpsertWithoutChatProductsInput = {
    update: XOR<MessageUpdateWithoutChatProductsInput, MessageUncheckedUpdateWithoutChatProductsInput>
    create: XOR<MessageCreateWithoutChatProductsInput, MessageUncheckedCreateWithoutChatProductsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutChatProductsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutChatProductsInput, MessageUncheckedUpdateWithoutChatProductsInput>
  }

  export type MessageUpdateWithoutChatProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageUpsertWithWhereUniqueWithoutChatProductInput = {
    where: ChatProductImageWhereUniqueInput
    update: XOR<ChatProductImageUpdateWithoutChatProductInput, ChatProductImageUncheckedUpdateWithoutChatProductInput>
    create: XOR<ChatProductImageCreateWithoutChatProductInput, ChatProductImageUncheckedCreateWithoutChatProductInput>
  }

  export type ChatProductImageUpdateWithWhereUniqueWithoutChatProductInput = {
    where: ChatProductImageWhereUniqueInput
    data: XOR<ChatProductImageUpdateWithoutChatProductInput, ChatProductImageUncheckedUpdateWithoutChatProductInput>
  }

  export type ChatProductImageUpdateManyWithWhereWithoutChatProductInput = {
    where: ChatProductImageScalarWhereInput
    data: XOR<ChatProductImageUpdateManyMutationInput, ChatProductImageUncheckedUpdateManyWithoutChatProductInput>
  }

  export type ChatProductImageScalarWhereInput = {
    AND?: ChatProductImageScalarWhereInput | ChatProductImageScalarWhereInput[]
    OR?: ChatProductImageScalarWhereInput[]
    NOT?: ChatProductImageScalarWhereInput | ChatProductImageScalarWhereInput[]
    id?: StringFilter<"ChatProductImage"> | string
    chatProductId?: StringFilter<"ChatProductImage"> | string
    url?: StringFilter<"ChatProductImage"> | string
    alt?: StringNullableFilter<"ChatProductImage"> | string | null
    sortOrder?: IntFilter<"ChatProductImage"> | number
    createdAt?: DateTimeFilter<"ChatProductImage"> | Date | string
  }

  export type CartItemUpsertWithWhereUniqueWithoutChatProductInput = {
    where: CartItemWhereUniqueInput
    update: XOR<CartItemUpdateWithoutChatProductInput, CartItemUncheckedUpdateWithoutChatProductInput>
    create: XOR<CartItemCreateWithoutChatProductInput, CartItemUncheckedCreateWithoutChatProductInput>
  }

  export type CartItemUpdateWithWhereUniqueWithoutChatProductInput = {
    where: CartItemWhereUniqueInput
    data: XOR<CartItemUpdateWithoutChatProductInput, CartItemUncheckedUpdateWithoutChatProductInput>
  }

  export type CartItemUpdateManyWithWhereWithoutChatProductInput = {
    where: CartItemScalarWhereInput
    data: XOR<CartItemUpdateManyMutationInput, CartItemUncheckedUpdateManyWithoutChatProductInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutChatProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutChatProductInput, OrderItemUncheckedUpdateWithoutChatProductInput>
    create: XOR<OrderItemCreateWithoutChatProductInput, OrderItemUncheckedCreateWithoutChatProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutChatProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutChatProductInput, OrderItemUncheckedUpdateWithoutChatProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutChatProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutChatProductInput>
  }

  export type ChatProductCreateWithoutImagesInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutChatProductsInput
    cartItems?: CartItemCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUncheckedCreateWithoutImagesInput = {
    id?: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    cartItems?: CartItemUncheckedCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductCreateOrConnectWithoutImagesInput = {
    where: ChatProductWhereUniqueInput
    create: XOR<ChatProductCreateWithoutImagesInput, ChatProductUncheckedCreateWithoutImagesInput>
  }

  export type ChatProductUpsertWithoutImagesInput = {
    update: XOR<ChatProductUpdateWithoutImagesInput, ChatProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ChatProductCreateWithoutImagesInput, ChatProductUncheckedCreateWithoutImagesInput>
    where?: ChatProductWhereInput
  }

  export type ChatProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ChatProductWhereInput
    data: XOR<ChatProductUpdateWithoutImagesInput, ChatProductUncheckedUpdateWithoutImagesInput>
  }

  export type ChatProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutChatProductsNestedInput
    cartItems?: CartItemUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cartItems?: CartItemUncheckedUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutChatProductNestedInput
  }

  export type ChatCreateWithoutStatusInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutChatsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutChatsInput
    manager?: UserCreateNestedOneWithoutManagedChatsInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutStatusInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutStatusInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput>
  }

  export type ChatCreateManyStatusInputEnvelope = {
    data: ChatCreateManyStatusInput | ChatCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type ChatUpsertWithWhereUniqueWithoutStatusInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutStatusInput, ChatUncheckedUpdateWithoutStatusInput>
    create: XOR<ChatCreateWithoutStatusInput, ChatUncheckedCreateWithoutStatusInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutStatusInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutStatusInput, ChatUncheckedUpdateWithoutStatusInput>
  }

  export type ChatUpdateManyWithWhereWithoutStatusInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutStatusInput>
  }

  export type UserCreateWithoutChatsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
  }

  export type AnonymousUserCreateWithoutChatsInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserUncheckedCreateWithoutChatsInput = {
    id?: string
    sessionId: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    lastActivity?: Date | string
    carts?: CartUncheckedCreateNestedManyWithoutAnonymousUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutAnonymousUserInput
  }

  export type AnonymousUserCreateOrConnectWithoutChatsInput = {
    where: AnonymousUserWhereUniqueInput
    create: XOR<AnonymousUserCreateWithoutChatsInput, AnonymousUserUncheckedCreateWithoutChatsInput>
  }

  export type UserCreateWithoutManagedChatsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutManagedChatsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutManagedChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedChatsInput, UserUncheckedCreateWithoutManagedChatsInput>
  }

  export type ChatStatusCreateWithoutChatsInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChatStatusUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChatStatusCreateOrConnectWithoutChatsInput = {
    where: ChatStatusWhereUniqueInput
    create: XOR<ChatStatusCreateWithoutChatsInput, ChatStatusUncheckedCreateWithoutChatsInput>
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatProducts?: ChatProductCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    chatProducts?: ChatProductUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChatsInput = {
    update: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnonymousUserUpsertWithoutChatsInput = {
    update: XOR<AnonymousUserUpdateWithoutChatsInput, AnonymousUserUncheckedUpdateWithoutChatsInput>
    create: XOR<AnonymousUserCreateWithoutChatsInput, AnonymousUserUncheckedCreateWithoutChatsInput>
    where?: AnonymousUserWhereInput
  }

  export type AnonymousUserUpdateToOneWithWhereWithoutChatsInput = {
    where?: AnonymousUserWhereInput
    data: XOR<AnonymousUserUpdateWithoutChatsInput, AnonymousUserUncheckedUpdateWithoutChatsInput>
  }

  export type AnonymousUserUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutAnonymousUserNestedInput
  }

  export type AnonymousUserUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    carts?: CartUncheckedUpdateManyWithoutAnonymousUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutAnonymousUserNestedInput
  }

  export type UserUpsertWithoutManagedChatsInput = {
    update: XOR<UserUpdateWithoutManagedChatsInput, UserUncheckedUpdateWithoutManagedChatsInput>
    create: XOR<UserCreateWithoutManagedChatsInput, UserUncheckedCreateWithoutManagedChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedChatsInput, UserUncheckedUpdateWithoutManagedChatsInput>
  }

  export type UserUpdateWithoutManagedChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChatStatusUpsertWithoutChatsInput = {
    update: XOR<ChatStatusUpdateWithoutChatsInput, ChatStatusUncheckedUpdateWithoutChatsInput>
    create: XOR<ChatStatusCreateWithoutChatsInput, ChatStatusUncheckedCreateWithoutChatsInput>
    where?: ChatStatusWhereInput
  }

  export type ChatStatusUpdateToOneWithWhereWithoutChatsInput = {
    where?: ChatStatusWhereInput
    data: XOR<ChatStatusUpdateWithoutChatsInput, ChatStatusUncheckedUpdateWithoutChatsInput>
  }

  export type ChatStatusUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatStatusUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    senderId?: StringNullableFilter<"Message"> | string | null
    senderType?: EnumSenderTypeFilter<"Message"> | $Enums.SenderType
    messageType?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutChatsInput
    anonymousUser?: AnonymousUserCreateNestedOneWithoutChatsInput
    manager?: UserCreateNestedOneWithoutManagedChatsInput
    status: ChatStatusCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type ChatProductCreateWithoutMessageInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    images?: ChatProductImageCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUncheckedCreateWithoutMessageInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    images?: ChatProductImageUncheckedCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutChatProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductCreateOrConnectWithoutMessageInput = {
    where: ChatProductWhereUniqueInput
    create: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput>
  }

  export type ChatProductCreateManyMessageInputEnvelope = {
    data: ChatProductCreateManyMessageInput | ChatProductCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutChatsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutChatsNestedInput
    manager?: UserUpdateOneWithoutManagedChatsNestedInput
    status?: ChatStatusUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatProductUpsertWithWhereUniqueWithoutMessageInput = {
    where: ChatProductWhereUniqueInput
    update: XOR<ChatProductUpdateWithoutMessageInput, ChatProductUncheckedUpdateWithoutMessageInput>
    create: XOR<ChatProductCreateWithoutMessageInput, ChatProductUncheckedCreateWithoutMessageInput>
  }

  export type ChatProductUpdateWithWhereUniqueWithoutMessageInput = {
    where: ChatProductWhereUniqueInput
    data: XOR<ChatProductUpdateWithoutMessageInput, ChatProductUncheckedUpdateWithoutMessageInput>
  }

  export type ChatProductUpdateManyWithWhereWithoutMessageInput = {
    where: ChatProductScalarWhereInput
    data: XOR<ChatProductUpdateManyMutationInput, ChatProductUncheckedUpdateManyWithoutMessageInput>
  }

  export type ChatProductScalarWhereInput = {
    AND?: ChatProductScalarWhereInput | ChatProductScalarWhereInput[]
    OR?: ChatProductScalarWhereInput[]
    NOT?: ChatProductScalarWhereInput | ChatProductScalarWhereInput[]
    id?: StringFilter<"ChatProduct"> | string
    messageId?: StringFilter<"ChatProduct"> | string
    name?: StringFilter<"ChatProduct"> | string
    brand?: StringFilter<"ChatProduct"> | string
    sku?: StringFilter<"ChatProduct"> | string
    price?: DecimalFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string
    comparePrice?: DecimalNullableFilter<"ChatProduct"> | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFilter<"ChatProduct"> | boolean
    deliveryDays?: IntNullableFilter<"ChatProduct"> | number | null
    description?: StringNullableFilter<"ChatProduct"> | string | null
    createdAt?: DateTimeFilter<"ChatProduct"> | Date | string
  }

  export type OrderCreateWithoutStatusInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStatusInput = {
    id?: string
    orderNumber: string
    userId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStatusInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput>
  }

  export type OrderCreateManyStatusInputEnvelope = {
    data: OrderCreateManyStatusInput | OrderCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrderStatusLogCreateWithoutStatusInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutStatusLogsInput
    createdBy: UserCreateNestedOneWithoutOrderStatusLogsInput
  }

  export type OrderStatusLogUncheckedCreateWithoutStatusInput = {
    id?: string
    orderId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type OrderStatusLogCreateOrConnectWithoutStatusInput = {
    where: OrderStatusLogWhereUniqueInput
    create: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput>
  }

  export type OrderStatusLogCreateManyStatusInputEnvelope = {
    data: OrderStatusLogCreateManyStatusInput | OrderStatusLogCreateManyStatusInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutStatusInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutStatusInput, OrderUncheckedUpdateWithoutStatusInput>
    create: XOR<OrderCreateWithoutStatusInput, OrderUncheckedCreateWithoutStatusInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutStatusInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutStatusInput, OrderUncheckedUpdateWithoutStatusInput>
  }

  export type OrderUpdateManyWithWhereWithoutStatusInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutStatusInput>
  }

  export type OrderStatusLogUpsertWithWhereUniqueWithoutStatusInput = {
    where: OrderStatusLogWhereUniqueInput
    update: XOR<OrderStatusLogUpdateWithoutStatusInput, OrderStatusLogUncheckedUpdateWithoutStatusInput>
    create: XOR<OrderStatusLogCreateWithoutStatusInput, OrderStatusLogUncheckedCreateWithoutStatusInput>
  }

  export type OrderStatusLogUpdateWithWhereUniqueWithoutStatusInput = {
    where: OrderStatusLogWhereUniqueInput
    data: XOR<OrderStatusLogUpdateWithoutStatusInput, OrderStatusLogUncheckedUpdateWithoutStatusInput>
  }

  export type OrderStatusLogUpdateManyWithWhereWithoutStatusInput = {
    where: OrderStatusLogScalarWhereInput
    data: XOR<OrderStatusLogUpdateManyMutationInput, OrderStatusLogUncheckedUpdateManyWithoutStatusInput>
  }

  export type OrderCreateWithoutDeliveryMethodInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryMethodInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryMethodInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput>
  }

  export type OrderCreateManyDeliveryMethodInputEnvelope = {
    data: OrderCreateManyDeliveryMethodInput | OrderCreateManyDeliveryMethodInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutDeliveryMethodInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDeliveryMethodInput, OrderUncheckedUpdateWithoutDeliveryMethodInput>
    create: XOR<OrderCreateWithoutDeliveryMethodInput, OrderUncheckedCreateWithoutDeliveryMethodInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDeliveryMethodInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDeliveryMethodInput, OrderUncheckedUpdateWithoutDeliveryMethodInput>
  }

  export type OrderUpdateManyWithWhereWithoutDeliveryMethodInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutDeliveryMethodInput>
  }

  export type OrderCreateWithoutPaymentMethodInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentMethodInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput>
  }

  export type OrderCreateManyPaymentMethodInputEnvelope = {
    data: OrderCreateManyPaymentMethodInput | OrderCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPaymentMethodInput, OrderUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<OrderCreateWithoutPaymentMethodInput, OrderUncheckedCreateWithoutPaymentMethodInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPaymentMethodInput, OrderUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type OrderUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orderLogs?: OrderStatusLogCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orderLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusCreateOrConnectWithoutOrdersInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
  }

  export type DeliveryMethodCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeliveryMethodUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DeliveryMethodCreateOrConnectWithoutOrdersInput = {
    where: DeliveryMethodWhereUniqueInput
    create: XOR<DeliveryMethodCreateWithoutOrdersInput, DeliveryMethodUncheckedCreateWithoutOrdersInput>
  }

  export type PaymentMethodCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    icon?: string | null
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    icon?: string | null
    isOnline?: boolean
    isActive?: boolean
    sortOrder?: number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PaymentMethodCreateOrConnectWithoutOrdersInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutOrdersInput, PaymentMethodUncheckedCreateWithoutOrdersInput>
  }

  export type PromoCodeCreateWithoutOrdersInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutPromoCodesInput
    personalUser?: UserCreateNestedOneWithoutPersonalPromoCodesInput
    usage?: PromoCodeUsageCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateWithoutOrdersInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    usage?: PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeCreateOrConnectWithoutOrdersInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    product?: ProductCreateNestedOneWithoutOrderItemsInput
    chatProduct?: ChatProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderStatusLogCreateWithoutOrderInput = {
    id?: string
    comment?: string | null
    createdAt?: Date | string
    status: OrderStatusCreateNestedOneWithoutOrderLogsInput
    createdBy: UserCreateNestedOneWithoutOrderStatusLogsInput
  }

  export type OrderStatusLogUncheckedCreateWithoutOrderInput = {
    id?: string
    statusId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type OrderStatusLogCreateOrConnectWithoutOrderInput = {
    where: OrderStatusLogWhereUniqueInput
    create: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusLogCreateManyOrderInputEnvelope = {
    data: OrderStatusLogCreateManyOrderInput | OrderStatusLogCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeUsageCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    promoCode: PromoCodeCreateNestedOneWithoutUsageInput
    user: UserCreateNestedOneWithoutPromoCodeUsageInput
  }

  export type PromoCodeUsageUncheckedCreateWithoutOrderInput = {
    id?: string
    promoCodeId: string
    userId: string
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateOrConnectWithoutOrderInput = {
    where: PromoCodeUsageWhereUniqueInput
    create: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput>
  }

  export type PromoCodeUsageCreateManyOrderInputEnvelope = {
    data: PromoCodeUsageCreateManyOrderInput | PromoCodeUsageCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderStatusUpsertWithoutOrdersInput = {
    update: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderStatusCreateWithoutOrdersInput, OrderStatusUncheckedCreateWithoutOrdersInput>
    where?: OrderStatusWhereInput
  }

  export type OrderStatusUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OrderStatusWhereInput
    data: XOR<OrderStatusUpdateWithoutOrdersInput, OrderStatusUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLogs?: OrderStatusLogUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderLogs?: OrderStatusLogUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type DeliveryMethodUpsertWithoutOrdersInput = {
    update: XOR<DeliveryMethodUpdateWithoutOrdersInput, DeliveryMethodUncheckedUpdateWithoutOrdersInput>
    create: XOR<DeliveryMethodCreateWithoutOrdersInput, DeliveryMethodUncheckedCreateWithoutOrdersInput>
    where?: DeliveryMethodWhereInput
  }

  export type DeliveryMethodUpdateToOneWithWhereWithoutOrdersInput = {
    where?: DeliveryMethodWhereInput
    data: XOR<DeliveryMethodUpdateWithoutOrdersInput, DeliveryMethodUncheckedUpdateWithoutOrdersInput>
  }

  export type DeliveryMethodUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryMethodUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUpsertWithoutOrdersInput = {
    update: XOR<PaymentMethodUpdateWithoutOrdersInput, PaymentMethodUncheckedUpdateWithoutOrdersInput>
    create: XOR<PaymentMethodCreateWithoutOrdersInput, PaymentMethodUncheckedCreateWithoutOrdersInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutOrdersInput, PaymentMethodUncheckedUpdateWithoutOrdersInput>
  }

  export type PaymentMethodUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    commission?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUpsertWithoutOrdersInput = {
    update: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>
    create: XOR<PromoCodeCreateWithoutOrdersInput, PromoCodeUncheckedCreateWithoutOrdersInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutOrdersInput, PromoCodeUncheckedUpdateWithoutOrdersInput>
  }

  export type PromoCodeUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutPromoCodesNestedInput
    personalUser?: UserUpdateOneWithoutPersonalPromoCodesNestedInput
    usage?: PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderStatusLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusLogWhereUniqueInput
    update: XOR<OrderStatusLogUpdateWithoutOrderInput, OrderStatusLogUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderStatusLogCreateWithoutOrderInput, OrderStatusLogUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusLogWhereUniqueInput
    data: XOR<OrderStatusLogUpdateWithoutOrderInput, OrderStatusLogUncheckedUpdateWithoutOrderInput>
  }

  export type OrderStatusLogUpdateManyWithWhereWithoutOrderInput = {
    where: OrderStatusLogScalarWhereInput
    data: XOR<OrderStatusLogUpdateManyMutationInput, OrderStatusLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type PromoCodeUsageUpsertWithWhereUniqueWithoutOrderInput = {
    where: PromoCodeUsageWhereUniqueInput
    update: XOR<PromoCodeUsageUpdateWithoutOrderInput, PromoCodeUsageUncheckedUpdateWithoutOrderInput>
    create: XOR<PromoCodeUsageCreateWithoutOrderInput, PromoCodeUsageUncheckedCreateWithoutOrderInput>
  }

  export type PromoCodeUsageUpdateWithWhereUniqueWithoutOrderInput = {
    where: PromoCodeUsageWhereUniqueInput
    data: XOR<PromoCodeUsageUpdateWithoutOrderInput, PromoCodeUsageUncheckedUpdateWithoutOrderInput>
  }

  export type PromoCodeUsageUpdateManyWithWhereWithoutOrderInput = {
    where: PromoCodeUsageScalarWhereInput
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    brand: BrandCreateNestedOneWithoutProductsInput
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceCreateNestedManyWithoutProductInput
    cartItems?: CartItemCreateNestedManyWithoutProductInput
    favorites?: FavoriteCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    brandId: string
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    characteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    vehicleApplications?: VehicleApplicationUncheckedCreateNestedManyWithoutProductInput
    crossReferences?: CrossReferenceUncheckedCreateNestedManyWithoutProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutProductInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutProductInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type ChatProductCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    message: MessageCreateNestedOneWithoutChatProductsInput
    images?: ChatProductImageCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    messageId: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
    images?: ChatProductImageUncheckedCreateNestedManyWithoutChatProductInput
    cartItems?: CartItemUncheckedCreateNestedManyWithoutChatProductInput
  }

  export type ChatProductCreateOrConnectWithoutOrderItemsInput = {
    where: ChatProductWhereUniqueInput
    create: XOR<ChatProductCreateWithoutOrderItemsInput, ChatProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    brandId?: StringFieldUpdateOperationsInput | string
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ChatProductUpsertWithoutOrderItemsInput = {
    update: XOR<ChatProductUpdateWithoutOrderItemsInput, ChatProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ChatProductCreateWithoutOrderItemsInput, ChatProductUncheckedCreateWithoutOrderItemsInput>
    where?: ChatProductWhereInput
  }

  export type ChatProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ChatProductWhereInput
    data: XOR<ChatProductUpdateWithoutOrderItemsInput, ChatProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ChatProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutChatProductsNestedInput
    images?: ChatProductImageUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ChatProductImageUncheckedUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutChatProductNestedInput
  }

  export type OrderCreateWithoutStatusLogsInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStatusLogsInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStatusLogsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStatusLogsInput, OrderUncheckedCreateWithoutStatusLogsInput>
  }

  export type OrderStatusCreateWithoutOrderLogsInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusUncheckedCreateWithoutOrderLogsInput = {
    id?: string
    name: string
    code: string
    color?: string | null
    description?: string | null
    isInitial?: boolean
    isFinalSuccess?: boolean
    isFinalFailure?: boolean
    canCancelOrder?: boolean
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutStatusInput
  }

  export type OrderStatusCreateOrConnectWithoutOrderLogsInput = {
    where: OrderStatusWhereUniqueInput
    create: XOR<OrderStatusCreateWithoutOrderLogsInput, OrderStatusUncheckedCreateWithoutOrderLogsInput>
  }

  export type UserCreateWithoutOrderStatusLogsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrderStatusLogsInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrderStatusLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderStatusLogsInput, UserUncheckedCreateWithoutOrderStatusLogsInput>
  }

  export type OrderUpsertWithoutStatusLogsInput = {
    update: XOR<OrderUpdateWithoutStatusLogsInput, OrderUncheckedUpdateWithoutStatusLogsInput>
    create: XOR<OrderCreateWithoutStatusLogsInput, OrderUncheckedCreateWithoutStatusLogsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStatusLogsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStatusLogsInput, OrderUncheckedUpdateWithoutStatusLogsInput>
  }

  export type OrderUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderStatusUpsertWithoutOrderLogsInput = {
    update: XOR<OrderStatusUpdateWithoutOrderLogsInput, OrderStatusUncheckedUpdateWithoutOrderLogsInput>
    create: XOR<OrderStatusCreateWithoutOrderLogsInput, OrderStatusUncheckedCreateWithoutOrderLogsInput>
    where?: OrderStatusWhereInput
  }

  export type OrderStatusUpdateToOneWithWhereWithoutOrderLogsInput = {
    where?: OrderStatusWhereInput
    data: XOR<OrderStatusUpdateWithoutOrderLogsInput, OrderStatusUncheckedUpdateWithoutOrderLogsInput>
  }

  export type OrderStatusUpdateWithoutOrderLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutStatusNestedInput
  }

  export type OrderStatusUncheckedUpdateWithoutOrderLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isInitial?: BoolFieldUpdateOperationsInput | boolean
    isFinalSuccess?: BoolFieldUpdateOperationsInput | boolean
    isFinalFailure?: BoolFieldUpdateOperationsInput | boolean
    canCancelOrder?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type UserUpsertWithoutOrderStatusLogsInput = {
    update: XOR<UserUpdateWithoutOrderStatusLogsInput, UserUncheckedUpdateWithoutOrderStatusLogsInput>
    create: XOR<UserCreateWithoutOrderStatusLogsInput, UserUncheckedCreateWithoutOrderStatusLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderStatusLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderStatusLogsInput, UserUncheckedUpdateWithoutOrderStatusLogsInput>
  }

  export type UserUpdateWithoutOrderStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderStatusLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderCreateWithoutPaymentsInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
  }

  export type OrderUpsertWithoutPaymentsInput = {
    update: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<OrderCreateWithoutPaymentsInput, OrderUncheckedCreateWithoutPaymentsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentsInput, OrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type OrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type UserCreateWithoutCustomerGroupInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomerGroupInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomerGroupInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput>
  }

  export type UserCreateManyCustomerGroupInputEnvelope = {
    data: UserCreateManyCustomerGroupInput | UserCreateManyCustomerGroupInput[]
    skipDuplicates?: boolean
  }

  export type DiscountRuleCreateWithoutCustomerGroupInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    promoCodes?: PromoCodeCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleUncheckedCreateWithoutCustomerGroupInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutDiscountRuleInput
  }

  export type DiscountRuleCreateOrConnectWithoutCustomerGroupInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput>
  }

  export type DiscountRuleCreateManyCustomerGroupInputEnvelope = {
    data: DiscountRuleCreateManyCustomerGroupInput | DiscountRuleCreateManyCustomerGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutCustomerGroupInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCustomerGroupInput, UserUncheckedUpdateWithoutCustomerGroupInput>
    create: XOR<UserCreateWithoutCustomerGroupInput, UserUncheckedCreateWithoutCustomerGroupInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCustomerGroupInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCustomerGroupInput, UserUncheckedUpdateWithoutCustomerGroupInput>
  }

  export type UserUpdateManyWithWhereWithoutCustomerGroupInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCustomerGroupInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    customerGroupId?: StringNullableFilter<"User"> | string | null
    personalDiscount?: DecimalNullableFilter<"User"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type DiscountRuleUpsertWithWhereUniqueWithoutCustomerGroupInput = {
    where: DiscountRuleWhereUniqueInput
    update: XOR<DiscountRuleUpdateWithoutCustomerGroupInput, DiscountRuleUncheckedUpdateWithoutCustomerGroupInput>
    create: XOR<DiscountRuleCreateWithoutCustomerGroupInput, DiscountRuleUncheckedCreateWithoutCustomerGroupInput>
  }

  export type DiscountRuleUpdateWithWhereUniqueWithoutCustomerGroupInput = {
    where: DiscountRuleWhereUniqueInput
    data: XOR<DiscountRuleUpdateWithoutCustomerGroupInput, DiscountRuleUncheckedUpdateWithoutCustomerGroupInput>
  }

  export type DiscountRuleUpdateManyWithWhereWithoutCustomerGroupInput = {
    where: DiscountRuleScalarWhereInput
    data: XOR<DiscountRuleUpdateManyMutationInput, DiscountRuleUncheckedUpdateManyWithoutCustomerGroupInput>
  }

  export type DiscountRuleScalarWhereInput = {
    AND?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
    OR?: DiscountRuleScalarWhereInput[]
    NOT?: DiscountRuleScalarWhereInput | DiscountRuleScalarWhereInput[]
    id?: StringFilter<"DiscountRule"> | string
    name?: StringFilter<"DiscountRule"> | string
    type?: EnumDiscountTypeFilter<"DiscountRule"> | $Enums.DiscountType
    value?: DecimalFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"DiscountRule"> | Decimal | DecimalJsLike | number | string | null
    startDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    endDate?: DateTimeNullableFilter<"DiscountRule"> | Date | string | null
    usageLimit?: IntNullableFilter<"DiscountRule"> | number | null
    customerGroupId?: StringNullableFilter<"DiscountRule"> | string | null
    categories?: JsonNullableFilter<"DiscountRule">
    brands?: JsonNullableFilter<"DiscountRule">
    isActive?: BoolFilter<"DiscountRule"> | boolean
  }

  export type CustomerGroupCreateWithoutDiscountRulesInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupUncheckedCreateWithoutDiscountRulesInput = {
    id?: string
    name: string
    discountPercent?: Decimal | DecimalJsLike | number | string
    minOrderAmount?: Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUncheckedCreateNestedManyWithoutCustomerGroupInput
  }

  export type CustomerGroupCreateOrConnectWithoutDiscountRulesInput = {
    where: CustomerGroupWhereUniqueInput
    create: XOR<CustomerGroupCreateWithoutDiscountRulesInput, CustomerGroupUncheckedCreateWithoutDiscountRulesInput>
  }

  export type PromoCodeCreateWithoutDiscountRuleInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    personalUser?: UserCreateNestedOneWithoutPersonalPromoCodesInput
    orders?: OrderCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateWithoutDiscountRuleInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput
    usage?: PromoCodeUsageUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeCreateOrConnectWithoutDiscountRuleInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput>
  }

  export type PromoCodeCreateManyDiscountRuleInputEnvelope = {
    data: PromoCodeCreateManyDiscountRuleInput | PromoCodeCreateManyDiscountRuleInput[]
    skipDuplicates?: boolean
  }

  export type CustomerGroupUpsertWithoutDiscountRulesInput = {
    update: XOR<CustomerGroupUpdateWithoutDiscountRulesInput, CustomerGroupUncheckedUpdateWithoutDiscountRulesInput>
    create: XOR<CustomerGroupCreateWithoutDiscountRulesInput, CustomerGroupUncheckedCreateWithoutDiscountRulesInput>
    where?: CustomerGroupWhereInput
  }

  export type CustomerGroupUpdateToOneWithWhereWithoutDiscountRulesInput = {
    where?: CustomerGroupWhereInput
    data: XOR<CustomerGroupUpdateWithoutDiscountRulesInput, CustomerGroupUncheckedUpdateWithoutDiscountRulesInput>
  }

  export type CustomerGroupUpdateWithoutDiscountRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUpdateManyWithoutCustomerGroupNestedInput
  }

  export type CustomerGroupUncheckedUpdateWithoutDiscountRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minOrderAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    benefits?: NullableJsonNullValueInput | InputJsonValue
    users?: UserUncheckedUpdateManyWithoutCustomerGroupNestedInput
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutDiscountRuleInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutDiscountRuleInput, PromoCodeUncheckedUpdateWithoutDiscountRuleInput>
    create: XOR<PromoCodeCreateWithoutDiscountRuleInput, PromoCodeUncheckedCreateWithoutDiscountRuleInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutDiscountRuleInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutDiscountRuleInput, PromoCodeUncheckedUpdateWithoutDiscountRuleInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutDiscountRuleInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutDiscountRuleInput>
  }

  export type DiscountRuleCreateWithoutPromoCodesInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    customerGroup?: CustomerGroupCreateNestedOneWithoutDiscountRulesInput
  }

  export type DiscountRuleUncheckedCreateWithoutPromoCodesInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    customerGroupId?: string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type DiscountRuleCreateOrConnectWithoutPromoCodesInput = {
    where: DiscountRuleWhereUniqueInput
    create: XOR<DiscountRuleCreateWithoutPromoCodesInput, DiscountRuleUncheckedCreateWithoutPromoCodesInput>
  }

  export type UserCreateWithoutPersonalPromoCodesInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPersonalPromoCodesInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPersonalPromoCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalPromoCodesInput, UserUncheckedCreateWithoutPersonalPromoCodesInput>
  }

  export type OrderCreateWithoutPromoCodeInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    promoCodeUsage?: PromoCodeUsageUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
  }

  export type OrderCreateManyPromoCodeInputEnvelope = {
    data: OrderCreateManyPromoCodeInput | OrderCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeUsageCreateWithoutPromoCodeInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPromoCodeUsageInput
    order?: OrderCreateNestedOneWithoutPromoCodeUsageInput
  }

  export type PromoCodeUsageUncheckedCreateWithoutPromoCodeInput = {
    id?: string
    userId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateOrConnectWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    create: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageCreateManyPromoCodeInputEnvelope = {
    data: PromoCodeUsageCreateManyPromoCodeInput | PromoCodeUsageCreateManyPromoCodeInput[]
    skipDuplicates?: boolean
  }

  export type DiscountRuleUpsertWithoutPromoCodesInput = {
    update: XOR<DiscountRuleUpdateWithoutPromoCodesInput, DiscountRuleUncheckedUpdateWithoutPromoCodesInput>
    create: XOR<DiscountRuleCreateWithoutPromoCodesInput, DiscountRuleUncheckedCreateWithoutPromoCodesInput>
    where?: DiscountRuleWhereInput
  }

  export type DiscountRuleUpdateToOneWithWhereWithoutPromoCodesInput = {
    where?: DiscountRuleWhereInput
    data: XOR<DiscountRuleUpdateWithoutPromoCodesInput, DiscountRuleUncheckedUpdateWithoutPromoCodesInput>
  }

  export type DiscountRuleUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    customerGroup?: CustomerGroupUpdateOneWithoutDiscountRulesNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutPersonalPromoCodesInput = {
    update: XOR<UserUpdateWithoutPersonalPromoCodesInput, UserUncheckedUpdateWithoutPersonalPromoCodesInput>
    create: XOR<UserCreateWithoutPersonalPromoCodesInput, UserUncheckedCreateWithoutPersonalPromoCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalPromoCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalPromoCodesInput, UserUncheckedUpdateWithoutPersonalPromoCodesInput>
  }

  export type UserUpdateWithoutPersonalPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalPromoCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<OrderCreateWithoutPromoCodeInput, OrderUncheckedCreateWithoutPromoCodeInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPromoCodeInput, OrderUncheckedUpdateWithoutPromoCodeInput>
  }

  export type OrderUpdateManyWithWhereWithoutPromoCodeInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type PromoCodeUsageUpsertWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    update: XOR<PromoCodeUsageUpdateWithoutPromoCodeInput, PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput>
    create: XOR<PromoCodeUsageCreateWithoutPromoCodeInput, PromoCodeUsageUncheckedCreateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageUpdateWithWhereUniqueWithoutPromoCodeInput = {
    where: PromoCodeUsageWhereUniqueInput
    data: XOR<PromoCodeUsageUpdateWithoutPromoCodeInput, PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput>
  }

  export type PromoCodeUsageUpdateManyWithWhereWithoutPromoCodeInput = {
    where: PromoCodeUsageScalarWhereInput
    data: XOR<PromoCodeUsageUpdateManyMutationInput, PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeInput>
  }

  export type PromoCodeCreateWithoutUsageInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    discountRule: DiscountRuleCreateNestedOneWithoutPromoCodesInput
    personalUser?: UserCreateNestedOneWithoutPersonalPromoCodesInput
    orders?: OrderCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeUncheckedCreateWithoutUsageInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPromoCodeInput
  }

  export type PromoCodeCreateOrConnectWithoutUsageInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutUsageInput, PromoCodeUncheckedCreateWithoutUsageInput>
  }

  export type UserCreateWithoutPromoCodeUsageInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    customerGroup?: CustomerGroupCreateNestedOneWithoutUsersInput
    carts?: CartCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    chats?: ChatCreateNestedManyWithoutUserInput
    managedChats?: ChatCreateNestedManyWithoutManagerInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeCreateNestedManyWithoutPersonalUserInput
    orderStatusLogs?: OrderStatusLogCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPromoCodeUsageInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    customerGroupId?: string | null
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    carts?: CartUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    managedChats?: ChatUncheckedCreateNestedManyWithoutManagerInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    viewHistory?: ViewHistoryUncheckedCreateNestedManyWithoutUserInput
    personalPromoCodes?: PromoCodeUncheckedCreateNestedManyWithoutPersonalUserInput
    orderStatusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutCreatedByInput
    PushSubscription?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    NotificationLog?: NotificationLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPromoCodeUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPromoCodeUsageInput, UserUncheckedCreateWithoutPromoCodeUsageInput>
  }

  export type OrderCreateWithoutPromoCodeUsageInput = {
    id?: string
    orderNumber: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    status: OrderStatusCreateNestedOneWithoutOrdersInput
    deliveryMethod: DeliveryMethodCreateNestedOneWithoutOrdersInput
    paymentMethod: PaymentMethodCreateNestedOneWithoutOrdersInput
    promoCode?: PromoCodeCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPromoCodeUsageInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    statusLogs?: OrderStatusLogUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPromoCodeUsageInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPromoCodeUsageInput, OrderUncheckedCreateWithoutPromoCodeUsageInput>
  }

  export type PromoCodeUpsertWithoutUsageInput = {
    update: XOR<PromoCodeUpdateWithoutUsageInput, PromoCodeUncheckedUpdateWithoutUsageInput>
    create: XOR<PromoCodeCreateWithoutUsageInput, PromoCodeUncheckedCreateWithoutUsageInput>
    where?: PromoCodeWhereInput
  }

  export type PromoCodeUpdateToOneWithWhereWithoutUsageInput = {
    where?: PromoCodeWhereInput
    data: XOR<PromoCodeUpdateWithoutUsageInput, PromoCodeUncheckedUpdateWithoutUsageInput>
  }

  export type PromoCodeUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutPromoCodesNestedInput
    personalUser?: UserUpdateOneWithoutPersonalPromoCodesNestedInput
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type UserUpsertWithoutPromoCodeUsageInput = {
    update: XOR<UserUpdateWithoutPromoCodeUsageInput, UserUncheckedUpdateWithoutPromoCodeUsageInput>
    create: XOR<UserCreateWithoutPromoCodeUsageInput, UserUncheckedCreateWithoutPromoCodeUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPromoCodeUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPromoCodeUsageInput, UserUncheckedUpdateWithoutPromoCodeUsageInput>
  }

  export type UserUpdateWithoutPromoCodeUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerGroup?: CustomerGroupUpdateOneWithoutUsersNestedInput
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPromoCodeUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    customerGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrderUpsertWithoutPromoCodeUsageInput = {
    update: XOR<OrderUpdateWithoutPromoCodeUsageInput, OrderUncheckedUpdateWithoutPromoCodeUsageInput>
    create: XOR<OrderCreateWithoutPromoCodeUsageInput, OrderUncheckedCreateWithoutPromoCodeUsageInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPromoCodeUsageInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPromoCodeUsageInput, OrderUncheckedUpdateWithoutPromoCodeUsageInput>
  }

  export type OrderUpdateWithoutPromoCodeUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPromoCodeUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type CartCreateManyUserInput = {
    id?: string
    anonymousId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    orderNumber: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyUserInput = {
    id?: string
    anonymousId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatCreateManyManagerInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type FavoriteCreateManyUserInput = {
    id?: string
    productId: string
    createdAt?: Date | string
  }

  export type ViewHistoryCreateManyUserInput = {
    id?: string
    anonymousId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type PromoCodeCreateManyPersonalUserInput = {
    id?: string
    code: string
    discountRuleId: string
    usageCount?: number
    usageLimit?: number | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PromoCodeUsageCreateManyUserInput = {
    id?: string
    promoCodeId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type OrderStatusLogCreateManyCreatedByInput = {
    id?: string
    orderId: string
    statusId: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type PushSubscriptionCreateManyUserInput = {
    id?: string
    endpoint: string
    p256dh: string
    auth: string
    userAgent?: string | null
    deviceName?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastUsedAt?: Date | string
  }

  export type NotificationLogCreateManyUserInput = {
    id?: string
    type: string
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: string | null
    status: string
    errorMessage?: string | null
    sentAt?: Date | string
    clickedAt?: Date | string | null
  }

  export type CartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anonymousUser?: AnonymousUserUpdateOneWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anonymousUser?: AnonymousUserUpdateOneWithoutChatsNestedInput
    manager?: UserUpdateOneWithoutManagedChatsNestedInput
    status?: ChatStatusUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutChatsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutChatsNestedInput
    status?: ChatStatusUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FavoriteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anonymousUser?: AnonymousUserUpdateOneWithoutViewHistoryNestedInput
    product?: ProductUpdateOneWithoutViewHistoryNestedInput
    category?: CategoryUpdateOneWithoutViewHistoryNestedInput
  }

  export type ViewHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUpdateWithoutPersonalUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountRule?: DiscountRuleUpdateOneRequiredWithoutPromoCodesNestedInput
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutPersonalUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateManyWithoutPersonalUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    discountRuleId?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUsageNestedInput
    order?: OrderUpdateOneWithoutPromoCodeUsageNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStatusLogsNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrderLogsNestedInput
  }

  export type OrderStatusLogUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    endpoint?: StringFieldUpdateOperationsInput | string
    p256dh?: StringFieldUpdateOperationsInput | string
    auth?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    deviceName?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUsedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CartCreateManyAnonymousUserInput = {
    id?: string
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateManyAnonymousUserInput = {
    id?: string
    userId?: string | null
    managerId?: string | null
    statusId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ViewHistoryCreateManyAnonymousUserInput = {
    id?: string
    userId?: string | null
    productId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type CartUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutCartsNestedInput
    items?: CartItemUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: CartItemUncheckedUpdateManyWithoutCartNestedInput
  }

  export type CartUncheckedUpdateManyWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutChatsNestedInput
    manager?: UserUpdateOneWithoutManagedChatsNestedInput
    status?: ChatStatusUpdateOneRequiredWithoutChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    statusId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ViewHistoryUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutViewHistoryNestedInput
    product?: ProductUpdateOneWithoutViewHistoryNestedInput
    category?: CategoryUpdateOneWithoutViewHistoryNestedInput
  }

  export type ViewHistoryUncheckedUpdateWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUncheckedUpdateManyWithoutAnonymousUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type ProductCategoryCreateManyCategoryInput = {
    id?: string
    productId: string
    isPrimary?: boolean
  }

  export type CharacteristicCategoryCreateManyCategoryInput = {
    id?: string
    characteristicId: string
  }

  export type ViewHistoryCreateManyCategoryInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    productId?: string | null
    viewedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    characteristics?: CharacteristicCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacteristicCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristic?: CharacteristicUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type CharacteristicCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type ViewHistoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutViewHistoryNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutViewHistoryNestedInput
    product?: ProductUpdateOneWithoutViewHistoryNestedInput
  }

  export type ViewHistoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyProductInput = {
    id?: string
    categoryId: string
    isPrimary?: boolean
  }

  export type ProductImageCreateManyProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductCharacteristicCreateManyProductInput = {
    id?: string
    characteristicId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type VehicleApplicationCreateManyProductInput = {
    id?: string
    modificationId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type CrossReferenceCreateManyProductInput = {
    id?: string
    crossPartNumber: string
    crossBrandId: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type CartItemCreateManyProductInput = {
    id?: string
    cartId: string
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    orderId: string
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type FavoriteCreateManyProductInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ViewHistoryCreateManyProductInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    categoryId?: string | null
    viewedAt?: Date | string
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductImageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCharacteristicUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductValuesNestedInput
    characteristicValue?: CharacteristicValueUpdateOneWithoutProductValuesNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleApplicationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    modification?: VehicleModificationUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type VehicleApplicationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    modificationId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleApplicationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    modificationId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
    crossBrand?: BrandUpdateOneRequiredWithoutCrossReferencesNestedInput
  }

  export type CrossReferenceUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossBrandId?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossBrandId?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type FavoriteUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutViewHistoryNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutViewHistoryNestedInput
    category?: CategoryUpdateOneWithoutViewHistoryNestedInput
  }

  export type ViewHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViewHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyBrandInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    shortDescription?: string | null
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    stock?: number
    deliveryDays?: number | null
    isOriginal?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type CrossReferenceCreateManyCrossBrandInput = {
    id?: string
    productId: string
    crossPartNumber: string
    crossType: $Enums.CrossType
    confidenceScore?: Decimal | DecimalJsLike | number | string
    verifiedByExpert?: boolean
  }

  export type ProductUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    characteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    vehicleApplications?: VehicleApplicationUncheckedUpdateManyWithoutProductNestedInput
    crossReferences?: CrossReferenceUncheckedUpdateManyWithoutProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutProductNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    shortDescription?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stock?: IntFieldUpdateOperationsInput | number
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrossReferenceUpdateWithoutCrossBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutCrossReferencesNestedInput
  }

  export type CrossReferenceUncheckedUpdateWithoutCrossBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CrossReferenceUncheckedUpdateManyWithoutCrossBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    crossPartNumber?: StringFieldUpdateOperationsInput | string
    crossType?: EnumCrossTypeFieldUpdateOperationsInput | $Enums.CrossType
    confidenceScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedByExpert?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CharacteristicValueCreateManyCharacteristicInput = {
    id?: string
    value: string
    sortOrder?: number
  }

  export type ProductCharacteristicCreateManyCharacteristicInput = {
    id?: string
    productId: string
    value?: string | null
    characteristicValueId?: string | null
  }

  export type CharacteristicCategoryCreateManyCharacteristicInput = {
    id?: string
    categoryId: string
  }

  export type CharacteristicValueUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    productValues?: ProductCharacteristicUpdateManyWithoutCharacteristicValueNestedInput
  }

  export type CharacteristicValueUncheckedUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    productValues?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicValueNestedInput
  }

  export type CharacteristicValueUncheckedUpdateManyWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCharacteristicUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutCharacteristicsNestedInput
    characteristicValue?: CharacteristicValueUpdateOneWithoutProductValuesNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    characteristicValueId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacteristicCategoryUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutCharacteristicsNestedInput
  }

  export type CharacteristicCategoryUncheckedUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicCategoryUncheckedUpdateManyWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicCreateManyCharacteristicValueInput = {
    id?: string
    productId: string
    characteristicId: string
    value?: string | null
  }

  export type ProductCharacteristicUpdateWithoutCharacteristicValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
    product?: ProductUpdateOneRequiredWithoutCharacteristicsNestedInput
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductValuesNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutCharacteristicValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModelCreateManyMakeInput = {
    id?: string
    name: string
    slug: string
    modelCode?: string | null
    startYear: number
    endYear?: number | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleModelUpdateWithoutMakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    generations?: VehicleGenerationUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelUncheckedUpdateWithoutMakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    generations?: VehicleGenerationUncheckedUpdateManyWithoutModelNestedInput
  }

  export type VehicleModelUncheckedUpdateManyWithoutMakeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    modelCode?: NullableStringFieldUpdateOperationsInput | string | null
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleGenerationCreateManyModelInput = {
    id?: string
    name: string
    slug: string
    startYear: number
    endYear?: number | null
    bodyType?: string | null
    description?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
  }

  export type VehicleGenerationUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: VehicleModificationUpdateManyWithoutGenerationNestedInput
  }

  export type VehicleGenerationUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    modifications?: VehicleModificationUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type VehicleGenerationUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    startYear?: IntFieldUpdateOperationsInput | number
    endYear?: NullableIntFieldUpdateOperationsInput | number | null
    bodyType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleModificationCreateManyGenerationInput = {
    id?: string
    name: string
    engineCode?: string | null
    fuelType?: string | null
    powerHp?: number | null
    transmission?: string | null
  }

  export type VehicleModificationUpdateWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: VehicleApplicationUpdateManyWithoutModificationNestedInput
  }

  export type VehicleModificationUncheckedUpdateWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
    applications?: VehicleApplicationUncheckedUpdateManyWithoutModificationNestedInput
  }

  export type VehicleModificationUncheckedUpdateManyWithoutGenerationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    engineCode?: NullableStringFieldUpdateOperationsInput | string | null
    fuelType?: NullableStringFieldUpdateOperationsInput | string | null
    powerHp?: NullableIntFieldUpdateOperationsInput | number | null
    transmission?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleApplicationCreateManyModificationInput = {
    id?: string
    productId: string
    kTypeId?: string | null
    notes?: string | null
    isVerified?: boolean
  }

  export type VehicleApplicationUpdateWithoutModificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneRequiredWithoutVehicleApplicationsNestedInput
  }

  export type VehicleApplicationUncheckedUpdateWithoutModificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VehicleApplicationUncheckedUpdateManyWithoutModificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    kTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CartItemCreateManyCartInput = {
    id?: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CartItemUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneWithoutCartItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageCreateManyChatProductInput = {
    id?: string
    url: string
    alt?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type CartItemCreateManyChatProductInput = {
    id?: string
    cartId: string
    productId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateManyChatProductInput = {
    id?: string
    orderId: string
    productId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type ChatProductImageUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageUncheckedUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductImageUncheckedUpdateManyWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cart?: CartUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutCartItemsNestedInput
  }

  export type CartItemUncheckedUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CartItemUncheckedUpdateManyWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    cartId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    product?: ProductUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUncheckedUpdateManyWithoutChatProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ChatCreateManyStatusInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type ChatUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutChatsNestedInput
    anonymousUser?: AnonymousUserUpdateOneWithoutChatsNestedInput
    manager?: UserUpdateOneWithoutManagedChatsNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManyChatInput = {
    id?: string
    senderId?: string | null
    senderType: $Enums.SenderType
    messageType?: $Enums.MessageType
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatProducts?: ChatProductUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chatProducts?: ChatProductUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    senderType?: EnumSenderTypeFieldUpdateOperationsInput | $Enums.SenderType
    messageType?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatProductCreateManyMessageInput = {
    id?: string
    name: string
    brand: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    comparePrice?: Decimal | DecimalJsLike | number | string | null
    isOriginal?: boolean
    deliveryDays?: number | null
    description?: string | null
    createdAt?: Date | string
  }

  export type ChatProductUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ChatProductImageUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ChatProductImageUncheckedUpdateManyWithoutChatProductNestedInput
    cartItems?: CartItemUncheckedUpdateManyWithoutChatProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutChatProductNestedInput
  }

  export type ChatProductUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comparePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isOriginal?: BoolFieldUpdateOperationsInput | boolean
    deliveryDays?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyStatusInput = {
    id?: string
    orderNumber: string
    userId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderStatusLogCreateManyStatusInput = {
    id?: string
    orderId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type OrderUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutStatusLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrderStatusLogsNestedInput
  }

  export type OrderStatusLogUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyDeliveryMethodInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutDeliveryMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyPaymentMethodInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    promoCodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    promoCode?: PromoCodeUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    promoCodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    productId?: string | null
    chatProductId?: string | null
    quantity: number
    price: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type OrderStatusLogCreateManyOrderInput = {
    id?: string
    statusId: string
    comment?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    status: string
    transactionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUsageCreateManyOrderInput = {
    id?: string
    promoCodeId: string
    userId: string
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: ProductUpdateOneWithoutOrderItemsNestedInput
    chatProduct?: ChatProductUpdateOneWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    chatProductId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type OrderStatusLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: OrderStatusUpdateOneRequiredWithoutOrderLogsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutOrderStatusLogsNestedInput
  }

  export type OrderStatusLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    promoCode?: PromoCodeUpdateOneRequiredWithoutUsageNestedInput
    user?: UserUpdateOneRequiredWithoutPromoCodeUsageNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    promoCodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyCustomerGroupInput = {
    id?: string
    phone: string
    email?: string | null
    firstName?: string | null
    lastName?: string | null
    role?: $Enums.UserRole
    personalDiscount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscountRuleCreateManyCustomerGroupInput = {
    id?: string
    name: string
    type: $Enums.DiscountType
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    usageLimit?: number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type UserUpdateWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    managedChats?: ChatUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carts?: CartUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    managedChats?: ChatUncheckedUpdateManyWithoutManagerNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    viewHistory?: ViewHistoryUncheckedUpdateManyWithoutUserNestedInput
    personalPromoCodes?: PromoCodeUncheckedUpdateManyWithoutPersonalUserNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutUserNestedInput
    orderStatusLogs?: OrderStatusLogUncheckedUpdateManyWithoutCreatedByNestedInput
    PushSubscription?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    NotificationLog?: NotificationLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    personalDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscountRuleUpdateWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    promoCodes?: PromoCodeUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutDiscountRuleNestedInput
  }

  export type DiscountRuleUncheckedUpdateManyWithoutCustomerGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    categories?: NullableJsonNullValueInput | InputJsonValue
    brands?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromoCodeCreateManyDiscountRuleInput = {
    id?: string
    code: string
    usageCount?: number
    usageLimit?: number | null
    personalUserId?: string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PromoCodeUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personalUser?: UserUpdateOneWithoutPersonalPromoCodesNestedInput
    orders?: OrderUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPromoCodeNestedInput
    usage?: PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeNestedInput
  }

  export type PromoCodeUncheckedUpdateManyWithoutDiscountRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    usageLimit?: NullableIntFieldUpdateOperationsInput | number | null
    personalUserId?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyPromoCodeInput = {
    id?: string
    orderNumber: string
    userId: string
    statusId: string
    subtotal: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    shippingAmount?: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    deliveryMethodId: string
    paymentMethodId: string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoCodeUsageCreateManyPromoCodeInput = {
    id?: string
    userId: string
    orderId?: string | null
    createdAt?: Date | string
  }

  export type OrderUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    status?: OrderStatusUpdateOneRequiredWithoutOrdersNestedInput
    deliveryMethod?: DeliveryMethodUpdateOneRequiredWithoutOrdersNestedInput
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    statusLogs?: OrderStatusLogUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    promoCodeUsage?: PromoCodeUsageUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    statusId?: StringFieldUpdateOperationsInput | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    shippingAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deliveryMethodId?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
    shippingAddress?: NullableJsonNullValueInput | InputJsonValue
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPromoCodeUsageNestedInput
    order?: OrderUpdateOneWithoutPromoCodeUsageNestedInput
  }

  export type PromoCodeUsageUncheckedUpdateWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUsageUncheckedUpdateManyWithoutPromoCodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}